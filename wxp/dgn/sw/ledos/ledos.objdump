
ledos.elf:     file format elf32-littlenios2
ledos.elf
architecture: nios2, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x018001c4

Program Header:
    LOAD off    0x00001000 vaddr 0x01800000 paddr 0x01800000 align 2**12
         filesz 0x00000020 memsz 0x00000020 flags r-x
    LOAD off    0x00001020 vaddr 0x01800020 paddr 0x01800020 align 2**12
         filesz 0x00009440 memsz 0x00009440 flags r-x
    LOAD off    0x0000a460 vaddr 0x01809460 paddr 0x0180af6c align 2**12
         filesz 0x00001b0c memsz 0x00001b0c flags rw-
    LOAD off    0x0000ca78 vaddr 0x0180ca78 paddr 0x0180ca78 align 2**12
         filesz 0x00000000 memsz 0x0000053c flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000020  01800000  01800000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   000001a4  01800020  01800020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         000091e8  018001c4  018001c4  000011c4  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       000000b4  018093ac  018093ac  0000a3ac  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       00001b0c  01809460  0180af6c  0000a460  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          0000053c  0180ca78  0180ca78  0000ca78  2**2
                  ALLOC, SMALL_DATA
  6 .comment      00000026  00000000  00000000  0000bf6c  2**0
                  CONTENTS, READONLY
  7 .debug_aranges 00000bb8  00000000  00000000  0000bf98  2**3
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_pubnames 0000146a  00000000  00000000  0000cb50  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_info   0002280d  00000000  00000000  0000dfba  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_abbrev 00006bf0  00000000  00000000  000307c7  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_line   0001224f  00000000  00000000  000373b7  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_frame  00001b54  00000000  00000000  00049608  2**2
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    00001b83  00000000  00000000  0004b15c  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_loc    00005070  00000000  00000000  0004ccdf  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_alt_sim_info 00000010  00000000  00000000  00051d50  2**2
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_ranges 000002f8  00000000  00000000  00051d60  2**3
                  CONTENTS, READONLY, DEBUGGING
 17 .thread_model 0000000c  00000000  00000000  000552e1  2**0
                  CONTENTS, READONLY
 18 .cpu          00000004  00000000  00000000  000552ed  2**0
                  CONTENTS, READONLY
 19 .qsys         00000001  00000000  00000000  000552f1  2**0
                  CONTENTS, READONLY
 20 .simulation_enabled 00000001  00000000  00000000  000552f2  2**0
                  CONTENTS, READONLY
 21 .sysid_hash   00000004  00000000  00000000  000552f3  2**0
                  CONTENTS, READONLY
 22 .sysid_base   00000004  00000000  00000000  000552f7  2**0
                  CONTENTS, READONLY
 23 .sysid_time   00000004  00000000  00000000  000552fb  2**0
                  CONTENTS, READONLY
 24 .stderr_dev   00000009  00000000  00000000  000552ff  2**0
                  CONTENTS, READONLY
 25 .stdin_dev    00000009  00000000  00000000  00055308  2**0
                  CONTENTS, READONLY
 26 .stdout_dev   00000009  00000000  00000000  00055311  2**0
                  CONTENTS, READONLY
 27 .sopc_system_name 00000006  00000000  00000000  0005531a  2**0
                  CONTENTS, READONLY
 28 .quartus_project_dir 00000036  00000000  00000000  00055320  2**0
                  CONTENTS, READONLY
 29 .jdi          0000476e  00000000  00000000  00055356  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
01800000 l    d  .entry	00000000 .entry
01800020 l    d  .exceptions	00000000 .exceptions
018001c4 l    d  .text	00000000 .text
018093ac l    d  .rodata	00000000 .rodata
01809460 l    d  .rwdata	00000000 .rwdata
0180ca78 l    d  .bss	00000000 .bss
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_pubnames	00000000 .debug_pubnames
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
018001fc l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 gpu.c
00000000 l    df *ABS*	00000000 vga.c
00000000 l    df *ABS*	00000000 graphics.c
00000000 l    df *ABS*	00000000 main.c
00000000 l    df *ABS*	00000000 chthreads.c
018010b0 l     F .text	00000040 list_remove
0180118c l     F .text	00000040 list_insert
00000000 l    df *ABS*	00000000 chvt.c
01801484 l       .text	00000000 _port_thread_start_loop
00000000 l    df *ABS*	00000000 alt_load.c
01801580 l     F .text	0000006c alt_load_section
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_printf.c
00000000 l    df *ABS*	00000000 alt_putchar.c
00000000 l    df *ABS*	00000000 alt_putstr.c
00000000 l    df *ABS*	00000000 alt_sys_init.c
01809460 l     O .rwdata	00001060 jtag_uart
0180a4c0 l     O .rwdata	000000c4 uart_0
018019fc l     F .text	00000038 alt_dev_reg
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_init.c
01801c3c l     F .text	00000228 altera_avalon_jtag_uart_irq
01801e64 l     F .text	000000b0 altera_avalon_jtag_uart_timeout
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_ioctl.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_avalon_timer_sc.c
018024e0 l     F .text	00000070 alt_avalon_timer_sc_irq
00000000 l    df *ABS*	00000000 altera_avalon_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_uart_init.c
018027a0 l     F .text	0000009c altera_avalon_uart_irq
0180283c l     F .text	000000e0 altera_avalon_uart_rxirq
0180291c l     F .text	0000015c altera_avalon_uart_txirq
00000000 l    df *ABS*	00000000 altera_avalon_uart_read.c
01802d08 l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 altera_avalon_uart_write.c
01802f30 l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 chdynamic.c
00000000 l    df *ABS*	00000000 chheap.c
0180caa8 l     O .bss	0000001c default_heap
00000000 l    df *ABS*	00000000 chmemcore.c
0180ca84 l     O .bss	00000004 nextmem
0180ca88 l     O .bss	00000004 endmem
00000000 l    df *ABS*	00000000 chmempools.c
00000000 l    df *ABS*	00000000 chmtx.c
01803d04 l     F .text	0000004c dequeue
01803d50 l     F .text	00000094 prio_insert
01804014 l     F .text	00000050 fifo_remove
00000000 l    df *ABS*	00000000 chschd.c
01804458 l     F .text	00000050 fifo_remove
018044a8 l     F .text	000000b8 wakeup
01804560 l     F .text	0000004c dequeue
00000000 l    df *ABS*	00000000 chsys.c
0180cac4 l     O .bss	00000048 mainthread.2251
00000000 l    df *ABS*	00000000 alt_alarm_start.c
00000000 l    df *ABS*	00000000 alt_close.c
01804ca4 l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_dev.c
01804d20 l     F .text	0000002c alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
01804e00 l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 alt_do_ctors.c
00000000 l    df *ABS*	00000000 alt_do_dtors.c
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_icache_flush_all.c
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_iic_isr_register.c
00000000 l    df *ABS*	00000000 alt_io_redirect.c
01805210 l     F .text	000000d8 alt_open_fd
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_open.c
01805360 l     F .text	000000f8 alt_file_locked
018055e4 l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 alt_release_fd.c
00000000 l    df *ABS*	00000000 alt_tick.c
00000000 l    df *ABS*	00000000 altera_nios2_qsys_irq.c
00000000 l    df *ABS*	00000000 chcore.c
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_find_file.c
00000000 l    df *ABS*	00000000 alt_get_fd.c
00000000 l    df *ABS*	00000000 atexit.c
00000000 l    df *ABS*	00000000 exit.c
00000000 l    df *ABS*	00000000 fputs.c
00000000 l    df *ABS*	00000000 fvwrite.c
00000000 l    df *ABS*	00000000 impure.c
0180a72c l     O .rwdata	00000400 impure_data
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 memchr.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 putc.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 wbuf.c
00000000 l    df *ABS*	00000000 wsetup.c
00000000 l    df *ABS*	00000000 __atexit.c
00000000 l    df *ABS*	00000000 __call_atexit.c
01807768 l     F .text	00000004 register_fini
00000000 l    df *ABS*	00000000 fflush.c
00000000 l    df *ABS*	00000000 findfp.c
01807b4c l     F .text	00000058 std
01807c58 l     F .text	00000008 __fp_lock
01807c60 l     F .text	00000008 __fp_unlock
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 fwalk.c
00000000 l    df *ABS*	00000000 makebuf.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 stdio.c
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 closer.c
00000000 l    df *ABS*	00000000 fclose.c
00000000 l    df *ABS*	00000000 fstatr.c
00000000 l    df *ABS*	00000000 isattyr.c
00000000 l    df *ABS*	00000000 lseekr.c
00000000 l    df *ABS*	00000000 readr.c
00000000 l    df *ABS*	00000000 lib2-mul.c
00000000 l    df *ABS*	00000000 alt_exit.c
01808b90 l     F .text	00000040 alt_sim_halt
00000000 l    df *ABS*	00000000 alt_fstat.c
01808ccc l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 alt_isatty.c
01808df0 l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 alt_lseek.c
01808f44 l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 alt_malloc_lock.c
00000000 l    df *ABS*	00000000 alt_read.c
01809108 l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 alt_sbrk.c
0180af68 l     O .rwdata	00000004 heap_end
00000000 l    df *ABS*	00000000 alt_write.c
01809348 l     F .text	00000060 alt_get_errno
018038fc g     F .text	00000060 chPoolInit
018007d8 g     F .text	00000010 enable_gpu
018089f8 g     F .text	00000070 _isatty_r
018015ec g     F .text	00000088 alt_main
01804924 g     F .text	0000012c chSysTimerHandlerI
01800fb0 g     F .text	00000048 chThdExit
018045ac g     F .text	00000090 chSchGoSleepTimeoutS
0180cd24 g     O .bss	00000100 alt_irq
01808a68 g     F .text	00000078 _lseek_r
0180af6c g       *ABS*	00000000 __flash_rwdata_start
01803ba0 g     F .text	00000164 chMtxLockS
018031ec g     F .text	000000d0 chThdCreateFromMemoryPool
0180cfb4 g       *ABS*	00000000 __alt_heap_start
01803e44 g     F .text	00000084 chMtxTryLockS
01803558 g     F .text	00000188 chHeapFree
01808634 g     F .text	00000068 __sseek
01807bb4 g     F .text	000000a4 __sinit
018073ac g     F .text	00000130 __swbuf_r
01807cb4 g     F .text	0000009c __sfmoreglue
01808fc4 g     F .text	00000020 __malloc_unlock
01806a08 g     F .text	000000e0 memmove
01807ca4 g     F .text	00000010 _cleanup
0180190c g     F .text	00000040 alt_putstr
018043c0 g     F .text	00000098 chSchGoSleepS
00000000  w      *UND*	00000000 __errno
01800000 g     F .entry	0000000c __reset
01800020 g       *ABS*	00000000 __flash_exceptions_start
01808984 g     F .text	00000074 _fstat_r
0180ca98 g     O .bss	00000004 errno
01800aec g     F .text	00000158 chThdCreateI
0180ca7c g     O .bss	00000004 alt_argv
01812f34 g       *ABS*	00000000 _gp
0180463c g     F .text	000000ac chSchWakeupS
01804288 g     F .text	00000090 _scheduler_init
018046e8 g     F .text	0000004c chSchRescheduleS
01800c44 g     F .text	0000008c chThdCreateStatic
0180a5ac g     O .rwdata	00000180 alt_fd_list
018058d4 g     F .text	00000094 alt_find_dev
01806968 g     F .text	000000a0 memcpy
01807c98 g     F .text	0000000c _cleanup_r
018052e8 g     F .text	00000078 alt_io_redirect
018093ac g       *ABS*	00000000 __DTOR_END__
01804318 g     F .text	000000a8 chSchReadyI
01805884  w    F .text	00000028 port_halt
018011cc g     F .text	00000064 _vt_init
01803854 g     F .text	0000007c chCoreAllocI
0180207c g     F .text	00000224 altera_avalon_jtag_uart_read
00000000  w      *UND*	00000000 malloc
01808d2c g     F .text	000000c4 isatty
018032bc g     F .text	0000005c _heap_init
0180ca9c g     O .bss	00000004 __malloc_top_pad
01803128 g     F .text	000000c4 chThdCreateFromHeap
01805c34 g     F .text	0000049c __sfvwrite_r
018072c8 g     F .text	00000070 _sbrk_r
018003c8 g     F .text	0000014c gpu_fill
01808ae0 g     F .text	00000078 _read_r
018036e0 g     F .text	000000c8 chHeapStatus
0180af44 g     O .rwdata	00000004 alt_max_fd
01808860 g     F .text	00000110 _fclose_r
01807b18 g     F .text	00000034 fflush
0180caa0 g     O .bss	00000004 __malloc_max_sbrked_mem
01800ff8 g     F .text	000000b8 chThdExitS
01808e50 g     F .text	000000f4 lseek
0180af5c g     O .rwdata	00000004 _global_impure_ptr
01806cd4 g     F .text	000005f4 _realloc_r
0180cfb4 g       *ABS*	00000000 __bss_end
01805118 g     F .text	000000f8 alt_iic_isr_register
01805754 g     F .text	00000110 alt_tick
018026d8 g     F .text	000000c8 altera_avalon_uart_init
01807c80 g     F .text	00000018 __fp_lock_all
018050d0 g     F .text	00000048 alt_ic_irq_enabled
018056bc g     F .text	00000098 alt_alarm_stop
0180ca8c g     O .bss	00000004 alt_irq_active
01801230 g     F .text	00000114 chVTSetI
018000ec g     F .exceptions	000000d8 alt_irq_handler
0180a584 g     O .rwdata	00000028 alt_dev_null
01800248 g     F .text	00000018 vga_en
01804d04 g     F .text	0000001c alt_dcache_flush_all
0180af6c g       *ABS*	00000000 __ram_rwdata_end
0180af3c g     O .rwdata	00000008 alt_dev_list
01809224 g     F .text	00000124 write
01806bec g     F .text	000000e8 _putc_r
01809460 g       *ABS*	00000000 __ram_rodata_end
01808bf4 g     F .text	000000d8 fstat
01803b48 g     F .text	00000058 chMtxLock
018038d0 g     F .text	0000002c chCoreStatus
018047b4 g     F .text	00000090 chSchDoReschedule
01804874 g     F .text	000000b0 chSysInit
01800e60 g     F .text	0000005c chThdSleep
0180cfb4 g       *ABS*	00000000 end
018013cc g     F .text	000000a8 chTimeIsWithin
01802d68 g     F .text	000001c8 altera_avalon_uart_write
01801b7c g     F .text	000000c0 altera_avalon_jtag_uart_init
018093a8 g       *ABS*	00000000 __CTOR_LIST__
02000000 g       *ABS*	00000000 __alt_stack_pointer
01802550 g     F .text	00000090 alt_avalon_timer_sc_init
01802638 g     F .text	00000058 altera_avalon_uart_write_fd
01802690 g     F .text	00000048 altera_avalon_uart_close_fd
018022a0 g     F .text	00000240 altera_avalon_jtag_uart_write
01807ba4 g     F .text	00000004 __sfp_lock_acquire
01806810 g     F .text	000000e4 memchr
018007c8 g     F .text	00000010 disable_gpu
01807f6c g     F .text	00000314 _free_r
01801674 g     F .text	00000258 alt_printf
0180395c g     F .text	00000084 chPoolAllocI
0180776c g     F .text	000001b0 __call_exitprocs
0180af64 g     O .rwdata	00000004 __malloc_sbrk_base
018001c4 g     F .text	0000003c _start
018037a8 g     F .text	0000004c _core_init
01804064 g     F .text	00000120 chMtxUnlockS
0180ca90 g     O .bss	00000004 _alt_tick_rate
018058ac g     F .text	00000028 port_time_tick
01800da0 g     F .text	00000060 chThdResume
01803de4 g     F .text	00000060 chMtxTryLock
0180ca94 g     O .bss	00000004 _alt_nticks
01808fe4 g     F .text	00000124 read
01801980 g     F .text	0000007c alt_sys_init
01807634 g     F .text	00000134 __register_exitproc
01804184 g     F .text	00000104 chMtxUnlockAll
018039e0 g     F .text	00000060 chPoolAlloc
01801f14 g     F .text	00000074 altera_avalon_jtag_uart_close
01808b58 g     F .text	00000038 __mulsi3
01809460 g       *ABS*	00000000 __ram_rwdata_start
018093ac g       *ABS*	00000000 __ram_rodata_start
0180cb0c g     O .bss	00000028 __malloc_current_mallinfo
0180cb34 g     O .bss	00000010 vtlist
0180022c g     F .text	0000001c vga_disable
01801a34 g     F .text	00000058 altera_avalon_jtag_uart_read_fd
01805a88 g     F .text	000000d0 alt_get_fd
018037f4 g     F .text	00000060 chCoreAlloc
018087f0 g     F .text	00000070 _close_r
018033a0 g     F .text	000001b8 chHeapAlloc
01802f90 g     F .text	00000064 chThdAddRef
018068f4 g     F .text	00000074 memcmp
01800200 g     F .text	0000002c set_vga_mode
01801ae4 g     F .text	00000048 altera_avalon_jtag_uart_close_fd
0180cfb4 g       *ABS*	00000000 __alt_stack_base
01801b2c g     F .text	00000050 altera_avalon_jtag_uart_ioctl_fd
01801488 g       .text	00000000 port_switch
018074f8 g     F .text	0000013c __swsetup_r
01807d50 g     F .text	000000f0 __sfp
0180ab2c g     O .rwdata	00000408 __malloc_av_
01807bb0 g     F .text	00000004 __sinit_lock_release
01808718 g     F .text	00000060 __sread
01805968 g     F .text	00000120 alt_find_file
01804d4c g     F .text	000000b4 alt_dev_llist_insert
01808fa4 g     F .text	00000020 __malloc_lock
01809168 g     F .text	000000bc sbrk
0180791c g     F .text	000001fc _fflush_r
0180ca78 g       *ABS*	00000000 __bss_start
01800ebc g     F .text	00000080 chThdSleepUntil
01808594 g     F .text	00000098 memset
018007e8 g     F .text	00000200 main
0180ca80 g     O .bss	00000004 alt_envp
0180caa4 g     O .bss	00000004 __malloc_max_total_mem
01801a8c g     F .text	00000058 altera_avalon_jtag_uart_write_fd
0180cb44 g     O .bss	00000020 rlist
018074dc g     F .text	0000001c __swbuf
0180862c g     F .text	00000008 __sclose
02000000 g       *ABS*	00000000 __alt_heap_limit
01808970 g     F .text	00000014 fclose
0180ce24 g     O .bss	00000190 _atexit0
018060d0 g     F .text	00000740 _malloc_r
0180af48 g     O .rwdata	00000004 alt_errno
01808348 g     F .text	000000b8 _fwalk
01803b00 g     F .text	00000048 chMtxInit
01804844 g     F .text	00000030 _idle_thread
01806ae8 g     F .text	00000104 putc
01807e40 g     F .text	0000012c _malloc_trim_r
018093ac g       *ABS*	00000000 __CTOR_END__
018093ac g       *ABS*	00000000 __flash_rodata_start
018093ac g       *ABS*	00000000 __DTOR_LIST__
01801474 g       .text	00000000 _port_thread_start
01803a40 g     F .text	00000060 chPoolFreeI
0180194c g     F .text	00000034 alt_irq_init
01805644 g     F .text	00000078 alt_release_fd
01805b58 g     F .text	00000014 atexit
01808778 g     F .text	00000078 _write_r
0180af58 g     O .rwdata	00000004 _impure_ptr
0180ca78 g     O .bss	00000004 alt_argc
01804ec4 g     F .text	00000064 _do_dtors
01802ff4 g     F .text	00000134 chThdRelease
01800020 g       .exceptions	00000000 alt_irq_entry
0180cb64 g     O .bss	000001c0 _idle_thread_wa
01807c68 g     F .text	00000018 __fp_unlock_all
01803aa0 g     F .text	00000060 chPoolFree
0180af34 g     O .rwdata	00000008 alt_fs_list
01800020 g       *ABS*	00000000 __ram_exceptions_start
01803ec8 g     F .text	0000014c chMtxUnlock
01804f44 g     F .text	00000050 alt_ic_isr_register
0180af6c g       *ABS*	00000000 _edata
018025e0 g     F .text	00000058 altera_avalon_uart_read_fd
0180cfb4 g       *ABS*	00000000 _end
018001c4 g       *ABS*	00000000 __ram_exceptions_end
01801344 g     F .text	00000088 chVTResetI
01801f88 g     F .text	000000f4 altera_avalon_jtag_uart_ioctl
01805ba4 g     F .text	00000074 _fputs_r
01805030 g     F .text	000000a0 alt_ic_irq_disable
0180869c g     F .text	0000007c __swrite
0180af60 g     O .rwdata	00000004 __malloc_trim_threshold
01805864 g     F .text	00000020 altera_nios2_qsys_irq_init
01805b6c g     F .text	00000038 exit
01808280 g     F .text	000000c8 _fwalk_reent
02000000 g       *ABS*	00000000 __alt_data_end
01800020 g     F .exceptions	00000000 alt_exception
01807ba8 g     F .text	00000004 __sfp_lock_release
01800000 g       *ABS*	00000000 __alt_mem_sdram
01800cd0 g     F .text	000000d0 chThdSetPriority
018010f0 g     F .text	0000009c chThdWait
01802a78 g     F .text	00000060 altera_avalon_uart_close
01804734 g     F .text	00000080 chSchIsPreemptionRequired
01808bd0 g     F .text	00000024 _exit
01804a50 g     F .text	00000154 alt_alarm_start
018009e8 g     F .text	00000104 _thread_init
01808400 g     F .text	00000194 __smakebuf_r
01807338 g     F .text	00000074 strlen
01805458 g     F .text	0000018c open
018018cc g     F .text	00000040 alt_putchar
01800f3c g     F .text	00000074 chThdYield
01804f28 g     F .text	0000001c alt_icache_flush_all
01805c18 g     F .text	0000001c fputs
0180af4c g     O .rwdata	00000004 alt_priority_mask
01803318 g     F .text	00000088 chHeapInit
01804f94 g     F .text	0000009c alt_ic_irq_enable
01802ad8 g     F .text	00000230 altera_avalon_uart_read
01800514 g     F .text	0000017c gpu_draw_bezier
0180af50 g     O .rwdata	00000008 alt_alarm_list
01800690 g     F .text	00000138 gpu_draw_line
01804e60 g     F .text	00000064 _do_ctors
01804ba4 g     F .text	00000100 close
01800260 g     F .text	00000168 gpu_hst_acc
01800e00 g     F .text	00000060 chThdTerminate
01801500 g     F .text	00000080 alt_load
00000000  w      *UND*	00000000 free
01807bac g     F .text	00000004 __sinit_lock_acquire



Disassembly of section .entry:

01800000 <__reset>:
 * Jump to the _start entry point in the .text section if reset code
 * is allowed or if optimizing for RTL simulation.
 */
#if defined(ALT_ALLOW_CODE_AT_RESET) || defined(ALT_SIM_OPTIMIZE)
    /* Jump to the _start entry point in the .text section. */
    movhi r1, %hi(_start)
 1800000:	00406034 	movhi	at,384
    ori r1, r1, %lo(_start)
 1800004:	08407114 	ori	at,at,452
    jmp r1
 1800008:	0800683a 	jmp	at
	...

Disassembly of section .exceptions:

01800020 <alt_exception>:
         * Process an exception.  For all exceptions we must preserve all
         * caller saved registers on the stack (See the Nios2 ABI
         * documentation for details).
         */

        addi  sp, sp, -76
 1800020:	deffed04 	addi	sp,sp,-76

#endif

#endif

        stw   ra,  0(sp)
 1800024:	dfc00015 	stw	ra,0(sp)
        /*
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */

        stw   r1,   8(sp)
 1800028:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
 180002c:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
 1800030:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
 1800034:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
 1800038:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
 180003c:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
 1800040:	d9c00815 	stw	r7,32(sp)

        rdctl r5, estatus
 1800044:	000b307a 	rdctl	r5,estatus

        stw   r8,  36(sp)
 1800048:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
 180004c:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
 1800050:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
 1800054:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
 1800058:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
 180005c:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
 1800060:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
 1800064:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
 1800068:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
 180006c:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
 1800070:	dbc01215 	stw	r15,72(sp)
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
 1800074:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
 1800078:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
 180007c:	10000326 	beq	r2,zero,180008c <alt_exception+0x6c>
        beq   r4, zero, .Lnot_irq
 1800080:	20000226 	beq	r4,zero,180008c <alt_exception+0x6c>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
 1800084:	18000ec0 	call	18000ec <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
 1800088:	00000306 	br	1800098 <alt_exception+0x78>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw   ea,  72(sp)  /* Don't re-issue */
 180008c:	df401215 	stw	ea,72(sp)
        ldw   r2, -4(ea)   /* Instruction that caused exception */
 1800090:	e8bfff17 	ldw	r2,-4(ea)
#ifdef NIOS2_HAS_DEBUG_STUB
       /*
        *  Either tell the user now (if there is a debugger attached) or go into
        *  the debug monitor which will loop until a debugger is attached.
        */
        break
 1800094:	003da03a 	break	0
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
 1800098:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
 180009c:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
 18000a0:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
 18000a4:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
 18000a8:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
 18000ac:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
 18000b0:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
 18000b4:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
 18000b8:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
 18000bc:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
 18000c0:	d9c00817 	ldw	r7,32(sp)
#ifdef ALT_STACK_CHECK
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif
#endif

        ldw   r8,  36(sp)
 18000c4:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
 18000c8:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
 18000cc:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
 18000d0:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
 18000d4:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
 18000d8:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
 18000dc:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
 18000e0:	dbc01017 	ldw	r15,64(sp)
#endif

        ldw   sp,  76(sp)

#else
        addi  sp, sp, 76
 18000e4:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
 18000e8:	ef80083a 	eret

018000ec <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
 18000ec:	defff904 	addi	sp,sp,-28
 18000f0:	dfc00615 	stw	ra,24(sp)
 18000f4:	df000515 	stw	fp,20(sp)
 18000f8:	df000504 	addi	fp,sp,20
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
 18000fc:	0005313a 	rdctl	r2,ipending
 1800100:	e0bffc15 	stw	r2,-16(fp)

  return active;
 1800104:	e0bffc17 	ldw	r2,-16(fp)
   * Consider the case where the high priority interupt is asserted during
   * the interrupt entry sequence for a lower priority interrupt to see why
   * this is the case.
   */

  active = alt_irq_pending ();
 1800108:	e0bfff15 	stw	r2,-4(fp)

  do
  {
    i = 0;
 180010c:	e03ffd15 	stw	zero,-12(fp)
    mask = 1;
 1800110:	00800044 	movi	r2,1
 1800114:	e0bffe15 	stw	r2,-8(fp)
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
 1800118:	e0ffff17 	ldw	r3,-4(fp)
 180011c:	e0bffe17 	ldw	r2,-8(fp)
 1800120:	1884703a 	and	r2,r3,r2
 1800124:	1005003a 	cmpeq	r2,r2,zero
 1800128:	1000161e 	bne	r2,zero,1800184 <alt_irq_handler+0x98>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
 180012c:	e0bffd17 	ldw	r2,-12(fp)
 1800130:	00c06074 	movhi	r3,385
 1800134:	18f34904 	addi	r3,r3,-13020
 1800138:	100490fa 	slli	r2,r2,3
 180013c:	10c5883a 	add	r2,r2,r3
 1800140:	11400017 	ldw	r5,0(r2)
 1800144:	e0bffd17 	ldw	r2,-12(fp)
 1800148:	00c06074 	movhi	r3,385
 180014c:	18f34904 	addi	r3,r3,-13020
 1800150:	100490fa 	slli	r2,r2,3
 1800154:	10c5883a 	add	r2,r2,r3
 1800158:	10800104 	addi	r2,r2,4
 180015c:	11000017 	ldw	r4,0(r2)
 1800160:	283ee83a 	callr	r5
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
 1800164:	0005313a 	rdctl	r2,ipending
 1800168:	e0bffb15 	stw	r2,-20(fp)

  return active;
 180016c:	e0bffb17 	ldw	r2,-20(fp)
      mask <<= 1;
      i++;

    } while (1);

    active = alt_irq_pending ();
 1800170:	e0bfff15 	stw	r2,-4(fp)
    
  } while (active);
 1800174:	e0bfff17 	ldw	r2,-4(fp)
 1800178:	1004c03a 	cmpne	r2,r2,zero
 180017c:	103fe31e 	bne	r2,zero,180010c <alt_irq_handler+0x20>
 1800180:	00000706 	br	18001a0 <alt_irq_handler+0xb4>
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
      }
      mask <<= 1;
 1800184:	e0bffe17 	ldw	r2,-8(fp)
 1800188:	1085883a 	add	r2,r2,r2
 180018c:	e0bffe15 	stw	r2,-8(fp)
      i++;
 1800190:	e0bffd17 	ldw	r2,-12(fp)
 1800194:	10800044 	addi	r2,r2,1
 1800198:	e0bffd15 	stw	r2,-12(fp)

    } while (1);
 180019c:	003fde06 	br	1800118 <alt_irq_handler+0x2c>

  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
 18001a0:	18047340 	call	1804734 <chSchIsPreemptionRequired>
 18001a4:	1005003a 	cmpeq	r2,r2,zero
 18001a8:	1000011e 	bne	r2,zero,18001b0 <alt_irq_handler+0xc4>
 18001ac:	18047b40 	call	18047b4 <chSchDoReschedule>
}
 18001b0:	e037883a 	mov	sp,fp
 18001b4:	dfc00117 	ldw	ra,4(sp)
 18001b8:	df000017 	ldw	fp,0(sp)
 18001bc:	dec00204 	addi	sp,sp,8
 18001c0:	f800283a 	ret

Disassembly of section .text:

018001c4 <_start>:
#if (NIOS2_NUM_OF_SHADOW_REG_SETS == 0)    
    /*
     * Now that the caches are initialized, set up the stack pointer.
     * The value provided by the linker is assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
 18001c4:	06c08034 	movhi	sp,512
    ori sp, sp, %lo(__alt_stack_pointer)
 18001c8:	dec00014 	ori	sp,sp,0

    /* Set up the global pointer. */
    movhi gp, %hi(_gp)
 18001cc:	06806074 	movhi	gp,385
    ori gp, gp, %lo(_gp)
 18001d0:	d68bcd14 	ori	gp,gp,12084
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
 18001d4:	00806034 	movhi	r2,384
    ori r2, r2, %lo(__bss_start)
 18001d8:	10b29e14 	ori	r2,r2,51832

    movhi r3, %hi(__bss_end)
 18001dc:	00c06034 	movhi	r3,384
    ori r3, r3, %lo(__bss_end)
 18001e0:	18f3ed14 	ori	r3,r3,53172

    beq r2, r3, 1f
 18001e4:	10c00326 	beq	r2,r3,18001f4 <_start+0x30>

0:
    stw zero, (r2)
 18001e8:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
 18001ec:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
 18001f0:	10fffd36 	bltu	r2,r3,18001e8 <_start+0x24>
     * section aren't defined until alt_load() has been called).
     */
    mov   et, zero
#endif

    call alt_load
 18001f4:	18015000 	call	1801500 <alt_load>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
 18001f8:	18015ec0 	call	18015ec <alt_main>

018001fc <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
 18001fc:	003fff06 	br	18001fc <alt_after_alt_main>

01800200 <set_vga_mode>:
	IOWR_VCORTEX_VGA_CONTROL(IORD_VCORTEX_VGA_CONTROL & ~VCORTEX_VGA_EN_MSK);
	return;
}

void set_vga_mode(VGA_MODE_T mode){
	IOWR_VCORTEX_VGA_CONTROL(IORD_VCORTEX_VGA_CONTROL & ~VCORTEX_VGA_MODE_MSK);
 1800200:	01400074 	movhi	r5,1
 1800204:	29440004 	addi	r5,r5,4096
 1800208:	28800037 	ldwio	r2,0(r5)
 180020c:	00ffff44 	movi	r3,-3
 1800210:	10c4703a 	and	r2,r2,r3
 1800214:	28800035 	stwio	r2,0(r5)
	IOWR_VCORTEX_VGA_CONTROL(IORD_VCORTEX_VGA_CONTROL | (mode & VCORTEX_VGA_MODE_MSK));
 1800218:	28800037 	ldwio	r2,0(r5)
 180021c:	2100008c 	andi	r4,r4,2
 1800220:	1104b03a 	or	r2,r2,r4
 1800224:	28800035 	stwio	r2,0(r5)
	return;
}
 1800228:	f800283a 	ret

0180022c <vga_disable>:
	IOWR_VCORTEX_VGA_CONTROL(IORD_VCORTEX_VGA_CONTROL | VCORTEX_VGA_EN_MSK);
	return;
}

void vga_disable() {
	IOWR_VCORTEX_VGA_CONTROL(IORD_VCORTEX_VGA_CONTROL & ~VCORTEX_VGA_EN_MSK);
 180022c:	00800074 	movhi	r2,1
 1800230:	10840004 	addi	r2,r2,4096
 1800234:	10c00037 	ldwio	r3,0(r2)
 1800238:	013fff84 	movi	r4,-2
 180023c:	1906703a 	and	r3,r3,r4
 1800240:	10c00035 	stwio	r3,0(r2)
	return;
}
 1800244:	f800283a 	ret

01800248 <vga_en>:
*/

#include "vga.h"

void vga_en() {
	IOWR_VCORTEX_VGA_CONTROL(IORD_VCORTEX_VGA_CONTROL | VCORTEX_VGA_EN_MSK);
 1800248:	00c00074 	movhi	r3,1
 180024c:	18c40004 	addi	r3,r3,4096
 1800250:	18800037 	ldwio	r2,0(r3)
 1800254:	10800054 	ori	r2,r2,1
 1800258:	18800035 	stwio	r2,0(r3)
	return;
}
 180025c:	f800283a 	ret

01800260 <gpu_hst_acc>:
	}

	return;
}

GPU_HST_ACC_JOB_T gpu_hst_acc(GPU_HST_ACC_JOB_T job, alt_u8 wait) {
 1800260:	defff404 	addi	sp,sp,-48
 1800264:	d9c00215 	stw	r7,8(sp)
 1800268:	d9800115 	stw	r6,4(sp)
 180026c:	ddc00a15 	stw	r23,40(sp)
 1800270:	dd800915 	stw	r22,36(sp)
 1800274:	dd400815 	stw	r21,32(sp)
 1800278:	dd000715 	stw	r20,28(sp)
 180027c:	dcc00615 	stw	r19,24(sp)
 1800280:	dc800515 	stw	r18,20(sp)
 1800284:	ddc00c03 	ldbu	r23,48(sp)
 1800288:	dd000283 	ldbu	r20,10(sp)
 180028c:	dc800243 	ldbu	r18,9(sp)
 1800290:	dcc00203 	ldbu	r19,8(sp)
 1800294:	dd80018b 	ldhu	r22,6(sp)
 1800298:	dd40010b 	ldhu	r21,4(sp)
 180029c:	dc400415 	stw	r17,16(sp)
 18002a0:	dc000315 	stw	r16,12(sp)
 18002a4:	2823883a 	mov	r17,r5
 18002a8:	2021883a 	mov	r16,r4
 18002ac:	dfc00b15 	stw	ra,44(sp)
 18002b0:	d9400015 	stw	r5,0(sp)
 18002b4:	00000106 	br	18002bc <gpu_hst_acc+0x5c>
									 VCORTEX_GPU_STATUS_HST_MUL_DONE_MSK + \
									 VCORTEX_GPU_STATUS_PICASSO_BUSY_MSK + \
									 VCORTEX_GPU_STATUS_EUCLID_BUSY_MSK))   \
			!= (VCORTEX_GPU_STATUS_HST_MUL_DONE_MSK+VCORTEX_GPU_STATUS_HST_ACC_DONE_MSK))
	{
		chThdSleepMilliseconds(1);
 18002b8:	1800e600 	call	1800e60 <chThdSleep>

GPU_HST_ACC_JOB_T gpu_hst_acc(GPU_HST_ACC_JOB_T job, alt_u8 wait) {
	alt_u32 res;

	//wait for GPU to be free
	while((IORD_VCORTEX_GPU_STATUS &(VCORTEX_GPU_STATUS_HST_ACC_DONE_MSK + \
 18002bc:	00800074 	movhi	r2,1
 18002c0:	10800404 	addi	r2,r2,16
 18002c4:	10800037 	ldwio	r2,0(r2)
 18002c8:	00c00304 	movi	r3,12
 18002cc:	108003cc 	andi	r2,r2,15
									 VCORTEX_GPU_STATUS_HST_MUL_DONE_MSK + \
									 VCORTEX_GPU_STATUS_PICASSO_BUSY_MSK + \
									 VCORTEX_GPU_STATUS_EUCLID_BUSY_MSK))   \
			!= (VCORTEX_GPU_STATUS_HST_MUL_DONE_MSK+VCORTEX_GPU_STATUS_HST_ACC_DONE_MSK))
	{
		chThdSleepMilliseconds(1);
 18002d0:	01000044 	movi	r4,1

GPU_HST_ACC_JOB_T gpu_hst_acc(GPU_HST_ACC_JOB_T job, alt_u8 wait) {
	alt_u32 res;

	//wait for GPU to be free
	while((IORD_VCORTEX_GPU_STATUS &(VCORTEX_GPU_STATUS_HST_ACC_DONE_MSK + \
 18002d4:	10fff81e 	bne	r2,r3,18002b8 <gpu_hst_acc+0x58>
	{
		chThdSleepMilliseconds(1);
	}


	IOWR_VCORTEX_GPU_JOB_BFFR_1(job.action);
 18002d8:	00800074 	movhi	r2,1
 18002dc:	10800c04 	addi	r2,r2,48
 18002e0:	14400035 	stwio	r17,0(r2)
	IOWR_VCORTEX_GPU_JOB_BFFR_2(job.ptr.x);
 18002e4:	a8ffffcc 	andi	r3,r21,65535
 18002e8:	10800404 	addi	r2,r2,16
 18002ec:	10c00035 	stwio	r3,0(r2)
	IOWR_VCORTEX_GPU_JOB_BFFR_3(job.ptr.y);
 18002f0:	b0ffffcc 	andi	r3,r22,65535
 18002f4:	10800404 	addi	r2,r2,16
 18002f8:	10c00035 	stwio	r3,0(r2)
	IOWR_VCORTEX_GPU_JOB_BFFR_4(PACK_HSI_PXL(job.color));
 18002fc:	98803fcc 	andi	r2,r19,255
 1800300:	90c03fcc 	andi	r3,r18,255
 1800304:	1004917a 	slli	r2,r2,5
 1800308:	180690fa 	slli	r3,r3,3
 180030c:	a1003fcc 	andi	r4,r20,255
 1800310:	1105883a 	add	r2,r2,r4
 1800314:	1887883a 	add	r3,r3,r2
 1800318:	00800074 	movhi	r2,1
 180031c:	10801804 	addi	r2,r2,96
 1800320:	10c00035 	stwio	r3,0(r2)
	IOWR_VCORTEX_GPU_JOB_BFFR_0(DEBUG);
 1800324:	00c000c4 	movi	r3,3
 1800328:	10bff004 	addi	r2,r2,-64
 180032c:	10c00035 	stwio	r3,0(r2)

	if(wait || (job.action == READ)) {
 1800330:	b800041e 	bne	r23,zero,1800344 <gpu_hst_acc+0xe4>
 1800334:	00800044 	movi	r2,1
 1800338:	8880111e 	bne	r17,r2,1800380 <gpu_hst_acc+0x120>
 180033c:	00000106 	br	1800344 <gpu_hst_acc+0xe4>
		while(!(IORD_VCORTEX_GPU_STATUS & VCORTEX_GPU_STATUS_HST_ACC_DONE_MSK)) {
			chThdSleepMilliseconds(1);
 1800340:	1800e600 	call	1800e60 <chThdSleep>
	IOWR_VCORTEX_GPU_JOB_BFFR_3(job.ptr.y);
	IOWR_VCORTEX_GPU_JOB_BFFR_4(PACK_HSI_PXL(job.color));
	IOWR_VCORTEX_GPU_JOB_BFFR_0(DEBUG);

	if(wait || (job.action == READ)) {
		while(!(IORD_VCORTEX_GPU_STATUS & VCORTEX_GPU_STATUS_HST_ACC_DONE_MSK)) {
 1800344:	00800074 	movhi	r2,1
 1800348:	10800404 	addi	r2,r2,16
 180034c:	10800037 	ldwio	r2,0(r2)
			chThdSleepMilliseconds(1);
 1800350:	01000044 	movi	r4,1
	IOWR_VCORTEX_GPU_JOB_BFFR_3(job.ptr.y);
	IOWR_VCORTEX_GPU_JOB_BFFR_4(PACK_HSI_PXL(job.color));
	IOWR_VCORTEX_GPU_JOB_BFFR_0(DEBUG);

	if(wait || (job.action == READ)) {
		while(!(IORD_VCORTEX_GPU_STATUS & VCORTEX_GPU_STATUS_HST_ACC_DONE_MSK)) {
 1800354:	1080010c 	andi	r2,r2,4
 1800358:	103ff926 	beq	r2,zero,1800340 <gpu_hst_acc+0xe0>
			chThdSleepMilliseconds(1);
		}
	}

	if(job.action == READ) {
 180035c:	8900081e 	bne	r17,r4,1800380 <gpu_hst_acc+0x120>
		res = IORD_VCORTEX_GPU_JOB_BFFR_4;
 1800360:	00800074 	movhi	r2,1
 1800364:	10801804 	addi	r2,r2,96
 1800368:	10800037 	ldwio	r2,0(r2)

		job.color.i = res & 0x7;
		job.color.s = (res >> INTENSITY_W) & 0x3;
		job.color.h = (res >> (SATURATION_W+INTENSITY_W)) & 0x7;
 180036c:	1006d17a 	srli	r3,r2,5

	if(job.action == READ) {
		res = IORD_VCORTEX_GPU_JOB_BFFR_4;

		job.color.i = res & 0x7;
		job.color.s = (res >> INTENSITY_W) & 0x3;
 1800370:	1008d0fa 	srli	r4,r2,3
	}

	if(job.action == READ) {
		res = IORD_VCORTEX_GPU_JOB_BFFR_4;

		job.color.i = res & 0x7;
 1800374:	150001cc 	andi	r20,r2,7
		job.color.s = (res >> INTENSITY_W) & 0x3;
		job.color.h = (res >> (SATURATION_W+INTENSITY_W)) & 0x7;
 1800378:	1cc001cc 	andi	r19,r3,7

	if(job.action == READ) {
		res = IORD_VCORTEX_GPU_JOB_BFFR_4;

		job.color.i = res & 0x7;
		job.color.s = (res >> INTENSITY_W) & 0x3;
 180037c:	248000cc 	andi	r18,r4,3

	//alt_printf("[gpu_hst_acc] Done RD/WR:%c ptr.x:0x%x ptr.y0x%x\n",job.action,job.ptr.x,job.ptr.y);


	return job;
}
 1800380:	8005883a 	mov	r2,r16
	}

	//alt_printf("[gpu_hst_acc] Done RD/WR:%c ptr.x:0x%x ptr.y0x%x\n",job.action,job.ptr.x,job.ptr.y);


	return job;
 1800384:	85000285 	stb	r20,10(r16)
 1800388:	84800245 	stb	r18,9(r16)
 180038c:	84c00205 	stb	r19,8(r16)
 1800390:	8580018d 	sth	r22,6(r16)
 1800394:	8540010d 	sth	r21,4(r16)
 1800398:	84400015 	stw	r17,0(r16)
}
 180039c:	dfc00b17 	ldw	ra,44(sp)
 18003a0:	ddc00a17 	ldw	r23,40(sp)
 18003a4:	dd800917 	ldw	r22,36(sp)
 18003a8:	dd400817 	ldw	r21,32(sp)
 18003ac:	dd000717 	ldw	r20,28(sp)
 18003b0:	dcc00617 	ldw	r19,24(sp)
 18003b4:	dc800517 	ldw	r18,20(sp)
 18003b8:	dc400417 	ldw	r17,16(sp)
 18003bc:	dc000317 	ldw	r16,12(sp)
 18003c0:	dec00c04 	addi	sp,sp,48
 18003c4:	f800283a 	ret

018003c8 <gpu_fill>:
	}

	return;
}

void gpu_fill(GPU_FILL_JOB_T job, alt_u8 wait) {
 18003c8:	defff304 	addi	sp,sp,-52
 18003cc:	d9000015 	stw	r4,0(sp)
 18003d0:	d9400115 	stw	r5,4(sp)
 18003d4:	d9800215 	stw	r6,8(sp)
 18003d8:	df000b15 	stw	fp,44(sp)
 18003dc:	dd800915 	stw	r22,36(sp)
 18003e0:	dd400815 	stw	r21,32(sp)
 18003e4:	dd000715 	stw	r20,28(sp)
 18003e8:	dcc00615 	stw	r19,24(sp)
 18003ec:	dc800515 	stw	r18,20(sp)
 18003f0:	dc400415 	stw	r17,16(sp)
 18003f4:	dc000315 	stw	r16,12(sp)
 18003f8:	df00020b 	ldhu	fp,8(sp)
 18003fc:	dd80018b 	ldhu	r22,6(sp)
 1800400:	dd400143 	ldbu	r21,5(sp)
 1800404:	dd000103 	ldbu	r20,4(sp)
 1800408:	dcc000c3 	ldbu	r19,3(sp)
 180040c:	dc800083 	ldbu	r18,2(sp)
 1800410:	dc400043 	ldbu	r17,1(sp)
 1800414:	dc000003 	ldbu	r16,0(sp)
 1800418:	ddc00a15 	stw	r23,40(sp)
 180041c:	382f883a 	mov	r23,r7
 1800420:	dfc00c15 	stw	ra,48(sp)
 1800424:	00000106 	br	180042c <gpu_fill+0x64>
									 VCORTEX_GPU_STATUS_HST_MUL_DONE_MSK + \
									 VCORTEX_GPU_STATUS_PICASSO_BUSY_MSK + \
									 VCORTEX_GPU_STATUS_EUCLID_BUSY_MSK))   \
			!= (VCORTEX_GPU_STATUS_HST_MUL_DONE_MSK+VCORTEX_GPU_STATUS_HST_ACC_DONE_MSK))
	{
		chThdSleepMilliseconds(1);
 1800428:	1800e600 	call	1800e60 <chThdSleep>
	return;
}

void gpu_fill(GPU_FILL_JOB_T job, alt_u8 wait) {
	//wait for GPU to be free
	while((IORD_VCORTEX_GPU_STATUS &(VCORTEX_GPU_STATUS_HST_ACC_DONE_MSK + \
 180042c:	00800074 	movhi	r2,1
 1800430:	10800404 	addi	r2,r2,16
 1800434:	10800037 	ldwio	r2,0(r2)
 1800438:	00c00304 	movi	r3,12
 180043c:	108003cc 	andi	r2,r2,15
									 VCORTEX_GPU_STATUS_HST_MUL_DONE_MSK + \
									 VCORTEX_GPU_STATUS_PICASSO_BUSY_MSK + \
									 VCORTEX_GPU_STATUS_EUCLID_BUSY_MSK))   \
			!= (VCORTEX_GPU_STATUS_HST_MUL_DONE_MSK+VCORTEX_GPU_STATUS_HST_ACC_DONE_MSK))
	{
		chThdSleepMilliseconds(1);
 1800440:	01000044 	movi	r4,1
	return;
}

void gpu_fill(GPU_FILL_JOB_T job, alt_u8 wait) {
	//wait for GPU to be free
	while((IORD_VCORTEX_GPU_STATUS &(VCORTEX_GPU_STATUS_HST_ACC_DONE_MSK + \
 1800444:	10fff81e 	bne	r2,r3,1800428 <gpu_fill+0x60>
	{
		chThdSleepMilliseconds(1);
	}


	IOWR_VCORTEX_GPU_JOB_BFFR_1(PACK_HSI_PXL(job.fill_color));
 1800448:	80803fcc 	andi	r2,r16,255
 180044c:	89003fcc 	andi	r4,r17,255
 1800450:	1004917a 	slli	r2,r2,5
 1800454:	200890fa 	slli	r4,r4,3
 1800458:	90c03fcc 	andi	r3,r18,255
 180045c:	10c5883a 	add	r2,r2,r3
 1800460:	2089883a 	add	r4,r4,r2
 1800464:	00800074 	movhi	r2,1
 1800468:	10800c04 	addi	r2,r2,48
 180046c:	11000035 	stwio	r4,0(r2)
	IOWR_VCORTEX_GPU_JOB_BFFR_2(PACK_HSI_PXL(job.line_color));
 1800470:	98803fcc 	andi	r2,r19,255
 1800474:	a1003fcc 	andi	r4,r20,255
 1800478:	1004917a 	slli	r2,r2,5
 180047c:	200890fa 	slli	r4,r4,3
 1800480:	a8c03fcc 	andi	r3,r21,255
 1800484:	10c5883a 	add	r2,r2,r3
 1800488:	2089883a 	add	r4,r4,r2
 180048c:	00800074 	movhi	r2,1
 1800490:	10801004 	addi	r2,r2,64
 1800494:	11000035 	stwio	r4,0(r2)
	IOWR_VCORTEX_GPU_JOB_BFFR_3(job.seed.x);
 1800498:	b0ffffcc 	andi	r3,r22,65535
 180049c:	10800404 	addi	r2,r2,16
 18004a0:	10c00035 	stwio	r3,0(r2)
	IOWR_VCORTEX_GPU_JOB_BFFR_4(job.seed.y);
 18004a4:	e0ffffcc 	andi	r3,fp,65535
 18004a8:	10800404 	addi	r2,r2,16
 18004ac:	10c00035 	stwio	r3,0(r2)
	IOWR_VCORTEX_GPU_JOB_BFFR_0(FILL);
 18004b0:	00c00044 	movi	r3,1
 18004b4:	10bff004 	addi	r2,r2,-64
 18004b8:	10c00035 	stwio	r3,0(r2)

	if(wait) {
 18004bc:	b8803fcc 	andi	r2,r23,255
 18004c0:	10000826 	beq	r2,zero,18004e4 <gpu_fill+0x11c>
 18004c4:	00000106 	br	18004cc <gpu_fill+0x104>
		while(IORD_VCORTEX_GPU_STATUS & VCORTEX_GPU_STATUS_PICASSO_BUSY_MSK) {
			chThdSleepMilliseconds(1);
 18004c8:	1800e600 	call	1800e60 <chThdSleep>
	IOWR_VCORTEX_GPU_JOB_BFFR_3(job.seed.x);
	IOWR_VCORTEX_GPU_JOB_BFFR_4(job.seed.y);
	IOWR_VCORTEX_GPU_JOB_BFFR_0(FILL);

	if(wait) {
		while(IORD_VCORTEX_GPU_STATUS & VCORTEX_GPU_STATUS_PICASSO_BUSY_MSK) {
 18004cc:	00800074 	movhi	r2,1
 18004d0:	10800404 	addi	r2,r2,16
 18004d4:	10800037 	ldwio	r2,0(r2)
			chThdSleepMilliseconds(1);
 18004d8:	01000044 	movi	r4,1
	IOWR_VCORTEX_GPU_JOB_BFFR_3(job.seed.x);
	IOWR_VCORTEX_GPU_JOB_BFFR_4(job.seed.y);
	IOWR_VCORTEX_GPU_JOB_BFFR_0(FILL);

	if(wait) {
		while(IORD_VCORTEX_GPU_STATUS & VCORTEX_GPU_STATUS_PICASSO_BUSY_MSK) {
 18004dc:	1080008c 	andi	r2,r2,2
 18004e0:	103ff91e 	bne	r2,zero,18004c8 <gpu_fill+0x100>
			chThdSleepMilliseconds(1);
		}
	}

	return;
}
 18004e4:	dfc00c17 	ldw	ra,48(sp)
 18004e8:	df000b17 	ldw	fp,44(sp)
 18004ec:	ddc00a17 	ldw	r23,40(sp)
 18004f0:	dd800917 	ldw	r22,36(sp)
 18004f4:	dd400817 	ldw	r21,32(sp)
 18004f8:	dd000717 	ldw	r20,28(sp)
 18004fc:	dcc00617 	ldw	r19,24(sp)
 1800500:	dc800517 	ldw	r18,20(sp)
 1800504:	dc400417 	ldw	r17,16(sp)
 1800508:	dc000317 	ldw	r16,12(sp)
 180050c:	dec00d04 	addi	sp,sp,52
 1800510:	f800283a 	ret

01800514 <gpu_draw_bezier>:
	}

	return;
}

void gpu_draw_bezier(GPU_DRAW_BEZIER_T job, alt_u8 wait){
 1800514:	defff004 	addi	sp,sp,-64
 1800518:	d8801003 	ldbu	r2,64(sp)
 180051c:	d9c00315 	stw	r7,12(sp)
 1800520:	d9000015 	stw	r4,0(sp)
 1800524:	d9400115 	stw	r5,4(sp)
 1800528:	d9800215 	stw	r6,8(sp)
 180052c:	df000e15 	stw	fp,56(sp)
 1800530:	ddc00d15 	stw	r23,52(sp)
 1800534:	dd800c15 	stw	r22,48(sp)
 1800538:	dd400b15 	stw	r21,44(sp)
 180053c:	dd000a15 	stw	r20,40(sp)
 1800540:	dcc00915 	stw	r19,36(sp)
 1800544:	dc800815 	stw	r18,32(sp)
 1800548:	dc400715 	stw	r17,28(sp)
 180054c:	dc000615 	stw	r16,24(sp)
 1800550:	d8800505 	stb	r2,20(sp)
 1800554:	df000383 	ldbu	fp,14(sp)
 1800558:	d88003c3 	ldbu	r2,15(sp)
 180055c:	ddc00343 	ldbu	r23,13(sp)
 1800560:	dd800303 	ldbu	r22,12(sp)
 1800564:	dd40028b 	ldhu	r21,10(sp)
 1800568:	dd00020b 	ldhu	r20,8(sp)
 180056c:	dcc0018b 	ldhu	r19,6(sp)
 1800570:	dc80010b 	ldhu	r18,4(sp)
 1800574:	dc40008b 	ldhu	r17,2(sp)
 1800578:	dc00000b 	ldhu	r16,0(sp)
 180057c:	dfc00f15 	stw	ra,60(sp)
 1800580:	d8800405 	stb	r2,16(sp)
 1800584:	00000106 	br	180058c <gpu_draw_bezier+0x78>
									 VCORTEX_GPU_STATUS_HST_MUL_DONE_MSK + \
									 VCORTEX_GPU_STATUS_PICASSO_BUSY_MSK + \
									 VCORTEX_GPU_STATUS_EUCLID_BUSY_MSK))   \
			!= (VCORTEX_GPU_STATUS_HST_MUL_DONE_MSK+VCORTEX_GPU_STATUS_HST_ACC_DONE_MSK))
	{
		chThdSleepMilliseconds(1);
 1800588:	1800e600 	call	1800e60 <chThdSleep>
	return;
}

void gpu_draw_bezier(GPU_DRAW_BEZIER_T job, alt_u8 wait){
	//wait for GPU to be free
	while((IORD_VCORTEX_GPU_STATUS &(VCORTEX_GPU_STATUS_HST_ACC_DONE_MSK + \
 180058c:	00800074 	movhi	r2,1
 1800590:	10800404 	addi	r2,r2,16
 1800594:	10800037 	ldwio	r2,0(r2)
 1800598:	00c00304 	movi	r3,12
 180059c:	108003cc 	andi	r2,r2,15
									 VCORTEX_GPU_STATUS_HST_MUL_DONE_MSK + \
									 VCORTEX_GPU_STATUS_PICASSO_BUSY_MSK + \
									 VCORTEX_GPU_STATUS_EUCLID_BUSY_MSK))   \
			!= (VCORTEX_GPU_STATUS_HST_MUL_DONE_MSK+VCORTEX_GPU_STATUS_HST_ACC_DONE_MSK))
	{
		chThdSleepMilliseconds(1);
 18005a0:	01000044 	movi	r4,1
	return;
}

void gpu_draw_bezier(GPU_DRAW_BEZIER_T job, alt_u8 wait){
	//wait for GPU to be free
	while((IORD_VCORTEX_GPU_STATUS &(VCORTEX_GPU_STATUS_HST_ACC_DONE_MSK + \
 18005a4:	10fff81e 	bne	r2,r3,1800588 <gpu_draw_bezier+0x74>
	{
		chThdSleepMilliseconds(1);
	}


	IOWR_VCORTEX_GPU_JOB_BFFR_1(BEZIER);
 18005a8:	00800074 	movhi	r2,1
 18005ac:	10800c04 	addi	r2,r2,48
 18005b0:	11000035 	stwio	r4,0(r2)
	IOWR_VCORTEX_GPU_JOB_BFFR_2(job.p0.x);
 18005b4:	80ffffcc 	andi	r3,r16,65535
 18005b8:	10800404 	addi	r2,r2,16
 18005bc:	10c00035 	stwio	r3,0(r2)
	IOWR_VCORTEX_GPU_JOB_BFFR_3(job.p0.y);
 18005c0:	88ffffcc 	andi	r3,r17,65535
 18005c4:	10800404 	addi	r2,r2,16
 18005c8:	10c00035 	stwio	r3,0(r2)
	IOWR_VCORTEX_GPU_JOB_BFFR_4(job.p1.x);
 18005cc:	90ffffcc 	andi	r3,r18,65535
 18005d0:	10800404 	addi	r2,r2,16
 18005d4:	10c00035 	stwio	r3,0(r2)
	IOWR_VCORTEX_GPU_JOB_BFFR_5(job.p1.y);
 18005d8:	98ffffcc 	andi	r3,r19,65535
 18005dc:	10800404 	addi	r2,r2,16
 18005e0:	10c00035 	stwio	r3,0(r2)
	IOWR_VCORTEX_GPU_JOB_BFFR_6(job.p2.x);
 18005e4:	a0ffffcc 	andi	r3,r20,65535
 18005e8:	10800404 	addi	r2,r2,16
 18005ec:	10c00035 	stwio	r3,0(r2)
	IOWR_VCORTEX_GPU_JOB_BFFR_7(job.p2.y);
 18005f0:	a8ffffcc 	andi	r3,r21,65535
 18005f4:	10800404 	addi	r2,r2,16
 18005f8:	10c00035 	stwio	r3,0(r2)
	IOWR_VCORTEX_GPU_JOB_BFFR_8(PACK_HSI_PXL(job.color));
 18005fc:	b0803fcc 	andi	r2,r22,255
 1800600:	b9003fcc 	andi	r4,r23,255
 1800604:	1004917a 	slli	r2,r2,5
 1800608:	200890fa 	slli	r4,r4,3
 180060c:	e0c03fcc 	andi	r3,fp,255
 1800610:	10c5883a 	add	r2,r2,r3
 1800614:	2089883a 	add	r4,r4,r2
 1800618:	00800074 	movhi	r2,1
 180061c:	10802804 	addi	r2,r2,160
 1800620:	11000035 	stwio	r4,0(r2)
	IOWR_VCORTEX_GPU_JOB_BFFR_9(job.depth);
 1800624:	d8c00403 	ldbu	r3,16(sp)
 1800628:	10800404 	addi	r2,r2,16
 180062c:	10c00035 	stwio	r3,0(r2)
	IOWR_VCORTEX_GPU_JOB_BFFR_0(DRAW);
 1800630:	10bfdc04 	addi	r2,r2,-144
 1800634:	10000035 	stwio	zero,0(r2)

	if(wait) {
 1800638:	d8800503 	ldbu	r2,20(sp)
 180063c:	10000826 	beq	r2,zero,1800660 <gpu_draw_bezier+0x14c>
 1800640:	00000106 	br	1800648 <gpu_draw_bezier+0x134>
		while(IORD_VCORTEX_GPU_STATUS & VCORTEX_GPU_STATUS_EUCLID_BUSY_MSK) {
			chThdSleepMilliseconds(1);
 1800644:	1800e600 	call	1800e60 <chThdSleep>
	IOWR_VCORTEX_GPU_JOB_BFFR_8(PACK_HSI_PXL(job.color));
	IOWR_VCORTEX_GPU_JOB_BFFR_9(job.depth);
	IOWR_VCORTEX_GPU_JOB_BFFR_0(DRAW);

	if(wait) {
		while(IORD_VCORTEX_GPU_STATUS & VCORTEX_GPU_STATUS_EUCLID_BUSY_MSK) {
 1800648:	00800074 	movhi	r2,1
 180064c:	10800404 	addi	r2,r2,16
 1800650:	10800037 	ldwio	r2,0(r2)
			chThdSleepMilliseconds(1);
 1800654:	01000044 	movi	r4,1
	IOWR_VCORTEX_GPU_JOB_BFFR_8(PACK_HSI_PXL(job.color));
	IOWR_VCORTEX_GPU_JOB_BFFR_9(job.depth);
	IOWR_VCORTEX_GPU_JOB_BFFR_0(DRAW);

	if(wait) {
		while(IORD_VCORTEX_GPU_STATUS & VCORTEX_GPU_STATUS_EUCLID_BUSY_MSK) {
 1800658:	1104703a 	and	r2,r2,r4
 180065c:	103ff91e 	bne	r2,zero,1800644 <gpu_draw_bezier+0x130>
			chThdSleepMilliseconds(1);
		}
	}

	return;
}
 1800660:	dfc00f17 	ldw	ra,60(sp)
 1800664:	df000e17 	ldw	fp,56(sp)
 1800668:	ddc00d17 	ldw	r23,52(sp)
 180066c:	dd800c17 	ldw	r22,48(sp)
 1800670:	dd400b17 	ldw	r21,44(sp)
 1800674:	dd000a17 	ldw	r20,40(sp)
 1800678:	dcc00917 	ldw	r19,36(sp)
 180067c:	dc800817 	ldw	r18,32(sp)
 1800680:	dc400717 	ldw	r17,28(sp)
 1800684:	dc000617 	ldw	r16,24(sp)
 1800688:	dec01004 	addi	sp,sp,64
 180068c:	f800283a 	ret

01800690 <gpu_draw_line>:
void disable_gpu() {
	IOWR_VCORTEX_GPU_CONTROL(~VCORTEX_GPU_EN_MSK);
	return;
}

void gpu_draw_line(GPU_DRAW_LINE_JOB_T job, alt_u8 wait) {
 1800690:	defff404 	addi	sp,sp,-48
 1800694:	d9800215 	stw	r6,8(sp)
 1800698:	d9000015 	stw	r4,0(sp)
 180069c:	d9400115 	stw	r5,4(sp)
 18006a0:	dd800915 	stw	r22,36(sp)
 18006a4:	dd400815 	stw	r21,32(sp)
 18006a8:	dd000715 	stw	r20,28(sp)
 18006ac:	dcc00615 	stw	r19,24(sp)
 18006b0:	dc800515 	stw	r18,20(sp)
 18006b4:	dc400415 	stw	r17,16(sp)
 18006b8:	dc000315 	stw	r16,12(sp)
 18006bc:	dd800283 	ldbu	r22,10(sp)
 18006c0:	dd400243 	ldbu	r21,9(sp)
 18006c4:	dd000203 	ldbu	r20,8(sp)
 18006c8:	dcc0018b 	ldhu	r19,6(sp)
 18006cc:	dc80010b 	ldhu	r18,4(sp)
 18006d0:	dc40008b 	ldhu	r17,2(sp)
 18006d4:	dc00000b 	ldhu	r16,0(sp)
 18006d8:	ddc00a15 	stw	r23,40(sp)
 18006dc:	382f883a 	mov	r23,r7
 18006e0:	dfc00b15 	stw	ra,44(sp)
 18006e4:	00000106 	br	18006ec <gpu_draw_line+0x5c>
				  	  	  	  	  	 VCORTEX_GPU_STATUS_HST_MUL_DONE_MSK + \
				  	  	  	  	  	 VCORTEX_GPU_STATUS_PICASSO_BUSY_MSK + \
				  	  	  	  	  	 VCORTEX_GPU_STATUS_EUCLID_BUSY_MSK))   \
			!= (VCORTEX_GPU_STATUS_HST_MUL_DONE_MSK+VCORTEX_GPU_STATUS_HST_ACC_DONE_MSK))
	{
		chThdSleepMilliseconds(1);
 18006e8:	1800e600 	call	1800e60 <chThdSleep>
	return;
}

void gpu_draw_line(GPU_DRAW_LINE_JOB_T job, alt_u8 wait) {
	//wait for GPU to be free
	while((IORD_VCORTEX_GPU_STATUS &(VCORTEX_GPU_STATUS_HST_ACC_DONE_MSK + \
 18006ec:	00800074 	movhi	r2,1
 18006f0:	10800404 	addi	r2,r2,16
 18006f4:	10800037 	ldwio	r2,0(r2)
 18006f8:	00c00304 	movi	r3,12
 18006fc:	108003cc 	andi	r2,r2,15
				  	  	  	  	  	 VCORTEX_GPU_STATUS_HST_MUL_DONE_MSK + \
				  	  	  	  	  	 VCORTEX_GPU_STATUS_PICASSO_BUSY_MSK + \
				  	  	  	  	  	 VCORTEX_GPU_STATUS_EUCLID_BUSY_MSK))   \
			!= (VCORTEX_GPU_STATUS_HST_MUL_DONE_MSK+VCORTEX_GPU_STATUS_HST_ACC_DONE_MSK))
	{
		chThdSleepMilliseconds(1);
 1800700:	01000044 	movi	r4,1
	return;
}

void gpu_draw_line(GPU_DRAW_LINE_JOB_T job, alt_u8 wait) {
	//wait for GPU to be free
	while((IORD_VCORTEX_GPU_STATUS &(VCORTEX_GPU_STATUS_HST_ACC_DONE_MSK + \
 1800704:	10fff81e 	bne	r2,r3,18006e8 <gpu_draw_line+0x58>
	{
		chThdSleepMilliseconds(1);
	}


	IOWR_VCORTEX_GPU_JOB_BFFR_1(LINE);
 1800708:	00800074 	movhi	r2,1
 180070c:	10800c04 	addi	r2,r2,48
 1800710:	10000035 	stwio	zero,0(r2)
	IOWR_VCORTEX_GPU_JOB_BFFR_2(job.start.x);
 1800714:	80ffffcc 	andi	r3,r16,65535
 1800718:	10800404 	addi	r2,r2,16
 180071c:	10c00035 	stwio	r3,0(r2)
	IOWR_VCORTEX_GPU_JOB_BFFR_3(job.start.y);
 1800720:	88ffffcc 	andi	r3,r17,65535
 1800724:	10800404 	addi	r2,r2,16
 1800728:	10c00035 	stwio	r3,0(r2)
	IOWR_VCORTEX_GPU_JOB_BFFR_4(job.end.x);
 180072c:	90ffffcc 	andi	r3,r18,65535
 1800730:	10800404 	addi	r2,r2,16
 1800734:	10c00035 	stwio	r3,0(r2)
	IOWR_VCORTEX_GPU_JOB_BFFR_5(job.end.y);
 1800738:	98ffffcc 	andi	r3,r19,65535
 180073c:	10800404 	addi	r2,r2,16
 1800740:	10c00035 	stwio	r3,0(r2)
	IOWR_VCORTEX_GPU_JOB_BFFR_8(PACK_HSI_PXL(job.color));
 1800744:	a0803fcc 	andi	r2,r20,255
 1800748:	a9003fcc 	andi	r4,r21,255
 180074c:	1004917a 	slli	r2,r2,5
 1800750:	200890fa 	slli	r4,r4,3
 1800754:	b0c03fcc 	andi	r3,r22,255
 1800758:	10c5883a 	add	r2,r2,r3
 180075c:	2089883a 	add	r4,r4,r2
 1800760:	00800074 	movhi	r2,1
 1800764:	10802804 	addi	r2,r2,160
 1800768:	11000035 	stwio	r4,0(r2)
	IOWR_VCORTEX_GPU_JOB_BFFR_0(DRAW);
 180076c:	10bfe004 	addi	r2,r2,-128
 1800770:	10000035 	stwio	zero,0(r2)

	if(wait) {
 1800774:	b8803fcc 	andi	r2,r23,255
 1800778:	10000826 	beq	r2,zero,180079c <gpu_draw_line+0x10c>
 180077c:	00000106 	br	1800784 <gpu_draw_line+0xf4>
		while(IORD_VCORTEX_GPU_STATUS & VCORTEX_GPU_STATUS_EUCLID_BUSY_MSK) {
			chThdSleepMilliseconds(1);
 1800780:	1800e600 	call	1800e60 <chThdSleep>
	IOWR_VCORTEX_GPU_JOB_BFFR_5(job.end.y);
	IOWR_VCORTEX_GPU_JOB_BFFR_8(PACK_HSI_PXL(job.color));
	IOWR_VCORTEX_GPU_JOB_BFFR_0(DRAW);

	if(wait) {
		while(IORD_VCORTEX_GPU_STATUS & VCORTEX_GPU_STATUS_EUCLID_BUSY_MSK) {
 1800784:	00800074 	movhi	r2,1
 1800788:	10800404 	addi	r2,r2,16
 180078c:	10800037 	ldwio	r2,0(r2)
			chThdSleepMilliseconds(1);
 1800790:	01000044 	movi	r4,1
	IOWR_VCORTEX_GPU_JOB_BFFR_5(job.end.y);
	IOWR_VCORTEX_GPU_JOB_BFFR_8(PACK_HSI_PXL(job.color));
	IOWR_VCORTEX_GPU_JOB_BFFR_0(DRAW);

	if(wait) {
		while(IORD_VCORTEX_GPU_STATUS & VCORTEX_GPU_STATUS_EUCLID_BUSY_MSK) {
 1800794:	1104703a 	and	r2,r2,r4
 1800798:	103ff91e 	bne	r2,zero,1800780 <gpu_draw_line+0xf0>
			chThdSleepMilliseconds(1);
		}
	}

	return;
}
 180079c:	dfc00b17 	ldw	ra,44(sp)
 18007a0:	ddc00a17 	ldw	r23,40(sp)
 18007a4:	dd800917 	ldw	r22,36(sp)
 18007a8:	dd400817 	ldw	r21,32(sp)
 18007ac:	dd000717 	ldw	r20,28(sp)
 18007b0:	dcc00617 	ldw	r19,24(sp)
 18007b4:	dc800517 	ldw	r18,20(sp)
 18007b8:	dc400417 	ldw	r17,16(sp)
 18007bc:	dc000317 	ldw	r16,12(sp)
 18007c0:	dec00c04 	addi	sp,sp,48
 18007c4:	f800283a 	ret

018007c8 <disable_gpu>:
	IOWR_VCORTEX_GPU_CONTROL(VCORTEX_GPU_EN_MSK);
	return;
}

void disable_gpu() {
	IOWR_VCORTEX_GPU_CONTROL(~VCORTEX_GPU_EN_MSK);
 18007c8:	00ffff84 	movi	r3,-2
 18007cc:	00800074 	movhi	r2,1
 18007d0:	10c00035 	stwio	r3,0(r2)
	return;
}
 18007d4:	f800283a 	ret

018007d8 <enable_gpu>:
#include "ch.h"
#include "sys/alt_stdio.h"


void enable_gpu() {
	IOWR_VCORTEX_GPU_CONTROL(VCORTEX_GPU_EN_MSK);
 18007d8:	00c00044 	movi	r3,1
 18007dc:	00800074 	movhi	r2,1
 18007e0:	10c00035 	stwio	r3,0(r2)
	return;
}
 18007e4:	f800283a 	ret

018007e8 <main>:
#include "ledos/ledos.h"
#include "ch.h"


int main()
{ 
 18007e8:	deffef04 	addi	sp,sp,-68
  GPU_HST_ACC_JOB_T job,rd_job;
  GPU_DRAW_LINE_JOB_T line_job;

  alt_putstr("Hello from Nios II!\n");
 18007ec:	01006074 	movhi	r4,385
 18007f0:	2124eb04 	addi	r4,r4,-27732
#include "ledos/ledos.h"
#include "ch.h"


int main()
{ 
 18007f4:	dfc01015 	stw	ra,64(sp)
 18007f8:	dd400f15 	stw	r21,60(sp)
 18007fc:	dd000e15 	stw	r20,56(sp)
 1800800:	dcc00d15 	stw	r19,52(sp)
 1800804:	dc800c15 	stw	r18,48(sp)
 1800808:	dc400b15 	stw	r17,44(sp)
 180080c:	dc000a15 	stw	r16,40(sp)
  GPU_HST_ACC_JOB_T job,rd_job;
  GPU_DRAW_LINE_JOB_T line_job;

  alt_putstr("Hello from Nios II!\n");
 1800810:	180190c0 	call	180190c <alt_putstr>

  alt_printf("GPU STATUS REG:0x%x\n",IORD_VCORTEX_GPU_STATUS);
 1800814:	00800074 	movhi	r2,1
 1800818:	10800404 	addi	r2,r2,16
 180081c:	11400037 	ldwio	r5,0(r2)
 1800820:	01006074 	movhi	r4,385
 1800824:	2124f104 	addi	r4,r4,-27708
 1800828:	18016740 	call	1801674 <alt_printf>


  vga_disable();

  job.color.h =0; job.color.s =0; job.color.i =0;
 180082c:	0023883a 	mov	r17,zero
  alt_putstr("Hello from Nios II!\n");

  alt_printf("GPU STATUS REG:0x%x\n",IORD_VCORTEX_GPU_STATUS);


  vga_disable();
 1800830:	180022c0 	call	180022c <vga_disable>

  job.color.h =0; job.color.s =0; job.color.i =0;
 1800834:	0025883a 	mov	r18,zero
 1800838:	d8000605 	stb	zero,24(sp)
 180083c:	d8000645 	stb	zero,25(sp)
 1800840:	d8000685 	stb	zero,26(sp)
 1800844:	0021883a 	mov	r16,zero
 1800848:	0009883a 	mov	r4,zero

  for(job.ptr.x=0; job.ptr.x<CANVAS_W; job.ptr.x++){
	  for(job.ptr.y=0; job.ptr.y<CANVAS_H; job.ptr.y++){
		  job.action = WRITE;

		  gpu_hst_acc(job, 1);
 180084c:	d900058d 	sth	r4,22(sp)
 1800850:	dc80050d 	sth	r18,20(sp)
 1800854:	d9800517 	ldw	r6,20(sp)
 1800858:	d9c00617 	ldw	r7,24(sp)
 180085c:	05400044 	movi	r21,1
 1800860:	d9000704 	addi	r4,sp,28
 1800864:	000b883a 	mov	r5,zero
  job.ptr.x=0; job.ptr.y=0;
  job.action = WRITE;

  for(job.ptr.x=0; job.ptr.x<CANVAS_W; job.ptr.x++){
	  for(job.ptr.y=0; job.ptr.y<CANVAS_H; job.ptr.y++){
		  job.action = WRITE;
 1800868:	d8000415 	stw	zero,16(sp)

		  gpu_hst_acc(job, 1);
 180086c:	dd400015 	stw	r21,0(sp)
 1800870:	18002600 	call	1800260 <gpu_hst_acc>
  job.color.h =0; job.color.s =0; job.color.i =0;
  job.ptr.x=0; job.ptr.y=0;
  job.action = WRITE;

  for(job.ptr.x=0; job.ptr.x<CANVAS_W; job.ptr.x++){
	  for(job.ptr.y=0; job.ptr.y<CANVAS_H; job.ptr.y++){
 1800874:	8545883a 	add	r2,r16,r21
 1800878:	1009883a 	mov	r4,r2
 180087c:	1021883a 	mov	r16,r2
 1800880:	10ffffcc 	andi	r3,r2,65535
 1800884:	00807804 	movi	r2,480
 1800888:	18bff01e 	bne	r3,r2,180084c <main+0x64>

  job.color.h =0; job.color.s =0; job.color.i =0;
  job.ptr.x=0; job.ptr.y=0;
  job.action = WRITE;

  for(job.ptr.x=0; job.ptr.x<CANVAS_W; job.ptr.x++){
 180088c:	89000044 	addi	r4,r17,1
 1800890:	20ffffcc 	andi	r3,r4,65535
 1800894:	0080a004 	movi	r2,640
 1800898:	2023883a 	mov	r17,r4
 180089c:	18800226 	beq	r3,r2,18008a8 <main+0xc0>
 18008a0:	2025883a 	mov	r18,r4
 18008a4:	003fe706 	br	1800844 <main+0x5c>
  line_job.start.x = 10;
  line_job.start.y = 10;
  line_job.end.x = 400;
  line_job.end.y = 400;

  gpu_draw_line(line_job, 1);
 18008a8:	04406404 	movi	r17,400
 18008ac:	04000284 	movi	r16,10
 18008b0:	048000c4 	movi	r18,3
 18008b4:	04c001c4 	movi	r19,7

		  gpu_hst_acc(job, 1);
	  }
  }

  alt_putstr("FB Init Done\n");
 18008b8:	01006074 	movhi	r4,385
 18008bc:	2124f704 	addi	r4,r4,-27684
 18008c0:	180190c0 	call	180190c <alt_putstr>
  line_job.start.x = 10;
  line_job.start.y = 10;
  line_job.end.x = 400;
  line_job.end.y = 400;

  gpu_draw_line(line_job, 1);
 18008c4:	dd400305 	stb	r21,12(sp)
 18008c8:	dc40028d 	sth	r17,10(sp)
 18008cc:	dc40020d 	sth	r17,8(sp)
 18008d0:	dc00018d 	sth	r16,6(sp)
 18008d4:	dc00010d 	sth	r16,4(sp)
 18008d8:	dcc00385 	stb	r19,14(sp)
 18008dc:	dc800345 	stb	r18,13(sp)
 18008e0:	d9000117 	ldw	r4,4(sp)
 18008e4:	d9400217 	ldw	r5,8(sp)
 18008e8:	d9800317 	ldw	r6,12(sp)
 18008ec:	a80f883a 	mov	r7,r21
 18008f0:	18006900 	call	1800690 <gpu_draw_line>
  line_job.start.x = 10;
  line_job.start.y = 400;
  line_job.end.x = 400;
  line_job.end.y = 10;

  gpu_draw_line(line_job, 1);
 18008f4:	dcc00385 	stb	r19,14(sp)
 18008f8:	dc00028d 	sth	r16,10(sp)
 18008fc:	dc40020d 	sth	r17,8(sp)
 1800900:	dc40018d 	sth	r17,6(sp)
 1800904:	dc00010d 	sth	r16,4(sp)
 1800908:	dc800345 	stb	r18,13(sp)
 180090c:	dc800305 	stb	r18,12(sp)
 1800910:	d9400217 	ldw	r5,8(sp)
 1800914:	d9800317 	ldw	r6,12(sp)
 1800918:	d9000117 	ldw	r4,4(sp)
 180091c:	a80f883a 	mov	r7,r21
 1800920:	18006900 	call	1800690 <gpu_draw_line>

  alt_putstr("Enabling VGA\n");
 1800924:	01006074 	movhi	r4,385
 1800928:	2124fb04 	addi	r4,r4,-27668
 180092c:	180190c0 	call	180190c <alt_putstr>

  set_vga_mode(NORMAL);
 1800930:	0009883a 	mov	r4,zero
 1800934:	18002000 	call	1800200 <set_vga_mode>
  vga_en();
 1800938:	18002480 	call	1800248 <vga_en>

  alt_printf("VGA Control Reg:0x%x\n",IORD_VCORTEX_VGA_CONTROL);
 180093c:	00800074 	movhi	r2,1
 1800940:	10840004 	addi	r2,r2,4096
 1800944:	11400037 	ldwio	r5,0(r2)
 1800948:	01006074 	movhi	r4,385
 180094c:	2124ff04 	addi	r4,r4,-27652
 1800950:	18016740 	call	1801674 <alt_printf>
 1800954:	882b883a 	mov	r21,r17
 1800958:	8029883a 	mov	r20,r16
 180095c:	9027883a 	mov	r19,r18

  while(1){
	  line_job.color.h= (line_job.color.h + 1) & 0x7;
 1800960:	98c00044 	addi	r3,r19,1
	  line_job.color.s= (line_job.color.s + 1) & 0x3;
 1800964:	92000044 	addi	r8,r18,1
	  line_job.color.i= 0x7;
	  line_job.start.x = (line_job.start.x + 1) & 0xff;
 1800968:	a2400044 	addi	r9,r20,1
	  line_job.start.y = (line_job.start.y + 1) & 0xff;
 180096c:	aa800044 	addi	r10,r21,1
	  line_job.end.x = (line_job.end.x + 1) & 0xff;
 1800970:	8ac00044 	addi	r11,r17,1
	  line_job.end.y = (line_job.end.y + 1) & 0xff;
 1800974:	83000044 	addi	r12,r16,1
  vga_en();

  alt_printf("VGA Control Reg:0x%x\n",IORD_VCORTEX_VGA_CONTROL);

  while(1){
	  line_job.color.h= (line_job.color.h + 1) & 0x7;
 1800978:	18c001cc 	andi	r3,r3,7
	  line_job.color.s= (line_job.color.s + 1) & 0x3;
 180097c:	420000cc 	andi	r8,r8,3
	  line_job.color.i= 0x7;
	  line_job.start.x = (line_job.start.x + 1) & 0xff;
 1800980:	4a403fcc 	andi	r9,r9,255
	  line_job.start.y = (line_job.start.y + 1) & 0xff;
 1800984:	52803fcc 	andi	r10,r10,255
	  line_job.end.x = (line_job.end.x + 1) & 0xff;
 1800988:	5ac03fcc 	andi	r11,r11,255
	  line_job.end.y = (line_job.end.y + 1) & 0xff;
 180098c:	63003fcc 	andi	r12,r12,255

	  gpu_draw_line(line_job, 1);
 1800990:	008001c4 	movi	r2,7
 1800994:	db00028d 	sth	r12,10(sp)
 1800998:	dac0020d 	sth	r11,8(sp)
 180099c:	da80018d 	sth	r10,6(sp)
 18009a0:	da40010d 	sth	r9,4(sp)
 18009a4:	d8800385 	stb	r2,14(sp)
 18009a8:	da000345 	stb	r8,13(sp)
 18009ac:	d8c00305 	stb	r3,12(sp)
 18009b0:	d9000117 	ldw	r4,4(sp)
 18009b4:	d9400217 	ldw	r5,8(sp)
 18009b8:	d9800317 	ldw	r6,12(sp)
 18009bc:	01c00044 	movi	r7,1
  vga_en();

  alt_printf("VGA Control Reg:0x%x\n",IORD_VCORTEX_VGA_CONTROL);

  while(1){
	  line_job.color.h= (line_job.color.h + 1) & 0x7;
 18009c0:	1827883a 	mov	r19,r3
	  line_job.color.s= (line_job.color.s + 1) & 0x3;
 18009c4:	4025883a 	mov	r18,r8
	  line_job.color.i= 0x7;
	  line_job.start.x = (line_job.start.x + 1) & 0xff;
 18009c8:	4829883a 	mov	r20,r9
	  line_job.start.y = (line_job.start.y + 1) & 0xff;
 18009cc:	502b883a 	mov	r21,r10
	  line_job.end.x = (line_job.end.x + 1) & 0xff;
 18009d0:	5823883a 	mov	r17,r11
	  line_job.end.y = (line_job.end.y + 1) & 0xff;
 18009d4:	6021883a 	mov	r16,r12

	  gpu_draw_line(line_job, 1);
 18009d8:	18006900 	call	1800690 <gpu_draw_line>

	  chThdSleepMilliseconds(30);
 18009dc:	01000784 	movi	r4,30
 18009e0:	1800e600 	call	1800e60 <chThdSleep>
 18009e4:	003fde06 	br	1800960 <main+0x178>

018009e8 <_thread_init>:
 * @param[in] prio      the priority level for the new thread
 * @return              The same thread pointer passed as parameter.
 *
 * @notapi
 */
Thread *_thread_init(Thread *tp, tprio_t prio) {
 18009e8:	defffd04 	addi	sp,sp,-12
 18009ec:	df000215 	stw	fp,8(sp)
 18009f0:	df000204 	addi	fp,sp,8
 18009f4:	e13ffe15 	stw	r4,-8(fp)
 18009f8:	e17fff15 	stw	r5,-4(fp)

  tp->p_prio = prio;
 18009fc:	e0fffe17 	ldw	r3,-8(fp)
 1800a00:	e0bfff17 	ldw	r2,-4(fp)
 1800a04:	18800215 	stw	r2,8(r3)
  tp->p_state = THD_STATE_SUSPENDED;
 1800a08:	e0fffe17 	ldw	r3,-8(fp)
 1800a0c:	00800084 	movi	r2,2
 1800a10:	18800705 	stb	r2,28(r3)
  tp->p_flags = THD_MEM_MODE_STATIC;
 1800a14:	e0bffe17 	ldw	r2,-8(fp)
 1800a18:	10000745 	stb	zero,29(r2)
#if CH_USE_MUTEXES
  tp->p_realprio = prio;
 1800a1c:	e0fffe17 	ldw	r3,-8(fp)
 1800a20:	e0bfff17 	ldw	r2,-4(fp)
 1800a24:	18801015 	stw	r2,64(r3)
  tp->p_mtxlist = NULL;
 1800a28:	e0bffe17 	ldw	r2,-8(fp)
 1800a2c:	10000f15 	stw	zero,60(r2)
#endif
#if CH_USE_EVENTS
  tp->p_epending = 0;
 1800a30:	e0bffe17 	ldw	r2,-8(fp)
 1800a34:	10000e15 	stw	zero,56(r2)
#endif
#if CH_DBG_THREADS_PROFILING
  tp->p_time = 0;
 1800a38:	e0bffe17 	ldw	r2,-8(fp)
 1800a3c:	10000815 	stw	zero,32(r2)
#endif
#if CH_USE_DYNAMIC
  tp->p_refs = 1;
 1800a40:	e0fffe17 	ldw	r3,-8(fp)
 1800a44:	00800044 	movi	r2,1
 1800a48:	18800785 	stb	r2,30(r3)
#endif
#if CH_USE_REGISTRY
  tp->p_name = NULL;
 1800a4c:	e0bffe17 	ldw	r2,-8(fp)
 1800a50:	10000615 	stw	zero,24(r2)
  REG_INSERT(tp);
 1800a54:	00c06074 	movhi	r3,385
 1800a58:	18f2d104 	addi	r3,r3,-13500
 1800a5c:	e0bffe17 	ldw	r2,-8(fp)
 1800a60:	10c00415 	stw	r3,16(r2)
 1800a64:	00806074 	movhi	r2,385
 1800a68:	10b2d104 	addi	r2,r2,-13500
 1800a6c:	10c00517 	ldw	r3,20(r2)
 1800a70:	e0bffe17 	ldw	r2,-8(fp)
 1800a74:	10c00515 	stw	r3,20(r2)
 1800a78:	e0bffe17 	ldw	r2,-8(fp)
 1800a7c:	11000517 	ldw	r4,20(r2)
 1800a80:	00c06074 	movhi	r3,385
 1800a84:	18f2d104 	addi	r3,r3,-13500
 1800a88:	e0bffe17 	ldw	r2,-8(fp)
 1800a8c:	18800515 	stw	r2,20(r3)
 1800a90:	00806074 	movhi	r2,385
 1800a94:	10b2d104 	addi	r2,r2,-13500
 1800a98:	10800517 	ldw	r2,20(r2)
 1800a9c:	20800415 	stw	r2,16(r4)
#endif
#if CH_USE_WAITEXIT
  list_init(&tp->p_waiting);
 1800aa0:	e0bffe17 	ldw	r2,-8(fp)
 1800aa4:	10800a04 	addi	r2,r2,40
 1800aa8:	1007883a 	mov	r3,r2
 1800aac:	e0bffe17 	ldw	r2,-8(fp)
 1800ab0:	10c00a15 	stw	r3,40(r2)
#endif
#if CH_USE_MESSAGES
  queue_init(&tp->p_msgqueue);
 1800ab4:	e0bffe17 	ldw	r2,-8(fp)
 1800ab8:	10800b04 	addi	r2,r2,44
 1800abc:	1007883a 	mov	r3,r2
 1800ac0:	e0bffe17 	ldw	r2,-8(fp)
 1800ac4:	10c00c15 	stw	r3,48(r2)
 1800ac8:	e0bffe17 	ldw	r2,-8(fp)
 1800acc:	10c00c17 	ldw	r3,48(r2)
 1800ad0:	e0bffe17 	ldw	r2,-8(fp)
 1800ad4:	10c00b15 	stw	r3,44(r2)
  tp->p_stklimit = (stkalign_t *)(tp + 1);
#endif
#if defined(THREAD_EXT_INIT_HOOK)
  THREAD_EXT_INIT_HOOK(tp);
#endif
  return tp;
 1800ad8:	e0bffe17 	ldw	r2,-8(fp)
}
 1800adc:	e037883a 	mov	sp,fp
 1800ae0:	df000017 	ldw	fp,0(sp)
 1800ae4:	dec00104 	addi	sp,sp,4
 1800ae8:	f800283a 	ret

01800aec <chThdCreateI>:
 *                      the thread into the working space area.
 *
 * @iclass
 */
Thread *chThdCreateI(void *wsp, size_t size,
                     tprio_t prio, tfunc_t pf, void *arg) {
 1800aec:	defff904 	addi	sp,sp,-28
 1800af0:	dfc00615 	stw	ra,24(sp)
 1800af4:	df000515 	stw	fp,20(sp)
 1800af8:	df000504 	addi	fp,sp,20
 1800afc:	e13ffc15 	stw	r4,-16(fp)
 1800b00:	e17ffd15 	stw	r5,-12(fp)
 1800b04:	e1bffe15 	stw	r6,-8(fp)
 1800b08:	e1ffff15 	stw	r7,-4(fp)
  /* Thread structure is layed out in the lower part of the thread workspace */
  Thread *tp = wsp;
 1800b0c:	e0bffc17 	ldw	r2,-16(fp)
 1800b10:	e0bffb15 	stw	r2,-20(fp)

  chDbgCheckClassI();

  chDbgCheck((wsp != NULL) && (size >= THD_WA_SIZE(0)) &&
 1800b14:	e0bffc17 	ldw	r2,-16(fp)
 1800b18:	1005003a 	cmpeq	r2,r2,zero
 1800b1c:	1000061e 	bne	r2,zero,1800b38 <chThdCreateI+0x4c>
 1800b20:	e0bffd17 	ldw	r2,-12(fp)
 1800b24:	10805030 	cmpltui	r2,r2,320
 1800b28:	1000031e 	bne	r2,zero,1800b38 <chThdCreateI+0x4c>
 1800b2c:	e0bffe17 	ldw	r2,-8(fp)
 1800b30:	10802028 	cmpgeui	r2,r2,128
 1800b34:	1000001e 	bne	r2,zero,1800b38 <chThdCreateI+0x4c>
             (prio <= HIGHPRIO) && (pf != NULL),
             "chThdCreateI");
  SETUP_CONTEXT(wsp, size, pf, arg);
 1800b38:	e0fffc17 	ldw	r3,-16(fp)
 1800b3c:	e0bffd17 	ldw	r2,-12(fp)
 1800b40:	1885883a 	add	r2,r3,r2
 1800b44:	10bff504 	addi	r2,r2,-44
 1800b48:	1007883a 	mov	r3,r2
 1800b4c:	e0bffb17 	ldw	r2,-20(fp)
 1800b50:	10c00315 	stw	r3,12(r2)
 1800b54:	e0bffb17 	ldw	r2,-20(fp)
 1800b58:	10c00317 	ldw	r3,12(r2)
 1800b5c:	e0bfff17 	ldw	r2,-4(fp)
 1800b60:	18800215 	stw	r2,8(r3)
 1800b64:	e0bffb17 	ldw	r2,-20(fp)
 1800b68:	10c00317 	ldw	r3,12(r2)
 1800b6c:	e0800217 	ldw	r2,8(fp)
 1800b70:	18800315 	stw	r2,12(r3)
 1800b74:	e0bffb17 	ldw	r2,-20(fp)
 1800b78:	10c00317 	ldw	r3,12(r2)
 1800b7c:	00860634 	movhi	r2,6168
 1800b80:	10860604 	addi	r2,r2,6168
 1800b84:	18800415 	stw	r2,16(r3)
 1800b88:	e0bffb17 	ldw	r2,-20(fp)
 1800b8c:	10c00317 	ldw	r3,12(r2)
 1800b90:	00864674 	movhi	r2,6425
 1800b94:	10864644 	addi	r2,r2,6425
 1800b98:	18800515 	stw	r2,20(r3)
 1800b9c:	e0bffb17 	ldw	r2,-20(fp)
 1800ba0:	10c00317 	ldw	r3,12(r2)
 1800ba4:	00880834 	movhi	r2,8224
 1800ba8:	10880804 	addi	r2,r2,8224
 1800bac:	18800615 	stw	r2,24(r3)
 1800bb0:	e0bffb17 	ldw	r2,-20(fp)
 1800bb4:	10c00317 	ldw	r3,12(r2)
 1800bb8:	00884874 	movhi	r2,8481
 1800bbc:	10884844 	addi	r2,r2,8481
 1800bc0:	18800715 	stw	r2,28(r3)
 1800bc4:	e0bffb17 	ldw	r2,-20(fp)
 1800bc8:	10c00317 	ldw	r3,12(r2)
 1800bcc:	008888b4 	movhi	r2,8738
 1800bd0:	10888884 	addi	r2,r2,8738
 1800bd4:	18800815 	stw	r2,32(r3)
 1800bd8:	e0bffb17 	ldw	r2,-20(fp)
 1800bdc:	10c00317 	ldw	r3,12(r2)
 1800be0:	0088c8f4 	movhi	r2,8995
 1800be4:	1088c8c4 	addi	r2,r2,8995
 1800be8:	18800915 	stw	r2,36(r3)
 1800bec:	e0bffb17 	ldw	r2,-20(fp)
 1800bf0:	10c00317 	ldw	r3,12(r2)
 1800bf4:	00800044 	movi	r2,1
 1800bf8:	18800a15 	stw	r2,40(r3)
 1800bfc:	e0bffb17 	ldw	r2,-20(fp)
 1800c00:	10c00317 	ldw	r3,12(r2)
 1800c04:	008a0a34 	movhi	r2,10280
 1800c08:	108a0a04 	addi	r2,r2,10280
 1800c0c:	18800115 	stw	r2,4(r3)
 1800c10:	e0bffb17 	ldw	r2,-20(fp)
 1800c14:	10c00317 	ldw	r3,12(r2)
 1800c18:	00806034 	movhi	r2,384
 1800c1c:	10851d04 	addi	r2,r2,5236
 1800c20:	18800015 	stw	r2,0(r3)
  return _thread_init(tp, prio);
 1800c24:	e13ffb17 	ldw	r4,-20(fp)
 1800c28:	e17ffe17 	ldw	r5,-8(fp)
 1800c2c:	18009e80 	call	18009e8 <_thread_init>
}
 1800c30:	e037883a 	mov	sp,fp
 1800c34:	dfc00117 	ldw	ra,4(sp)
 1800c38:	df000017 	ldw	fp,0(sp)
 1800c3c:	dec00204 	addi	sp,sp,8
 1800c40:	f800283a 	ret

01800c44 <chThdCreateStatic>:
 *                      the thread into the working space area.
 *
 * @api
 */
Thread *chThdCreateStatic(void *wsp, size_t size,
                          tprio_t prio, tfunc_t pf, void *arg) {
 1800c44:	defff604 	addi	sp,sp,-40
 1800c48:	dfc00915 	stw	ra,36(sp)
 1800c4c:	df000815 	stw	fp,32(sp)
 1800c50:	df000804 	addi	fp,sp,32
 1800c54:	e13ffc15 	stw	r4,-16(fp)
 1800c58:	e17ffd15 	stw	r5,-12(fp)
 1800c5c:	e1bffe15 	stw	r6,-8(fp)
 1800c60:	e1ffff15 	stw	r7,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 1800c64:	0005303a 	rdctl	r2,status
 1800c68:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 1800c6c:	e0fffa17 	ldw	r3,-24(fp)
 1800c70:	00bfff84 	movi	r2,-2
 1800c74:	1884703a 	and	r2,r3,r2
 1800c78:	1001703a 	wrctl	status,r2
  _thread_memfill((uint8_t *)wsp + sizeof(Thread),
                  (uint8_t *)wsp + size,
                  CH_STACK_FILL_VALUE);
#endif
  chSysLock();
  chSchWakeupS(tp = chThdCreateI(wsp, size, prio, pf, arg), RDY_OK);
 1800c7c:	e0800217 	ldw	r2,8(fp)
 1800c80:	d8800015 	stw	r2,0(sp)
 1800c84:	e13ffc17 	ldw	r4,-16(fp)
 1800c88:	e17ffd17 	ldw	r5,-12(fp)
 1800c8c:	e1bffe17 	ldw	r6,-8(fp)
 1800c90:	e1ffff17 	ldw	r7,-4(fp)
 1800c94:	1800aec0 	call	1800aec <chThdCreateI>
 1800c98:	e0bffb15 	stw	r2,-20(fp)
 1800c9c:	e13ffb17 	ldw	r4,-20(fp)
 1800ca0:	000b883a 	mov	r5,zero
 1800ca4:	180463c0 	call	180463c <chSchWakeupS>
 1800ca8:	00800044 	movi	r2,1
 1800cac:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 1800cb0:	e0bff917 	ldw	r2,-28(fp)
 1800cb4:	1001703a 	wrctl	status,r2
  chSysUnlock();
  return tp;
 1800cb8:	e0bffb17 	ldw	r2,-20(fp)
}
 1800cbc:	e037883a 	mov	sp,fp
 1800cc0:	dfc00117 	ldw	ra,4(sp)
 1800cc4:	df000017 	ldw	fp,0(sp)
 1800cc8:	dec00204 	addi	sp,sp,8
 1800ccc:	f800283a 	ret

01800cd0 <chThdSetPriority>:
 * @param[in] newprio   the new priority level of the running thread
 * @return              The old priority level.
 *
 * @api
 */
tprio_t chThdSetPriority(tprio_t newprio) {
 1800cd0:	defffa04 	addi	sp,sp,-24
 1800cd4:	dfc00515 	stw	ra,20(sp)
 1800cd8:	df000415 	stw	fp,16(sp)
 1800cdc:	df000404 	addi	fp,sp,16
 1800ce0:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 1800ce4:	0005303a 	rdctl	r2,status
 1800ce8:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 1800cec:	e0fffd17 	ldw	r3,-12(fp)
 1800cf0:	00bfff84 	movi	r2,-2
 1800cf4:	1884703a 	and	r2,r3,r2
 1800cf8:	1001703a 	wrctl	status,r2

  chDbgCheck(newprio <= HIGHPRIO, "chThdSetPriority");

  chSysLock();
#if CH_USE_MUTEXES
  oldprio = currp->p_realprio;
 1800cfc:	00806074 	movhi	r2,385
 1800d00:	10b2d104 	addi	r2,r2,-13500
 1800d04:	10800717 	ldw	r2,28(r2)
 1800d08:	10801017 	ldw	r2,64(r2)
 1800d0c:	e0bffe15 	stw	r2,-8(fp)
  if ((currp->p_prio == currp->p_realprio) || (newprio > currp->p_prio))
 1800d10:	00806074 	movhi	r2,385
 1800d14:	10b2d104 	addi	r2,r2,-13500
 1800d18:	10800717 	ldw	r2,28(r2)
 1800d1c:	10c00217 	ldw	r3,8(r2)
 1800d20:	00806074 	movhi	r2,385
 1800d24:	10b2d104 	addi	r2,r2,-13500
 1800d28:	10800717 	ldw	r2,28(r2)
 1800d2c:	10801017 	ldw	r2,64(r2)
 1800d30:	18800626 	beq	r3,r2,1800d4c <chThdSetPriority+0x7c>
 1800d34:	00806074 	movhi	r2,385
 1800d38:	10b2d104 	addi	r2,r2,-13500
 1800d3c:	10800717 	ldw	r2,28(r2)
 1800d40:	10c00217 	ldw	r3,8(r2)
 1800d44:	e0bfff17 	ldw	r2,-4(fp)
 1800d48:	1880052e 	bgeu	r3,r2,1800d60 <chThdSetPriority+0x90>
    currp->p_prio = newprio;
 1800d4c:	00806074 	movhi	r2,385
 1800d50:	10b2d104 	addi	r2,r2,-13500
 1800d54:	10c00717 	ldw	r3,28(r2)
 1800d58:	e0bfff17 	ldw	r2,-4(fp)
 1800d5c:	18800215 	stw	r2,8(r3)
  currp->p_realprio = newprio;
 1800d60:	00806074 	movhi	r2,385
 1800d64:	10b2d104 	addi	r2,r2,-13500
 1800d68:	10c00717 	ldw	r3,28(r2)
 1800d6c:	e0bfff17 	ldw	r2,-4(fp)
 1800d70:	18801015 	stw	r2,64(r3)
#else
  oldprio = currp->p_prio;
  currp->p_prio = newprio;
#endif
  chSchRescheduleS();
 1800d74:	18046e80 	call	18046e8 <chSchRescheduleS>
 1800d78:	00800044 	movi	r2,1
 1800d7c:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 1800d80:	e0bffc17 	ldw	r2,-16(fp)
 1800d84:	1001703a 	wrctl	status,r2
  chSysUnlock();
  return oldprio;
 1800d88:	e0bffe17 	ldw	r2,-8(fp)
}
 1800d8c:	e037883a 	mov	sp,fp
 1800d90:	dfc00117 	ldw	ra,4(sp)
 1800d94:	df000017 	ldw	fp,0(sp)
 1800d98:	dec00204 	addi	sp,sp,8
 1800d9c:	f800283a 	ret

01800da0 <chThdResume>:
 * @param[in] tp        pointer to the thread
 * @return              The pointer to the thread.
 *
 * @api
 */
Thread *chThdResume(Thread *tp) {
 1800da0:	defffb04 	addi	sp,sp,-20
 1800da4:	dfc00415 	stw	ra,16(sp)
 1800da8:	df000315 	stw	fp,12(sp)
 1800dac:	df000304 	addi	fp,sp,12
 1800db0:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 1800db4:	0005303a 	rdctl	r2,status
 1800db8:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 1800dbc:	e0fffe17 	ldw	r3,-8(fp)
 1800dc0:	00bfff84 	movi	r2,-2
 1800dc4:	1884703a 	and	r2,r3,r2
 1800dc8:	1001703a 	wrctl	status,r2

  chSysLock();
  chDbgAssert(tp->p_state == THD_STATE_SUSPENDED,
              "chThdResume(), #1",
              "thread not in THD_STATE_SUSPENDED state");
  chSchWakeupS(tp, RDY_OK);
 1800dcc:	e13fff17 	ldw	r4,-4(fp)
 1800dd0:	000b883a 	mov	r5,zero
 1800dd4:	180463c0 	call	180463c <chSchWakeupS>
 1800dd8:	00800044 	movi	r2,1
 1800ddc:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 1800de0:	e0bffd17 	ldw	r2,-12(fp)
 1800de4:	1001703a 	wrctl	status,r2
  chSysUnlock();
  return tp;
 1800de8:	e0bfff17 	ldw	r2,-4(fp)
}
 1800dec:	e037883a 	mov	sp,fp
 1800df0:	dfc00117 	ldw	ra,4(sp)
 1800df4:	df000017 	ldw	fp,0(sp)
 1800df8:	dec00204 	addi	sp,sp,8
 1800dfc:	f800283a 	ret

01800e00 <chThdTerminate>:
 *
 * @param[in] tp        pointer to the thread
 *
 * @api
 */
void chThdTerminate(Thread *tp) {
 1800e00:	defffc04 	addi	sp,sp,-16
 1800e04:	df000315 	stw	fp,12(sp)
 1800e08:	df000304 	addi	fp,sp,12
 1800e0c:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 1800e10:	0005303a 	rdctl	r2,status
 1800e14:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 1800e18:	e0fffe17 	ldw	r3,-8(fp)
 1800e1c:	00bfff84 	movi	r2,-2
 1800e20:	1884703a 	and	r2,r3,r2
 1800e24:	1001703a 	wrctl	status,r2

  chSysLock();
  tp->p_flags |= THD_TERMINATE;
 1800e28:	e0bfff17 	ldw	r2,-4(fp)
 1800e2c:	10800743 	ldbu	r2,29(r2)
 1800e30:	10800114 	ori	r2,r2,4
 1800e34:	1007883a 	mov	r3,r2
 1800e38:	e0bfff17 	ldw	r2,-4(fp)
 1800e3c:	10c00745 	stb	r3,29(r2)
 1800e40:	00800044 	movi	r2,1
 1800e44:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 1800e48:	e0bffd17 	ldw	r2,-12(fp)
 1800e4c:	1001703a 	wrctl	status,r2
  chSysUnlock();
}
 1800e50:	e037883a 	mov	sp,fp
 1800e54:	df000017 	ldw	fp,0(sp)
 1800e58:	dec00104 	addi	sp,sp,4
 1800e5c:	f800283a 	ret

01800e60 <chThdSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
void chThdSleep(systime_t time) {
 1800e60:	defffb04 	addi	sp,sp,-20
 1800e64:	dfc00415 	stw	ra,16(sp)
 1800e68:	df000315 	stw	fp,12(sp)
 1800e6c:	df000304 	addi	fp,sp,12
 1800e70:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 1800e74:	0005303a 	rdctl	r2,status
 1800e78:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 1800e7c:	e0fffe17 	ldw	r3,-8(fp)
 1800e80:	00bfff84 	movi	r2,-2
 1800e84:	1884703a 	and	r2,r3,r2
 1800e88:	1001703a 	wrctl	status,r2

  chDbgCheck(time != TIME_IMMEDIATE, "chThdSleep");

  chSysLock();
  chThdSleepS(time);
 1800e8c:	01000184 	movi	r4,6
 1800e90:	e17fff17 	ldw	r5,-4(fp)
 1800e94:	18045ac0 	call	18045ac <chSchGoSleepTimeoutS>
 1800e98:	00800044 	movi	r2,1
 1800e9c:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 1800ea0:	e0bffd17 	ldw	r2,-12(fp)
 1800ea4:	1001703a 	wrctl	status,r2
  chSysUnlock();
}
 1800ea8:	e037883a 	mov	sp,fp
 1800eac:	dfc00117 	ldw	ra,4(sp)
 1800eb0:	df000017 	ldw	fp,0(sp)
 1800eb4:	dec00204 	addi	sp,sp,8
 1800eb8:	f800283a 	ret

01800ebc <chThdSleepUntil>:
 *
 * @param[in] time      absolute system time
 *
 * @api
 */
void chThdSleepUntil(systime_t time) {
 1800ebc:	defffb04 	addi	sp,sp,-20
 1800ec0:	dfc00415 	stw	ra,16(sp)
 1800ec4:	df000315 	stw	fp,12(sp)
 1800ec8:	df000304 	addi	fp,sp,12
 1800ecc:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 1800ed0:	0005303a 	rdctl	r2,status
 1800ed4:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 1800ed8:	e0fffe17 	ldw	r3,-8(fp)
 1800edc:	00bfff84 	movi	r2,-2
 1800ee0:	1884703a 	and	r2,r3,r2
 1800ee4:	1001703a 	wrctl	status,r2

  chSysLock();
  if ((time -= chTimeNow()) > 0)
 1800ee8:	00806074 	movhi	r2,385
 1800eec:	10b2cd04 	addi	r2,r2,-13516
 1800ef0:	10c00317 	ldw	r3,12(r2)
 1800ef4:	e0bfff17 	ldw	r2,-4(fp)
 1800ef8:	10c5c83a 	sub	r2,r2,r3
 1800efc:	e0bfff15 	stw	r2,-4(fp)
 1800f00:	e0bfff17 	ldw	r2,-4(fp)
 1800f04:	1005003a 	cmpeq	r2,r2,zero
 1800f08:	1000031e 	bne	r2,zero,1800f18 <chThdSleepUntil+0x5c>
    chThdSleepS(time);
 1800f0c:	01000184 	movi	r4,6
 1800f10:	e17fff17 	ldw	r5,-4(fp)
 1800f14:	18045ac0 	call	18045ac <chSchGoSleepTimeoutS>
 1800f18:	00800044 	movi	r2,1
 1800f1c:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 1800f20:	e0bffd17 	ldw	r2,-12(fp)
 1800f24:	1001703a 	wrctl	status,r2
  chSysUnlock();
}
 1800f28:	e037883a 	mov	sp,fp
 1800f2c:	dfc00117 	ldw	ra,4(sp)
 1800f30:	df000017 	ldw	fp,0(sp)
 1800f34:	dec00204 	addi	sp,sp,8
 1800f38:	f800283a 	ret

01800f3c <chThdYield>:
 * @details Yields the CPU control to the next thread in the ready list with
 *          equal priority, if any.
 *
 * @api
 */
void chThdYield(void) {
 1800f3c:	defffc04 	addi	sp,sp,-16
 1800f40:	dfc00315 	stw	ra,12(sp)
 1800f44:	df000215 	stw	fp,8(sp)
 1800f48:	df000204 	addi	fp,sp,8
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 1800f4c:	0005303a 	rdctl	r2,status
 1800f50:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 1800f54:	e0ffff17 	ldw	r3,-4(fp)
 1800f58:	00bfff84 	movi	r2,-2
 1800f5c:	1884703a 	and	r2,r3,r2
 1800f60:	1001703a 	wrctl	status,r2

  chSysLock();
  chSchDoYieldS();
 1800f64:	00806074 	movhi	r2,385
 1800f68:	10b2d104 	addi	r2,r2,-13500
 1800f6c:	10800017 	ldw	r2,0(r2)
 1800f70:	10c00217 	ldw	r3,8(r2)
 1800f74:	00806074 	movhi	r2,385
 1800f78:	10b2d104 	addi	r2,r2,-13500
 1800f7c:	10800717 	ldw	r2,28(r2)
 1800f80:	10800217 	ldw	r2,8(r2)
 1800f84:	18800136 	bltu	r3,r2,1800f8c <chThdYield+0x50>
 1800f88:	18047b40 	call	18047b4 <chSchDoReschedule>
 1800f8c:	00800044 	movi	r2,1
 1800f90:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 1800f94:	e0bffe17 	ldw	r2,-8(fp)
 1800f98:	1001703a 	wrctl	status,r2
  chSysUnlock();
}
 1800f9c:	e037883a 	mov	sp,fp
 1800fa0:	dfc00117 	ldw	ra,4(sp)
 1800fa4:	df000017 	ldw	fp,0(sp)
 1800fa8:	dec00204 	addi	sp,sp,8
 1800fac:	f800283a 	ret

01800fb0 <chThdExit>:
 *
 * @param[in] msg       thread exit code
 *
 * @api
 */
void chThdExit(msg_t msg) {
 1800fb0:	defffc04 	addi	sp,sp,-16
 1800fb4:	dfc00315 	stw	ra,12(sp)
 1800fb8:	df000215 	stw	fp,8(sp)
 1800fbc:	df000204 	addi	fp,sp,8
 1800fc0:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 1800fc4:	0005303a 	rdctl	r2,status
 1800fc8:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 1800fcc:	e0fffe17 	ldw	r3,-8(fp)
 1800fd0:	00bfff84 	movi	r2,-2
 1800fd4:	1884703a 	and	r2,r3,r2
 1800fd8:	1001703a 	wrctl	status,r2

  chSysLock();
  chThdExitS(msg);
 1800fdc:	e13fff17 	ldw	r4,-4(fp)
 1800fe0:	1800ff80 	call	1800ff8 <chThdExitS>
  /* The thread never returns here.*/
}
 1800fe4:	e037883a 	mov	sp,fp
 1800fe8:	dfc00117 	ldw	ra,4(sp)
 1800fec:	df000017 	ldw	fp,0(sp)
 1800ff0:	dec00204 	addi	sp,sp,8
 1800ff4:	f800283a 	ret

01800ff8 <chThdExitS>:
 *
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
 1800ff8:	defffc04 	addi	sp,sp,-16
 1800ffc:	dfc00315 	stw	ra,12(sp)
 1801000:	df000215 	stw	fp,8(sp)
 1801004:	df000204 	addi	fp,sp,8
 1801008:	e13fff15 	stw	r4,-4(fp)
  Thread *tp = currp;
 180100c:	00806074 	movhi	r2,385
 1801010:	10b2d104 	addi	r2,r2,-13500
 1801014:	10800717 	ldw	r2,28(r2)
 1801018:	e0bffe15 	stw	r2,-8(fp)

  tp->p_u.exitcode = msg;
 180101c:	e0fffe17 	ldw	r3,-8(fp)
 1801020:	e0bfff17 	ldw	r2,-4(fp)
 1801024:	18800915 	stw	r2,36(r3)
#if defined(THREAD_EXT_EXIT_HOOK)
  THREAD_EXT_EXIT_HOOK(tp);
#endif
#if CH_USE_WAITEXIT
  while (notempty(&tp->p_waiting))
 1801028:	00000506 	br	1801040 <chThdExitS+0x48>
    chSchReadyI(list_remove(&tp->p_waiting));
 180102c:	e0bffe17 	ldw	r2,-8(fp)
 1801030:	11000a04 	addi	r4,r2,40
 1801034:	18010b00 	call	18010b0 <list_remove>
 1801038:	1009883a 	mov	r4,r2
 180103c:	18043180 	call	1804318 <chSchReadyI>
  tp->p_u.exitcode = msg;
#if defined(THREAD_EXT_EXIT_HOOK)
  THREAD_EXT_EXIT_HOOK(tp);
#endif
#if CH_USE_WAITEXIT
  while (notempty(&tp->p_waiting))
 1801040:	e0bffe17 	ldw	r2,-8(fp)
 1801044:	10c00a17 	ldw	r3,40(r2)
 1801048:	e0bffe17 	ldw	r2,-8(fp)
 180104c:	10800a04 	addi	r2,r2,40
 1801050:	18bff61e 	bne	r3,r2,180102c <chThdExitS+0x34>
    chSchReadyI(list_remove(&tp->p_waiting));
#endif
#if CH_USE_REGISTRY
  /* Static threads are immediately removed from the registry because
     there is no memory to recover.*/
  if ((tp->p_flags & THD_MEM_MODE_MASK) == THD_MEM_MODE_STATIC)
 1801054:	e0bffe17 	ldw	r2,-8(fp)
 1801058:	10800743 	ldbu	r2,29(r2)
 180105c:	10803fcc 	andi	r2,r2,255
 1801060:	108000cc 	andi	r2,r2,3
 1801064:	1004c03a 	cmpne	r2,r2,zero
 1801068:	10000a1e 	bne	r2,zero,1801094 <chThdExitS+0x9c>
    REG_REMOVE(tp);
 180106c:	e0bffe17 	ldw	r2,-8(fp)
 1801070:	10c00517 	ldw	r3,20(r2)
 1801074:	e0bffe17 	ldw	r2,-8(fp)
 1801078:	10800417 	ldw	r2,16(r2)
 180107c:	18800415 	stw	r2,16(r3)
 1801080:	e0bffe17 	ldw	r2,-8(fp)
 1801084:	10c00417 	ldw	r3,16(r2)
 1801088:	e0bffe17 	ldw	r2,-8(fp)
 180108c:	10800517 	ldw	r2,20(r2)
 1801090:	18800515 	stw	r2,20(r3)
#endif
  chSchGoSleepS(THD_STATE_FINAL);
 1801094:	01000384 	movi	r4,14
 1801098:	18043c00 	call	18043c0 <chSchGoSleepS>
  /* The thread never returns here.*/
  chDbgAssert(FALSE, "chThdExitS(), #1", "zombies apocalypse");
}
 180109c:	e037883a 	mov	sp,fp
 18010a0:	dfc00117 	ldw	ra,4(sp)
 18010a4:	df000017 	ldw	fp,0(sp)
 18010a8:	dec00204 	addi	sp,sp,8
 18010ac:	f800283a 	ret

018010b0 <list_remove>:

  tp->p_next = tlp->p_next;
  tlp->p_next = tp;
}

static INLINE Thread *list_remove(ThreadsList *tlp) {
 18010b0:	defffd04 	addi	sp,sp,-12
 18010b4:	df000215 	stw	fp,8(sp)
 18010b8:	df000204 	addi	fp,sp,8
 18010bc:	e13fff15 	stw	r4,-4(fp)

  Thread *tp = tlp->p_next;
 18010c0:	e0bfff17 	ldw	r2,-4(fp)
 18010c4:	10800017 	ldw	r2,0(r2)
 18010c8:	e0bffe15 	stw	r2,-8(fp)
  tlp->p_next = tp->p_next;
 18010cc:	e0bffe17 	ldw	r2,-8(fp)
 18010d0:	10c00017 	ldw	r3,0(r2)
 18010d4:	e0bfff17 	ldw	r2,-4(fp)
 18010d8:	10c00015 	stw	r3,0(r2)
  return tp;
 18010dc:	e0bffe17 	ldw	r2,-8(fp)
}
 18010e0:	e037883a 	mov	sp,fp
 18010e4:	df000017 	ldw	fp,0(sp)
 18010e8:	dec00104 	addi	sp,sp,4
 18010ec:	f800283a 	ret

018010f0 <chThdWait>:
 * @param[in] tp        pointer to the thread
 * @return              The exit code from the terminated thread.
 *
 * @api
 */
msg_t chThdWait(Thread *tp) {
 18010f0:	defffa04 	addi	sp,sp,-24
 18010f4:	dfc00515 	stw	ra,20(sp)
 18010f8:	df000415 	stw	fp,16(sp)
 18010fc:	df000404 	addi	fp,sp,16
 1801100:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 1801104:	0005303a 	rdctl	r2,status
 1801108:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 180110c:	e0fffd17 	ldw	r3,-12(fp)
 1801110:	00bfff84 	movi	r2,-2
 1801114:	1884703a 	and	r2,r3,r2
 1801118:	1001703a 	wrctl	status,r2
  chSysLock();
  chDbgAssert(tp != currp, "chThdWait(), #1", "waiting self");
#if CH_USE_DYNAMIC
  chDbgAssert(tp->p_refs > 0, "chThdWait(), #2", "not referenced");
#endif
  if (tp->p_state != THD_STATE_FINAL) {
 180111c:	e0bfff17 	ldw	r2,-4(fp)
 1801120:	10800703 	ldbu	r2,28(r2)
 1801124:	10803fcc 	andi	r2,r2,255
 1801128:	108003a0 	cmpeqi	r2,r2,14
 180112c:	1000081e 	bne	r2,zero,1801150 <chThdWait+0x60>
    list_insert(currp, &tp->p_waiting);
 1801130:	00806074 	movhi	r2,385
 1801134:	10b2d104 	addi	r2,r2,-13500
 1801138:	11000717 	ldw	r4,28(r2)
 180113c:	e0bfff17 	ldw	r2,-4(fp)
 1801140:	11400a04 	addi	r5,r2,40
 1801144:	180118c0 	call	180118c <list_insert>
    chSchGoSleepS(THD_STATE_WTEXIT);
 1801148:	010001c4 	movi	r4,7
 180114c:	18043c00 	call	18043c0 <chSchGoSleepS>
  }
  msg = tp->p_u.exitcode;
 1801150:	e0bfff17 	ldw	r2,-4(fp)
 1801154:	10800917 	ldw	r2,36(r2)
 1801158:	e0bffe15 	stw	r2,-8(fp)
 180115c:	00800044 	movi	r2,1
 1801160:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 1801164:	e0bffc17 	ldw	r2,-16(fp)
 1801168:	1001703a 	wrctl	status,r2
  chSysUnlock();
#if CH_USE_DYNAMIC
  chThdRelease(tp);
 180116c:	e13fff17 	ldw	r4,-4(fp)
 1801170:	1802ff40 	call	1802ff4 <chThdRelease>
#endif
  return msg;
 1801174:	e0bffe17 	ldw	r2,-8(fp)
}
 1801178:	e037883a 	mov	sp,fp
 180117c:	dfc00117 	ldw	ra,4(sp)
 1801180:	df000017 	ldw	fp,0(sp)
 1801184:	dec00204 	addi	sp,sp,8
 1801188:	f800283a 	ret

0180118c <list_insert>:
  tp->p_prev->p_next = tp->p_next;
  tp->p_next->p_prev = tp->p_prev;
  return tp;
}

static INLINE void list_insert(Thread *tp, ThreadsList *tlp) {
 180118c:	defffd04 	addi	sp,sp,-12
 1801190:	df000215 	stw	fp,8(sp)
 1801194:	df000204 	addi	fp,sp,8
 1801198:	e13ffe15 	stw	r4,-8(fp)
 180119c:	e17fff15 	stw	r5,-4(fp)

  tp->p_next = tlp->p_next;
 18011a0:	e0bfff17 	ldw	r2,-4(fp)
 18011a4:	10c00017 	ldw	r3,0(r2)
 18011a8:	e0bffe17 	ldw	r2,-8(fp)
 18011ac:	10c00015 	stw	r3,0(r2)
  tlp->p_next = tp;
 18011b0:	e0ffff17 	ldw	r3,-4(fp)
 18011b4:	e0bffe17 	ldw	r2,-8(fp)
 18011b8:	18800015 	stw	r2,0(r3)
}
 18011bc:	e037883a 	mov	sp,fp
 18011c0:	df000017 	ldw	fp,0(sp)
 18011c4:	dec00104 	addi	sp,sp,4
 18011c8:	f800283a 	ret

018011cc <_vt_init>:
 * @brief   Virtual Timers initialization.
 * @note    Internal use only.
 *
 * @notapi
 */
void _vt_init(void) {
 18011cc:	deffff04 	addi	sp,sp,-4
 18011d0:	df000015 	stw	fp,0(sp)
 18011d4:	d839883a 	mov	fp,sp

  vtlist.vt_next = vtlist.vt_prev = (void *)&vtlist;
 18011d8:	00c06074 	movhi	r3,385
 18011dc:	18f2cd04 	addi	r3,r3,-13516
 18011e0:	00806074 	movhi	r2,385
 18011e4:	10b2cd04 	addi	r2,r2,-13516
 18011e8:	10c00115 	stw	r3,4(r2)
 18011ec:	00806074 	movhi	r2,385
 18011f0:	10b2cd04 	addi	r2,r2,-13516
 18011f4:	10c00117 	ldw	r3,4(r2)
 18011f8:	00806074 	movhi	r2,385
 18011fc:	10b2cd04 	addi	r2,r2,-13516
 1801200:	10c00015 	stw	r3,0(r2)
  vtlist.vt_time = (systime_t)-1;
 1801204:	00c06074 	movhi	r3,385
 1801208:	18f2cd04 	addi	r3,r3,-13516
 180120c:	00bfffc4 	movi	r2,-1
 1801210:	18800215 	stw	r2,8(r3)
  vtlist.vt_systime = 0;
 1801214:	00806074 	movhi	r2,385
 1801218:	10b2cd04 	addi	r2,r2,-13516
 180121c:	10000315 	stw	zero,12(r2)
}
 1801220:	e037883a 	mov	sp,fp
 1801224:	df000017 	ldw	fp,0(sp)
 1801228:	dec00104 	addi	sp,sp,4
 180122c:	f800283a 	ret

01801230 <chVTSetI>:
 * @param[in] par       a parameter that will be passed to the callback
 *                      function
 *
 * @iclass
 */
void chVTSetI(VirtualTimer *vtp, systime_t time, vtfunc_t vtfunc, void *par) {
 1801230:	defffa04 	addi	sp,sp,-24
 1801234:	df000515 	stw	fp,20(sp)
 1801238:	df000504 	addi	fp,sp,20
 180123c:	e13ffc15 	stw	r4,-16(fp)
 1801240:	e17ffd15 	stw	r5,-12(fp)
 1801244:	e1bffe15 	stw	r6,-8(fp)
 1801248:	e1ffff15 	stw	r7,-4(fp)
  VirtualTimer *p;

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (time != TIME_IMMEDIATE),
 180124c:	e0bffc17 	ldw	r2,-16(fp)
 1801250:	1005003a 	cmpeq	r2,r2,zero
 1801254:	1000031e 	bne	r2,zero,1801264 <chVTSetI+0x34>
 1801258:	e0bffe17 	ldw	r2,-8(fp)
 180125c:	1005003a 	cmpeq	r2,r2,zero
 1801260:	1000001e 	bne	r2,zero,1801264 <chVTSetI+0x34>
             "chVTSetI");

  vtp->vt_par = par;
 1801264:	e0fffc17 	ldw	r3,-16(fp)
 1801268:	e0bfff17 	ldw	r2,-4(fp)
 180126c:	18800415 	stw	r2,16(r3)
  vtp->vt_func = vtfunc;
 1801270:	e0fffc17 	ldw	r3,-16(fp)
 1801274:	e0bffe17 	ldw	r2,-8(fp)
 1801278:	18800315 	stw	r2,12(r3)
  p = vtlist.vt_next;
 180127c:	00806074 	movhi	r2,385
 1801280:	10b2cd04 	addi	r2,r2,-13516
 1801284:	10800017 	ldw	r2,0(r2)
 1801288:	e0bffb15 	stw	r2,-20(fp)
  while (p->vt_time < time) {
 180128c:	00000806 	br	18012b0 <chVTSetI+0x80>
    time -= p->vt_time;
 1801290:	e0bffb17 	ldw	r2,-20(fp)
 1801294:	10c00217 	ldw	r3,8(r2)
 1801298:	e0bffd17 	ldw	r2,-12(fp)
 180129c:	10c5c83a 	sub	r2,r2,r3
 18012a0:	e0bffd15 	stw	r2,-12(fp)
    p = p->vt_next;
 18012a4:	e0bffb17 	ldw	r2,-20(fp)
 18012a8:	10800017 	ldw	r2,0(r2)
 18012ac:	e0bffb15 	stw	r2,-20(fp)
             "chVTSetI");

  vtp->vt_par = par;
  vtp->vt_func = vtfunc;
  p = vtlist.vt_next;
  while (p->vt_time < time) {
 18012b0:	e0bffb17 	ldw	r2,-20(fp)
 18012b4:	10c00217 	ldw	r3,8(r2)
 18012b8:	e0bffd17 	ldw	r2,-12(fp)
 18012bc:	18bff436 	bltu	r3,r2,1801290 <chVTSetI+0x60>
    time -= p->vt_time;
    p = p->vt_next;
  }

  vtp->vt_prev = (vtp->vt_next = p)->vt_prev;
 18012c0:	e0fffc17 	ldw	r3,-16(fp)
 18012c4:	e0bffb17 	ldw	r2,-20(fp)
 18012c8:	18800015 	stw	r2,0(r3)
 18012cc:	e0bffc17 	ldw	r2,-16(fp)
 18012d0:	10800017 	ldw	r2,0(r2)
 18012d4:	10c00117 	ldw	r3,4(r2)
 18012d8:	e0bffc17 	ldw	r2,-16(fp)
 18012dc:	10c00115 	stw	r3,4(r2)
  vtp->vt_prev->vt_next = p->vt_prev = vtp;
 18012e0:	e0bffc17 	ldw	r2,-16(fp)
 18012e4:	11000117 	ldw	r4,4(r2)
 18012e8:	e0fffb17 	ldw	r3,-20(fp)
 18012ec:	e0bffc17 	ldw	r2,-16(fp)
 18012f0:	18800115 	stw	r2,4(r3)
 18012f4:	e0bffb17 	ldw	r2,-20(fp)
 18012f8:	10800117 	ldw	r2,4(r2)
 18012fc:	20800015 	stw	r2,0(r4)
  vtp->vt_time = time;
 1801300:	e0fffc17 	ldw	r3,-16(fp)
 1801304:	e0bffd17 	ldw	r2,-12(fp)
 1801308:	18800215 	stw	r2,8(r3)
  if (p != (void *)&vtlist)
 180130c:	e0fffb17 	ldw	r3,-20(fp)
 1801310:	00806074 	movhi	r2,385
 1801314:	10b2cd04 	addi	r2,r2,-13516
 1801318:	18800626 	beq	r3,r2,1801334 <chVTSetI+0x104>
    p->vt_time -= time;
 180131c:	e0bffb17 	ldw	r2,-20(fp)
 1801320:	10c00217 	ldw	r3,8(r2)
 1801324:	e0bffd17 	ldw	r2,-12(fp)
 1801328:	1887c83a 	sub	r3,r3,r2
 180132c:	e0bffb17 	ldw	r2,-20(fp)
 1801330:	10c00215 	stw	r3,8(r2)
}
 1801334:	e037883a 	mov	sp,fp
 1801338:	df000017 	ldw	fp,0(sp)
 180133c:	dec00104 	addi	sp,sp,4
 1801340:	f800283a 	ret

01801344 <chVTResetI>:
 *
 * @param[in] vtp       the @p VirtualTimer structure pointer
 *
 * @iclass
 */
void chVTResetI(VirtualTimer *vtp) {
 1801344:	defffe04 	addi	sp,sp,-8
 1801348:	df000115 	stw	fp,4(sp)
 180134c:	df000104 	addi	fp,sp,4
 1801350:	e13fff15 	stw	r4,-4(fp)
  chDbgCheck(vtp != NULL, "chVTResetI");
  chDbgAssert(vtp->vt_func != NULL,
              "chVTResetI(), #1",
              "timer not set or already triggered");

  if (vtp->vt_next != (void *)&vtlist)
 1801354:	e0bfff17 	ldw	r2,-4(fp)
 1801358:	10c00017 	ldw	r3,0(r2)
 180135c:	00806074 	movhi	r2,385
 1801360:	10b2cd04 	addi	r2,r2,-13516
 1801364:	18800926 	beq	r3,r2,180138c <chVTResetI+0x48>
    vtp->vt_next->vt_time += vtp->vt_time;
 1801368:	e0bfff17 	ldw	r2,-4(fp)
 180136c:	11000017 	ldw	r4,0(r2)
 1801370:	e0bfff17 	ldw	r2,-4(fp)
 1801374:	10800017 	ldw	r2,0(r2)
 1801378:	10c00217 	ldw	r3,8(r2)
 180137c:	e0bfff17 	ldw	r2,-4(fp)
 1801380:	10800217 	ldw	r2,8(r2)
 1801384:	1885883a 	add	r2,r3,r2
 1801388:	20800215 	stw	r2,8(r4)
  vtp->vt_prev->vt_next = vtp->vt_next;
 180138c:	e0bfff17 	ldw	r2,-4(fp)
 1801390:	10c00117 	ldw	r3,4(r2)
 1801394:	e0bfff17 	ldw	r2,-4(fp)
 1801398:	10800017 	ldw	r2,0(r2)
 180139c:	18800015 	stw	r2,0(r3)
  vtp->vt_next->vt_prev = vtp->vt_prev;
 18013a0:	e0bfff17 	ldw	r2,-4(fp)
 18013a4:	10c00017 	ldw	r3,0(r2)
 18013a8:	e0bfff17 	ldw	r2,-4(fp)
 18013ac:	10800117 	ldw	r2,4(r2)
 18013b0:	18800115 	stw	r2,4(r3)
  vtp->vt_func = (vtfunc_t)NULL;
 18013b4:	e0bfff17 	ldw	r2,-4(fp)
 18013b8:	10000315 	stw	zero,12(r2)
}
 18013bc:	e037883a 	mov	sp,fp
 18013c0:	df000017 	ldw	fp,0(sp)
 18013c4:	dec00104 	addi	sp,sp,4
 18013c8:	f800283a 	ret

018013cc <chTimeIsWithin>:
 * @retval TRUE         current time within the specified time window.
 * @retval FALSE        current time not within the specified time window.
 *
 * @api
 */
bool_t chTimeIsWithin(systime_t start, systime_t end) {
 18013cc:	defff904 	addi	sp,sp,-28
 18013d0:	df000615 	stw	fp,24(sp)
 18013d4:	df000604 	addi	fp,sp,24
 18013d8:	e13ffb15 	stw	r4,-20(fp)
 18013dc:	e17ffc15 	stw	r5,-16(fp)

  systime_t time = chTimeNow();
 18013e0:	00806074 	movhi	r2,385
 18013e4:	10b2cd04 	addi	r2,r2,-13516
 18013e8:	10800317 	ldw	r2,12(r2)
 18013ec:	e0bffa15 	stw	r2,-24(fp)
  return end > start ? (time >= start) && (time < end) :
 18013f0:	e0fffc17 	ldw	r3,-16(fp)
 18013f4:	e0bffb17 	ldw	r2,-20(fp)
 18013f8:	10c00d2e 	bgeu	r2,r3,1801430 <chTimeIsWithin+0x64>
 18013fc:	e0fffa17 	ldw	r3,-24(fp)
 1801400:	e0bffb17 	ldw	r2,-20(fp)
 1801404:	18800636 	bltu	r3,r2,1801420 <chTimeIsWithin+0x54>
 1801408:	e0fffa17 	ldw	r3,-24(fp)
 180140c:	e0bffc17 	ldw	r2,-16(fp)
 1801410:	1880032e 	bgeu	r3,r2,1801420 <chTimeIsWithin+0x54>
 1801414:	00800044 	movi	r2,1
 1801418:	e0bffe15 	stw	r2,-8(fp)
 180141c:	00000106 	br	1801424 <chTimeIsWithin+0x58>
 1801420:	e03ffe15 	stw	zero,-8(fp)
 1801424:	e0bffe17 	ldw	r2,-8(fp)
 1801428:	e0bfff15 	stw	r2,-4(fp)
 180142c:	00000c06 	br	1801460 <chTimeIsWithin+0x94>
 1801430:	e0fffa17 	ldw	r3,-24(fp)
 1801434:	e0bffb17 	ldw	r2,-20(fp)
 1801438:	1880032e 	bgeu	r3,r2,1801448 <chTimeIsWithin+0x7c>
 180143c:	e0fffa17 	ldw	r3,-24(fp)
 1801440:	e0bffc17 	ldw	r2,-16(fp)
 1801444:	1880032e 	bgeu	r3,r2,1801454 <chTimeIsWithin+0x88>
 1801448:	00800044 	movi	r2,1
 180144c:	e0bffd15 	stw	r2,-12(fp)
 1801450:	00000106 	br	1801458 <chTimeIsWithin+0x8c>
 1801454:	e03ffd15 	stw	zero,-12(fp)
 1801458:	e0bffd17 	ldw	r2,-12(fp)
 180145c:	e0bfff15 	stw	r2,-4(fp)
 1801460:	e0bfff17 	ldw	r2,-4(fp)
                       (time >= start) || (time < end);
}
 1801464:	e037883a 	mov	sp,fp
 1801468:	df000017 	ldw	fp,0(sp)
 180146c:	dec00104 	addi	sp,sp,4
 1801470:	f800283a 	ret

01801474 <_port_thread_start>:
/*                                                                         */
/*  Start a thread by invoking its work function.                          */
/***************************************************************************/
_port_thread_start:

      mov   r4, r17        /* r4 = Register Arguments (First 32 bits) */
 1801474:	8809883a 	mov	r4,r17
      mov   r5, r16        /* Store thread pointer for the callr,     */
 1801478:	800b883a 	mov	r5,r16
      callr r5             /* and call the thread */
 180147c:	283ee83a 	callr	r5
      call  chThdExit      /* This is the thread exit function. */
 1801480:	1800fb00 	call	1800fb0 <chThdExit>

01801484 <_port_thread_start_loop>:
      
_port_thread_start_loop:      
      br    _port_thread_start_loop
 1801484:	003fff06 	br	1801484 <_port_thread_start_loop>

01801488 <port_switch>:
/***************************************************************************/
port_switch:

      /* r4 = ntp, r5 = otp */

      addi  sp, sp, -44    /* Size of the intctx structure */
 1801488:	defff504 	addi	sp,sp,-44
      
      stw   ra,   0(sp)
 180148c:	dfc00015 	stw	ra,0(sp)
      stw   fp,   4(sp)
 1801490:	df000115 	stw	fp,4(sp)
      stw   r16,  8(sp)
 1801494:	dc000215 	stw	r16,8(sp)
      stw   r17, 12(sp)
 1801498:	dc400315 	stw	r17,12(sp)
      stw   r18, 16(sp)
 180149c:	dc800415 	stw	r18,16(sp)
      stw   r19, 20(sp)
 18014a0:	dcc00515 	stw	r19,20(sp)
      stw   r20, 24(sp)
 18014a4:	dd000615 	stw	r20,24(sp)
      stw   r21, 28(sp)
 18014a8:	dd400715 	stw	r21,28(sp)
      stw   r22, 32(sp)
 18014ac:	dd800815 	stw	r22,32(sp)
      stw   r23, 36(sp)
 18014b0:	ddc00915 	stw	r23,36(sp)
      
      rdctl r23, status    /* r23 is not more needed and can */
 18014b4:	002f303a 	rdctl	r23,status
      stw   r23, 40(sp)    /* be used here to store the status */
 18014b8:	ddc00a15 	stw	r23,40(sp)
      
      stw   sp, 12(r5)     /* Save old stack: otp->p_ctx.sp = sp */
 18014bc:	2ec00315 	stw	sp,12(r5)
      
      ldw   sp, 12(r4)     /* Get new stack: sp = ntp->p_ctx.sp */
 18014c0:	26c00317 	ldw	sp,12(r4)
      
      ldw   ra,   0(sp)
 18014c4:	dfc00017 	ldw	ra,0(sp)
      ldw   fp,   4(sp)
 18014c8:	df000117 	ldw	fp,4(sp)
      ldw   r16,  8(sp)
 18014cc:	dc000217 	ldw	r16,8(sp)
      ldw   r17, 12(sp)
 18014d0:	dc400317 	ldw	r17,12(sp)
      ldw   r18, 16(sp)
 18014d4:	dc800417 	ldw	r18,16(sp)
      ldw   r19, 20(sp)
 18014d8:	dcc00517 	ldw	r19,20(sp)
      ldw   r20, 24(sp)
 18014dc:	dd000617 	ldw	r20,24(sp)
      ldw   r21, 28(sp)
 18014e0:	dd400717 	ldw	r21,28(sp)
      ldw   r22, 32(sp)
 18014e4:	dd800817 	ldw	r22,32(sp)
      ldw   r23, 36(sp)
 18014e8:	ddc00917 	ldw	r23,36(sp)
      
      ldw   r4,  40(sp)    /* r4 is not more needed and can */
 18014ec:	d9000a17 	ldw	r4,40(sp)
      wrctl status, r4     /* be used here to store the status */
 18014f0:	2001703a 	wrctl	status,r4
      
      addi  sp, sp, 44     /* Size of the intctx structure */
 18014f4:	dec00b04 	addi	sp,sp,44
      
      ret
 18014f8:	f800283a 	ret
   
      nop
 18014fc:	0001883a 	nop

01801500 <alt_load>:
 * there is no bootloader, so this application is responsible for loading to
 * RAM any sections that are required.
 */  

void alt_load (void)
{
 1801500:	defffe04 	addi	sp,sp,-8
 1801504:	dfc00115 	stw	ra,4(sp)
 1801508:	df000015 	stw	fp,0(sp)
 180150c:	d839883a 	mov	fp,sp
  /* 
   * Copy the .rwdata section. 
   */

  alt_load_section (&__flash_rwdata_start, 
 1801510:	01006074 	movhi	r4,385
 1801514:	212bdb04 	addi	r4,r4,-20628
 1801518:	01406074 	movhi	r5,385
 180151c:	29651804 	addi	r5,r5,-27552
 1801520:	01806074 	movhi	r6,385
 1801524:	31abdb04 	addi	r6,r6,-20628
 1801528:	18015800 	call	1801580 <alt_load_section>

  /*
   * Copy the exception handler.
   */

  alt_load_section (&__flash_exceptions_start, 
 180152c:	01006034 	movhi	r4,384
 1801530:	21000804 	addi	r4,r4,32
 1801534:	01406034 	movhi	r5,384
 1801538:	29400804 	addi	r5,r5,32
 180153c:	01806034 	movhi	r6,384
 1801540:	31807104 	addi	r6,r6,452
 1801544:	18015800 	call	1801580 <alt_load_section>

  /*
   * Copy the .rodata section.
   */

  alt_load_section (&__flash_rodata_start, 
 1801548:	01006074 	movhi	r4,385
 180154c:	2124eb04 	addi	r4,r4,-27732
 1801550:	01406074 	movhi	r5,385
 1801554:	2964eb04 	addi	r5,r5,-27732
 1801558:	01806074 	movhi	r6,385
 180155c:	31a51804 	addi	r6,r6,-27552
 1801560:	18015800 	call	1801580 <alt_load_section>
  
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
 1801564:	1804d040 	call	1804d04 <alt_dcache_flush_all>
  alt_icache_flush_all();
 1801568:	1804f280 	call	1804f28 <alt_icache_flush_all>
}
 180156c:	e037883a 	mov	sp,fp
 1801570:	dfc00117 	ldw	ra,4(sp)
 1801574:	df000017 	ldw	fp,0(sp)
 1801578:	dec00204 	addi	sp,sp,8
 180157c:	f800283a 	ret

01801580 <alt_load_section>:
 */

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
 1801580:	defffc04 	addi	sp,sp,-16
 1801584:	df000315 	stw	fp,12(sp)
 1801588:	df000304 	addi	fp,sp,12
 180158c:	e13ffd15 	stw	r4,-12(fp)
 1801590:	e17ffe15 	stw	r5,-8(fp)
 1801594:	e1bfff15 	stw	r6,-4(fp)
  if (to != from)
 1801598:	e0fffe17 	ldw	r3,-8(fp)
 180159c:	e0bffd17 	ldw	r2,-12(fp)
 18015a0:	18800e26 	beq	r3,r2,18015dc <alt_load_section+0x5c>
  {
    while( to != end )
 18015a4:	00000a06 	br	18015d0 <alt_load_section+0x50>
    {
      *to++ = *from++;
 18015a8:	e0bffd17 	ldw	r2,-12(fp)
 18015ac:	10c00017 	ldw	r3,0(r2)
 18015b0:	e0bffe17 	ldw	r2,-8(fp)
 18015b4:	10c00015 	stw	r3,0(r2)
 18015b8:	e0bffe17 	ldw	r2,-8(fp)
 18015bc:	10800104 	addi	r2,r2,4
 18015c0:	e0bffe15 	stw	r2,-8(fp)
 18015c4:	e0bffd17 	ldw	r2,-12(fp)
 18015c8:	10800104 	addi	r2,r2,4
 18015cc:	e0bffd15 	stw	r2,-12(fp)
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
  {
    while( to != end )
 18015d0:	e0fffe17 	ldw	r3,-8(fp)
 18015d4:	e0bfff17 	ldw	r2,-4(fp)
 18015d8:	18bff31e 	bne	r3,r2,18015a8 <alt_load_section+0x28>
    {
      *to++ = *from++;
    }
  }
}
 18015dc:	e037883a 	mov	sp,fp
 18015e0:	df000017 	ldw	fp,0(sp)
 18015e4:	dec00104 	addi	sp,sp,4
 18015e8:	f800283a 	ret

018015ec <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
 18015ec:	defffc04 	addi	sp,sp,-16
 18015f0:	dfc00315 	stw	ra,12(sp)
 18015f4:	df000215 	stw	fp,8(sp)
 18015f8:	df000204 	addi	fp,sp,8
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
 18015fc:	0009883a 	mov	r4,zero
 1801600:	180194c0 	call	180194c <alt_irq_init>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 1801604:	0005303a 	rdctl	r2,status
 1801608:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 180160c:	e0fffe17 	ldw	r3,-8(fp)
 1801610:	00bfff84 	movi	r2,-2
 1801614:	1884703a 	and	r2,r3,r2
 1801618:	1001703a 	wrctl	status,r2

  /* Initialize the operating system */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_irq_init, calling alt_os_init.\r\n");
  ALT_OS_INIT();
 180161c:	18048740 	call	1804874 <chSysInit>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
 1801620:	18019800 	call	1801980 <alt_sys_init>
   * devices be present (not equal to /dev/null) and if direct drivers
   * aren't being used.
   */

    ALT_LOG_PRINT_BOOT("[alt_main.c] Redirecting IO.\r\n");
    alt_io_redirect(ALT_STDOUT, ALT_STDIN, ALT_STDERR);
 1801624:	01006074 	movhi	r4,385
 1801628:	21250504 	addi	r4,r4,-27628
 180162c:	01406074 	movhi	r5,385
 1801630:	29650504 	addi	r5,r5,-27628
 1801634:	01806074 	movhi	r6,385
 1801638:	31a50504 	addi	r6,r6,-27628
 180163c:	18052e80 	call	18052e8 <alt_io_redirect>
  /* 
   * Call the C++ constructors 
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling C++ constructors.\r\n");
  _do_ctors ();
 1801640:	1804e600 	call	1804e60 <_do_ctors>
   * redefined as _exit()). This is in the interest of reducing code footprint,
   * in that the atexit() overhead is removed when it's not needed.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling atexit.\r\n");
  atexit (_do_dtors);
 1801644:	01006034 	movhi	r4,384
 1801648:	2113b104 	addi	r4,r4,20164
 180164c:	1805b580 	call	1805b58 <atexit>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
#else
  result = main (alt_argc, alt_argv, alt_envp);
 1801650:	d126d117 	ldw	r4,-25788(gp)
 1801654:	d166d217 	ldw	r5,-25784(gp)
 1801658:	d1a6d317 	ldw	r6,-25780(gp)
 180165c:	18007e80 	call	18007e8 <main>
 1801660:	e0bfff15 	stw	r2,-4(fp)
  close(STDOUT_FILENO);
 1801664:	01000044 	movi	r4,1
 1801668:	1804ba40 	call	1804ba4 <close>
  exit (result);
 180166c:	e13fff17 	ldw	r4,-4(fp)
 1801670:	1805b6c0 	call	1805b6c <exit>

01801674 <alt_printf>:
/* 
 * ALT printf function 
 */
void 
alt_printf(const char* fmt, ... )
{
 1801674:	defff204 	addi	sp,sp,-56
 1801678:	dfc00a15 	stw	ra,40(sp)
 180167c:	df000915 	stw	fp,36(sp)
 1801680:	df000904 	addi	fp,sp,36
 1801684:	e1400215 	stw	r5,8(fp)
 1801688:	e1800315 	stw	r6,12(fp)
 180168c:	e1c00415 	stw	r7,16(fp)
 1801690:	e13fff15 	stw	r4,-4(fp)
	va_list args;
	va_start(args, fmt);
 1801694:	e0800204 	addi	r2,fp,8
 1801698:	e0bffe15 	stw	r2,-8(fp)
    const char *w;
    char c;

    /* Process format string. */
    w = fmt;
 180169c:	e0bfff17 	ldw	r2,-4(fp)
 18016a0:	e0bffd15 	stw	r2,-12(fp)
    while ((c = *w++) != 0)
 18016a4:	00007806 	br	1801888 <alt_printf+0x214>
    {
        /* If not a format escape character, just print  */
        /* character.  Otherwise, process format string. */
        if (c != '%')
 18016a8:	e0bffc07 	ldb	r2,-16(fp)
 18016ac:	10800960 	cmpeqi	r2,r2,37
 18016b0:	1000031e 	bne	r2,zero,18016c0 <alt_printf+0x4c>
        {
            alt_putchar(c);
 18016b4:	e13ffc07 	ldb	r4,-16(fp)
 18016b8:	18018cc0 	call	18018cc <alt_putchar>
 18016bc:	00007206 	br	1801888 <alt_printf+0x214>
        }
        else
        {
            /* Get format character.  If none     */
            /* available, processing is complete. */
            if ((c = *w++) != 0)
 18016c0:	e0bffd17 	ldw	r2,-12(fp)
 18016c4:	10800003 	ldbu	r2,0(r2)
 18016c8:	e0bffc05 	stb	r2,-16(fp)
 18016cc:	e0bffc07 	ldb	r2,-16(fp)
 18016d0:	1004c03a 	cmpne	r2,r2,zero
 18016d4:	1007883a 	mov	r3,r2
 18016d8:	e0bffd17 	ldw	r2,-12(fp)
 18016dc:	10800044 	addi	r2,r2,1
 18016e0:	e0bffd15 	stw	r2,-12(fp)
 18016e4:	18803fcc 	andi	r2,r3,255
 18016e8:	1005003a 	cmpeq	r2,r2,zero
 18016ec:	1000721e 	bne	r2,zero,18018b8 <alt_printf+0x244>
            {
                if (c == '%')
 18016f0:	e0bffc07 	ldb	r2,-16(fp)
 18016f4:	10800958 	cmpnei	r2,r2,37
 18016f8:	1000031e 	bne	r2,zero,1801708 <alt_printf+0x94>
                {
                    /* Process "%" escape sequence. */
                    alt_putchar(c);
 18016fc:	e13ffc07 	ldb	r4,-16(fp)
 1801700:	18018cc0 	call	18018cc <alt_putchar>
 1801704:	00006006 	br	1801888 <alt_printf+0x214>
                } 
                else if (c == 'c')
 1801708:	e0bffc07 	ldb	r2,-16(fp)
 180170c:	108018d8 	cmpnei	r2,r2,99
 1801710:	1000091e 	bne	r2,zero,1801738 <alt_printf+0xc4>
                {
                    int v = va_arg(args, int);
 1801714:	e0fffe17 	ldw	r3,-8(fp)
 1801718:	18800104 	addi	r2,r3,4
 180171c:	e0bffe15 	stw	r2,-8(fp)
 1801720:	1805883a 	mov	r2,r3
 1801724:	10800017 	ldw	r2,0(r2)
 1801728:	e0bffb15 	stw	r2,-20(fp)
                    alt_putchar(v);
 180172c:	e13ffb17 	ldw	r4,-20(fp)
 1801730:	18018cc0 	call	18018cc <alt_putchar>
 1801734:	00005406 	br	1801888 <alt_printf+0x214>
                }
                else if (c == 'x')
 1801738:	e0bffc07 	ldb	r2,-16(fp)
 180173c:	10801e18 	cmpnei	r2,r2,120
 1801740:	1000371e 	bne	r2,zero,1801820 <alt_printf+0x1ac>
                {
                    /* Process hexadecimal number format. */
                    unsigned long v = va_arg(args, unsigned long);
 1801744:	e0fffe17 	ldw	r3,-8(fp)
 1801748:	18800104 	addi	r2,r3,4
 180174c:	e0bffe15 	stw	r2,-8(fp)
 1801750:	1805883a 	mov	r2,r3
 1801754:	10800017 	ldw	r2,0(r2)
 1801758:	e0bffa15 	stw	r2,-24(fp)
                    unsigned long digit;
                    int digit_shift;

                    /* If the number value is zero, just print and continue. */
                    if (v == 0)
 180175c:	e0bffa17 	ldw	r2,-24(fp)
 1801760:	1004c03a 	cmpne	r2,r2,zero
 1801764:	1000031e 	bne	r2,zero,1801774 <alt_printf+0x100>
                    {
                        alt_putchar('0');
 1801768:	01000c04 	movi	r4,48
 180176c:	18018cc0 	call	18018cc <alt_putchar>
                        continue;
 1801770:	00004506 	br	1801888 <alt_printf+0x214>
                    }

                    /* Find first non-zero digit. */
                    digit_shift = 28;
 1801774:	00800704 	movi	r2,28
 1801778:	e0bff815 	stw	r2,-32(fp)
                    while (!(v & (0xF << digit_shift)))
 180177c:	00000306 	br	180178c <alt_printf+0x118>
                        digit_shift -= 4;
 1801780:	e0bff817 	ldw	r2,-32(fp)
 1801784:	10bfff04 	addi	r2,r2,-4
 1801788:	e0bff815 	stw	r2,-32(fp)
                        continue;
                    }

                    /* Find first non-zero digit. */
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
 180178c:	00c003c4 	movi	r3,15
 1801790:	e0bff817 	ldw	r2,-32(fp)
 1801794:	1884983a 	sll	r2,r3,r2
 1801798:	1007883a 	mov	r3,r2
 180179c:	e0bffa17 	ldw	r2,-24(fp)
 18017a0:	1884703a 	and	r2,r3,r2
 18017a4:	1005003a 	cmpeq	r2,r2,zero
 18017a8:	103ff51e 	bne	r2,zero,1801780 <alt_printf+0x10c>
                        digit_shift -= 4;

                    /* Print digits. */
                    for (; digit_shift >= 0; digit_shift -= 4)
 18017ac:	00001806 	br	1801810 <alt_printf+0x19c>
                    {
                        digit = (v & (0xF << digit_shift)) >> digit_shift;
 18017b0:	00c003c4 	movi	r3,15
 18017b4:	e0bff817 	ldw	r2,-32(fp)
 18017b8:	1884983a 	sll	r2,r3,r2
 18017bc:	1007883a 	mov	r3,r2
 18017c0:	e0bffa17 	ldw	r2,-24(fp)
 18017c4:	1886703a 	and	r3,r3,r2
 18017c8:	e0bff817 	ldw	r2,-32(fp)
 18017cc:	1884d83a 	srl	r2,r3,r2
 18017d0:	e0bff915 	stw	r2,-28(fp)
                        if (digit <= 9)
 18017d4:	e0bff917 	ldw	r2,-28(fp)
 18017d8:	108002a8 	cmpgeui	r2,r2,10
 18017dc:	1000041e 	bne	r2,zero,18017f0 <alt_printf+0x17c>
                            c = '0' + digit;
 18017e0:	e0bff917 	ldw	r2,-28(fp)
 18017e4:	10800c04 	addi	r2,r2,48
 18017e8:	e0bffc05 	stb	r2,-16(fp)
 18017ec:	00000306 	br	18017fc <alt_printf+0x188>
                        else
                            c = 'a' + digit - 10;
 18017f0:	e0bff917 	ldw	r2,-28(fp)
 18017f4:	108015c4 	addi	r2,r2,87
 18017f8:	e0bffc05 	stb	r2,-16(fp)
                        alt_putchar(c);
 18017fc:	e13ffc07 	ldb	r4,-16(fp)
 1801800:	18018cc0 	call	18018cc <alt_putchar>
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
                        digit_shift -= 4;

                    /* Print digits. */
                    for (; digit_shift >= 0; digit_shift -= 4)
 1801804:	e0bff817 	ldw	r2,-32(fp)
 1801808:	10bfff04 	addi	r2,r2,-4
 180180c:	e0bff815 	stw	r2,-32(fp)
 1801810:	e0bff817 	ldw	r2,-32(fp)
 1801814:	1004403a 	cmpge	r2,r2,zero
 1801818:	103fe51e 	bne	r2,zero,18017b0 <alt_printf+0x13c>
 180181c:	00001a06 	br	1801888 <alt_printf+0x214>
                        else
                            c = 'a' + digit - 10;
                        alt_putchar(c);
                    }
                }
                else if (c == 's')
 1801820:	e0bffc07 	ldb	r2,-16(fp)
 1801824:	10801cd8 	cmpnei	r2,r2,115
 1801828:	1000171e 	bne	r2,zero,1801888 <alt_printf+0x214>
                {
                    /* Process string format. */
                    char *s = va_arg(args, char *);
 180182c:	e0fffe17 	ldw	r3,-8(fp)
 1801830:	18800104 	addi	r2,r3,4
 1801834:	e0bffe15 	stw	r2,-8(fp)
 1801838:	1805883a 	mov	r2,r3
 180183c:	10800017 	ldw	r2,0(r2)
 1801840:	e0bff715 	stw	r2,-36(fp)

                    while(*s)
 1801844:	00000906 	br	180186c <alt_printf+0x1f8>
                      alt_putchar(*s++);
 1801848:	e0bff717 	ldw	r2,-36(fp)
 180184c:	10800003 	ldbu	r2,0(r2)
 1801850:	11003fcc 	andi	r4,r2,255
 1801854:	2100201c 	xori	r4,r4,128
 1801858:	213fe004 	addi	r4,r4,-128
 180185c:	e0bff717 	ldw	r2,-36(fp)
 1801860:	10800044 	addi	r2,r2,1
 1801864:	e0bff715 	stw	r2,-36(fp)
 1801868:	18018cc0 	call	18018cc <alt_putchar>
                else if (c == 's')
                {
                    /* Process string format. */
                    char *s = va_arg(args, char *);

                    while(*s)
 180186c:	e0bff717 	ldw	r2,-36(fp)
 1801870:	10800003 	ldbu	r2,0(r2)
 1801874:	10803fcc 	andi	r2,r2,255
 1801878:	1080201c 	xori	r2,r2,128
 180187c:	10bfe004 	addi	r2,r2,-128
 1801880:	1004c03a 	cmpne	r2,r2,zero
 1801884:	103ff01e 	bne	r2,zero,1801848 <alt_printf+0x1d4>
    const char *w;
    char c;

    /* Process format string. */
    w = fmt;
    while ((c = *w++) != 0)
 1801888:	e0bffd17 	ldw	r2,-12(fp)
 180188c:	10800003 	ldbu	r2,0(r2)
 1801890:	e0bffc05 	stb	r2,-16(fp)
 1801894:	e0bffc07 	ldb	r2,-16(fp)
 1801898:	1004c03a 	cmpne	r2,r2,zero
 180189c:	1007883a 	mov	r3,r2
 18018a0:	e0bffd17 	ldw	r2,-12(fp)
 18018a4:	10800044 	addi	r2,r2,1
 18018a8:	e0bffd15 	stw	r2,-12(fp)
 18018ac:	18803fcc 	andi	r2,r3,255
 18018b0:	1004c03a 	cmpne	r2,r2,zero
 18018b4:	103f7c1e 	bne	r2,zero,18016a8 <alt_printf+0x34>
            {
                break;
            }
        }
    }
}
 18018b8:	e037883a 	mov	sp,fp
 18018bc:	dfc00117 	ldw	ra,4(sp)
 18018c0:	df000017 	ldw	fp,0(sp)
 18018c4:	dec00504 	addi	sp,sp,20
 18018c8:	f800283a 	ret

018018cc <alt_putchar>:
 * Uses the ALT_DRIVER_WRITE() macro to call directly to driver if available.
 * Otherwise, uses newlib provided putchar() routine.
 */
int 
alt_putchar(int c)
{
 18018cc:	defffd04 	addi	sp,sp,-12
 18018d0:	dfc00215 	stw	ra,8(sp)
 18018d4:	df000115 	stw	fp,4(sp)
 18018d8:	df000104 	addi	fp,sp,4
 18018dc:	e13fff15 	stw	r4,-4(fp)
    if (ALT_DRIVER_WRITE(ALT_STDOUT_DEV, &c1, 1, 0) == -1) {
        return -1;
    }
    return c;
#else
    return putchar(c);
 18018e0:	00806074 	movhi	r2,385
 18018e4:	10abd604 	addi	r2,r2,-20648
 18018e8:	10800017 	ldw	r2,0(r2)
 18018ec:	11400217 	ldw	r5,8(r2)
 18018f0:	e13fff17 	ldw	r4,-4(fp)
 18018f4:	1806ae80 	call	1806ae8 <putc>
#endif
}
 18018f8:	e037883a 	mov	sp,fp
 18018fc:	dfc00117 	ldw	ra,4(sp)
 1801900:	df000017 	ldw	fp,0(sp)
 1801904:	dec00204 	addi	sp,sp,8
 1801908:	f800283a 	ret

0180190c <alt_putstr>:
 * Uses the ALT_DRIVER_WRITE() macro to call directly to driver if available.
 * Otherwise, uses newlib provided fputs() routine.
 */
int 
alt_putstr(const char* str)
{
 180190c:	defffd04 	addi	sp,sp,-12
 1801910:	dfc00215 	stw	ra,8(sp)
 1801914:	df000115 	stw	fp,4(sp)
 1801918:	df000104 	addi	fp,sp,4
 180191c:	e13fff15 	stw	r4,-4(fp)
#ifdef ALT_USE_DIRECT_DRIVERS
    ALT_DRIVER_WRITE_EXTERNS(ALT_STDOUT_DEV);
    return ALT_DRIVER_WRITE(ALT_STDOUT_DEV, str, strlen(str), 0);
#else
    return fputs(str, stdout);
 1801920:	00806074 	movhi	r2,385
 1801924:	10abd604 	addi	r2,r2,-20648
 1801928:	10800017 	ldw	r2,0(r2)
 180192c:	11400217 	ldw	r5,8(r2)
 1801930:	e13fff17 	ldw	r4,-4(fp)
 1801934:	1805c180 	call	1805c18 <fputs>
#endif
}
 1801938:	e037883a 	mov	sp,fp
 180193c:	dfc00117 	ldw	ra,4(sp)
 1801940:	df000017 	ldw	fp,0(sp)
 1801944:	dec00204 	addi	sp,sp,8
 1801948:	f800283a 	ret

0180194c <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
 180194c:	defffd04 	addi	sp,sp,-12
 1801950:	dfc00215 	stw	ra,8(sp)
 1801954:	df000115 	stw	fp,4(sp)
 1801958:	df000104 	addi	fp,sp,4
 180195c:	e13fff15 	stw	r4,-4(fp)
    ALTERA_NIOS2_QSYS_IRQ_INIT ( NIOS, nios);
 1801960:	18058640 	call	1805864 <altera_nios2_qsys_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts ()
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
 1801964:	00800044 	movi	r2,1
 1801968:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
 180196c:	e037883a 	mov	sp,fp
 1801970:	dfc00117 	ldw	ra,4(sp)
 1801974:	df000017 	ldw	fp,0(sp)
 1801978:	dec00204 	addi	sp,sp,8
 180197c:	f800283a 	ret

01801980 <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
 1801980:	defffe04 	addi	sp,sp,-8
 1801984:	dfc00115 	stw	ra,4(sp)
 1801988:	df000015 	stw	fp,0(sp)
 180198c:	d839883a 	mov	fp,sp
    ALTERA_AVALON_TIMER_INIT ( TIMER_0, timer_0);
 1801990:	01008074 	movhi	r4,513
 1801994:	21041004 	addi	r4,r4,4160
 1801998:	000b883a 	mov	r5,zero
 180199c:	018000c4 	movi	r6,3
 18019a0:	01c0fa04 	movi	r7,1000
 18019a4:	18025500 	call	1802550 <alt_avalon_timer_sc_init>
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART, jtag_uart);
 18019a8:	01006074 	movhi	r4,385
 18019ac:	21252204 	addi	r4,r4,-27512
 18019b0:	000b883a 	mov	r5,zero
 18019b4:	01800084 	movi	r6,2
 18019b8:	1801b7c0 	call	1801b7c <altera_avalon_jtag_uart_init>
 18019bc:	01006074 	movhi	r4,385
 18019c0:	21251804 	addi	r4,r4,-27552
 18019c4:	18019fc0 	call	18019fc <alt_dev_reg>
    ALTERA_AVALON_SPI_INIT ( SDCARD_SPI, sdcard_spi);
    ALTERA_AVALON_SYSID_QSYS_INIT ( SYSID, sysid);
    ALTERA_AVALON_UART_INIT ( UART_0, uart_0);
 18019c8:	01006074 	movhi	r4,385
 18019cc:	21293a04 	addi	r4,r4,-23320
 18019d0:	000b883a 	mov	r5,zero
 18019d4:	000d883a 	mov	r6,zero
 18019d8:	18026d80 	call	18026d8 <altera_avalon_uart_init>
 18019dc:	01006074 	movhi	r4,385
 18019e0:	21293004 	addi	r4,r4,-23360
 18019e4:	18019fc0 	call	18019fc <alt_dev_reg>
}
 18019e8:	e037883a 	mov	sp,fp
 18019ec:	dfc00117 	ldw	ra,4(sp)
 18019f0:	df000017 	ldw	fp,0(sp)
 18019f4:	dec00204 	addi	sp,sp,8
 18019f8:	f800283a 	ret

018019fc <alt_dev_reg>:
 */

extern int alt_fs_reg  (alt_dev* dev); 

static ALT_INLINE int alt_dev_reg (alt_dev* dev)
{
 18019fc:	defffd04 	addi	sp,sp,-12
 1801a00:	dfc00215 	stw	ra,8(sp)
 1801a04:	df000115 	stw	fp,4(sp)
 1801a08:	df000104 	addi	fp,sp,4
 1801a0c:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) dev, &alt_dev_list);
 1801a10:	e13fff17 	ldw	r4,-4(fp)
 1801a14:	01406074 	movhi	r5,385
 1801a18:	296bcf04 	addi	r5,r5,-20676
 1801a1c:	1804d4c0 	call	1804d4c <alt_dev_llist_insert>
}
 1801a20:	e037883a 	mov	sp,fp
 1801a24:	dfc00117 	ldw	ra,4(sp)
 1801a28:	df000017 	ldw	fp,0(sp)
 1801a2c:	dec00204 	addi	sp,sp,8
 1801a30:	f800283a 	ret

01801a34 <altera_avalon_jtag_uart_read_fd>:
 *
 */

int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
 1801a34:	defffa04 	addi	sp,sp,-24
 1801a38:	dfc00515 	stw	ra,20(sp)
 1801a3c:	df000415 	stw	fp,16(sp)
 1801a40:	df000404 	addi	fp,sp,16
 1801a44:	e13ffd15 	stw	r4,-12(fp)
 1801a48:	e17ffe15 	stw	r5,-8(fp)
 1801a4c:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 1801a50:	e0bffd17 	ldw	r2,-12(fp)
 1801a54:	10800017 	ldw	r2,0(r2)
 1801a58:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
 1801a5c:	e0bffc17 	ldw	r2,-16(fp)
 1801a60:	11000a04 	addi	r4,r2,40
 1801a64:	e0bffd17 	ldw	r2,-12(fp)
 1801a68:	11c00217 	ldw	r7,8(r2)
 1801a6c:	e17ffe17 	ldw	r5,-8(fp)
 1801a70:	e1bfff17 	ldw	r6,-4(fp)
 1801a74:	180207c0 	call	180207c <altera_avalon_jtag_uart_read>
      fd->fd_flags);
}
 1801a78:	e037883a 	mov	sp,fp
 1801a7c:	dfc00117 	ldw	ra,4(sp)
 1801a80:	df000017 	ldw	fp,0(sp)
 1801a84:	dec00204 	addi	sp,sp,8
 1801a88:	f800283a 	ret

01801a8c <altera_avalon_jtag_uart_write_fd>:

int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
 1801a8c:	defffa04 	addi	sp,sp,-24
 1801a90:	dfc00515 	stw	ra,20(sp)
 1801a94:	df000415 	stw	fp,16(sp)
 1801a98:	df000404 	addi	fp,sp,16
 1801a9c:	e13ffd15 	stw	r4,-12(fp)
 1801aa0:	e17ffe15 	stw	r5,-8(fp)
 1801aa4:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 1801aa8:	e0bffd17 	ldw	r2,-12(fp)
 1801aac:	10800017 	ldw	r2,0(r2)
 1801ab0:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
 1801ab4:	e0bffc17 	ldw	r2,-16(fp)
 1801ab8:	11000a04 	addi	r4,r2,40
 1801abc:	e0bffd17 	ldw	r2,-12(fp)
 1801ac0:	11c00217 	ldw	r7,8(r2)
 1801ac4:	e17ffe17 	ldw	r5,-8(fp)
 1801ac8:	e1bfff17 	ldw	r6,-4(fp)
 1801acc:	18022a00 	call	18022a0 <altera_avalon_jtag_uart_write>
      fd->fd_flags);
}
 1801ad0:	e037883a 	mov	sp,fp
 1801ad4:	dfc00117 	ldw	ra,4(sp)
 1801ad8:	df000017 	ldw	fp,0(sp)
 1801adc:	dec00204 	addi	sp,sp,8
 1801ae0:	f800283a 	ret

01801ae4 <altera_avalon_jtag_uart_close_fd>:

#ifndef ALTERA_AVALON_JTAG_UART_SMALL

int 
altera_avalon_jtag_uart_close_fd(alt_fd* fd)
{
 1801ae4:	defffc04 	addi	sp,sp,-16
 1801ae8:	dfc00315 	stw	ra,12(sp)
 1801aec:	df000215 	stw	fp,8(sp)
 1801af0:	df000204 	addi	fp,sp,8
 1801af4:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 1801af8:	e0bfff17 	ldw	r2,-4(fp)
 1801afc:	10800017 	ldw	r2,0(r2)
 1801b00:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_jtag_uart_close(&dev->state, fd->fd_flags);
 1801b04:	e0bffe17 	ldw	r2,-8(fp)
 1801b08:	11000a04 	addi	r4,r2,40
 1801b0c:	e0bfff17 	ldw	r2,-4(fp)
 1801b10:	11400217 	ldw	r5,8(r2)
 1801b14:	1801f140 	call	1801f14 <altera_avalon_jtag_uart_close>
}
 1801b18:	e037883a 	mov	sp,fp
 1801b1c:	dfc00117 	ldw	ra,4(sp)
 1801b20:	df000017 	ldw	fp,0(sp)
 1801b24:	dec00204 	addi	sp,sp,8
 1801b28:	f800283a 	ret

01801b2c <altera_avalon_jtag_uart_ioctl_fd>:

int 
altera_avalon_jtag_uart_ioctl_fd(alt_fd* fd, int req, void* arg)
{
 1801b2c:	defffa04 	addi	sp,sp,-24
 1801b30:	dfc00515 	stw	ra,20(sp)
 1801b34:	df000415 	stw	fp,16(sp)
 1801b38:	df000404 	addi	fp,sp,16
 1801b3c:	e13ffd15 	stw	r4,-12(fp)
 1801b40:	e17ffe15 	stw	r5,-8(fp)
 1801b44:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev;
 1801b48:	e0bffd17 	ldw	r2,-12(fp)
 1801b4c:	10800017 	ldw	r2,0(r2)
 1801b50:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_ioctl(&dev->state, req, arg);
 1801b54:	e0bffc17 	ldw	r2,-16(fp)
 1801b58:	11000a04 	addi	r4,r2,40
 1801b5c:	e17ffe17 	ldw	r5,-8(fp)
 1801b60:	e1bfff17 	ldw	r6,-4(fp)
 1801b64:	1801f880 	call	1801f88 <altera_avalon_jtag_uart_ioctl>
}
 1801b68:	e037883a 	mov	sp,fp
 1801b6c:	dfc00117 	ldw	ra,4(sp)
 1801b70:	df000017 	ldw	fp,0(sp)
 1801b74:	dec00204 	addi	sp,sp,8
 1801b78:	f800283a 	ret

01801b7c <altera_avalon_jtag_uart_init>:
 * Return 1 on sucessful IRQ register and 0 on failure.
 */

void altera_avalon_jtag_uart_init(altera_avalon_jtag_uart_state* sp, 
                                  int irq_controller_id, int irq)
{
 1801b7c:	defffa04 	addi	sp,sp,-24
 1801b80:	dfc00515 	stw	ra,20(sp)
 1801b84:	df000415 	stw	fp,16(sp)
 1801b88:	df000404 	addi	fp,sp,16
 1801b8c:	e13ffd15 	stw	r4,-12(fp)
 1801b90:	e17ffe15 	stw	r5,-8(fp)
 1801b94:	e1bfff15 	stw	r6,-4(fp)
  ALT_FLAG_CREATE(&sp->events, 0);
  ALT_SEM_CREATE(&sp->read_lock, 1);
  ALT_SEM_CREATE(&sp->write_lock, 1);

  /* enable read interrupts at the device */
  sp->irq_enable = ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 1801b98:	e0fffd17 	ldw	r3,-12(fp)
 1801b9c:	00800044 	movi	r2,1
 1801ba0:	18800815 	stw	r2,32(r3)

  IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable); 
 1801ba4:	e0bffd17 	ldw	r2,-12(fp)
 1801ba8:	10800017 	ldw	r2,0(r2)
 1801bac:	11000104 	addi	r4,r2,4
 1801bb0:	e0bffd17 	ldw	r2,-12(fp)
 1801bb4:	10800817 	ldw	r2,32(r2)
 1801bb8:	1007883a 	mov	r3,r2
 1801bbc:	2005883a 	mov	r2,r4
 1801bc0:	10c00035 	stwio	r3,0(r2)
  
  /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, altera_avalon_jtag_uart_irq, 
 1801bc4:	e13ffe17 	ldw	r4,-8(fp)
 1801bc8:	e17fff17 	ldw	r5,-4(fp)
 1801bcc:	d8000015 	stw	zero,0(sp)
 1801bd0:	01806034 	movhi	r6,384
 1801bd4:	31870f04 	addi	r6,r6,7228
 1801bd8:	e1fffd17 	ldw	r7,-12(fp)
 1801bdc:	1804f440 	call	1804f44 <alt_ic_isr_register>
#else
  alt_irq_register(irq, sp, altera_avalon_jtag_uart_irq);
#endif  

  /* Register an alarm to go off every second to check for presence of host */
  sp->host_inactive = 0;
 1801be0:	e0bffd17 	ldw	r2,-12(fp)
 1801be4:	10000915 	stw	zero,36(r2)

  if (alt_alarm_start(&sp->alarm, alt_ticks_per_second(), 
 1801be8:	e0bffd17 	ldw	r2,-12(fp)
 1801bec:	11000204 	addi	r4,r2,8
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
 1801bf0:	00806074 	movhi	r2,385
 1801bf4:	10b2a404 	addi	r2,r2,-13680
 1801bf8:	10800017 	ldw	r2,0(r2)
 1801bfc:	100b883a 	mov	r5,r2
 1801c00:	01806034 	movhi	r6,384
 1801c04:	31879904 	addi	r6,r6,7780
 1801c08:	e1fffd17 	ldw	r7,-12(fp)
 1801c0c:	1804a500 	call	1804a50 <alt_alarm_start>
 1801c10:	1004403a 	cmpge	r2,r2,zero
 1801c14:	1000041e 	bne	r2,zero,1801c28 <altera_avalon_jtag_uart_init+0xac>
    &altera_avalon_jtag_uart_timeout, sp) < 0)
  {
    /* If we can't set the alarm then record "don't know if host present" 
     * and behave as though the host is present.
     */
    sp->timeout = INT_MAX;
 1801c18:	e0fffd17 	ldw	r3,-12(fp)
 1801c1c:	00a00034 	movhi	r2,32768
 1801c20:	10bfffc4 	addi	r2,r2,-1
 1801c24:	18800115 	stw	r2,4(r3)
  }

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ALARM_REGISTER(sp, sp->base);
}
 1801c28:	e037883a 	mov	sp,fp
 1801c2c:	dfc00117 	ldw	ra,4(sp)
 1801c30:	df000017 	ldw	fp,0(sp)
 1801c34:	dec00204 	addi	sp,sp,8
 1801c38:	f800283a 	ret

01801c3c <altera_avalon_jtag_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_jtag_uart_irq(void* context)
#else
static void altera_avalon_jtag_uart_irq(void* context, alt_u32 id)
#endif
{
 1801c3c:	defff804 	addi	sp,sp,-32
 1801c40:	df000715 	stw	fp,28(sp)
 1801c44:	df000704 	addi	fp,sp,28
 1801c48:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state*) context;
 1801c4c:	e0bfff17 	ldw	r2,-4(fp)
 1801c50:	e0bffe15 	stw	r2,-8(fp)
  unsigned int base = sp->base;
 1801c54:	e0bffe17 	ldw	r2,-8(fp)
 1801c58:	10800017 	ldw	r2,0(r2)
 1801c5c:	e0bffd15 	stw	r2,-12(fp)
 1801c60:	00000006 	br	1801c64 <altera_avalon_jtag_uart_irq+0x28>
  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ISR_FUNCTION(base, sp);

  for ( ; ; )
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 1801c64:	e0bffd17 	ldw	r2,-12(fp)
 1801c68:	10800104 	addi	r2,r2,4
 1801c6c:	10800037 	ldwio	r2,0(r2)
 1801c70:	e0bffc15 	stw	r2,-16(fp)

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
 1801c74:	e0bffc17 	ldw	r2,-16(fp)
 1801c78:	1080c00c 	andi	r2,r2,768
 1801c7c:	1005003a 	cmpeq	r2,r2,zero
 1801c80:	1000741e 	bne	r2,zero,1801e54 <altera_avalon_jtag_uart_irq+0x218>
      break;

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK)
 1801c84:	e0bffc17 	ldw	r2,-16(fp)
 1801c88:	1080400c 	andi	r2,r2,256
 1801c8c:	1005003a 	cmpeq	r2,r2,zero
 1801c90:	1000351e 	bne	r2,zero,1801d68 <altera_avalon_jtag_uart_irq+0x12c>
    {
      /* process a read irq.  Start by assuming that there is data in the
       * receive FIFO (otherwise why would we have been interrupted?)
       */
      unsigned int data = 1 << ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_OFST;
 1801c94:	00800074 	movhi	r2,1
 1801c98:	e0bffb15 	stw	r2,-20(fp)
      for ( ; ; )
      {
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 1801c9c:	e0bffe17 	ldw	r2,-8(fp)
 1801ca0:	10800a17 	ldw	r2,40(r2)
 1801ca4:	10800044 	addi	r2,r2,1
 1801ca8:	1081ffcc 	andi	r2,r2,2047
 1801cac:	e0bffa15 	stw	r2,-24(fp)
        if (next == sp->rx_out)
 1801cb0:	e0bffe17 	ldw	r2,-8(fp)
 1801cb4:	10c00b17 	ldw	r3,44(r2)
 1801cb8:	e0bffa17 	ldw	r2,-24(fp)
 1801cbc:	18801626 	beq	r3,r2,1801d18 <altera_avalon_jtag_uart_irq+0xdc>
          break;

        /* Try to remove a character from the FIFO and find out whether there
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
 1801cc0:	e0bffd17 	ldw	r2,-12(fp)
 1801cc4:	10800037 	ldwio	r2,0(r2)
 1801cc8:	e0bffb15 	stw	r2,-20(fp)
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
 1801ccc:	e0bffb17 	ldw	r2,-20(fp)
 1801cd0:	10a0000c 	andi	r2,r2,32768
 1801cd4:	1005003a 	cmpeq	r2,r2,zero
 1801cd8:	10000f1e 	bne	r2,zero,1801d18 <altera_avalon_jtag_uart_irq+0xdc>
          break;

        sp->rx_buf[sp->rx_in] = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
 1801cdc:	e0bffe17 	ldw	r2,-8(fp)
 1801ce0:	10c00a17 	ldw	r3,40(r2)
 1801ce4:	e0bffb17 	ldw	r2,-20(fp)
 1801ce8:	1009883a 	mov	r4,r2
 1801cec:	e0bffe17 	ldw	r2,-8(fp)
 1801cf0:	1885883a 	add	r2,r3,r2
 1801cf4:	10800e04 	addi	r2,r2,56
 1801cf8:	11000005 	stb	r4,0(r2)
        sp->rx_in = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 1801cfc:	e0bffe17 	ldw	r2,-8(fp)
 1801d00:	10800a17 	ldw	r2,40(r2)
 1801d04:	10800044 	addi	r2,r2,1
 1801d08:	10c1ffcc 	andi	r3,r2,2047
 1801d0c:	e0bffe17 	ldw	r2,-8(fp)
 1801d10:	10c00a15 	stw	r3,40(r2)

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }
 1801d14:	003fe106 	br	1801c9c <altera_avalon_jtag_uart_irq+0x60>

      if (data & ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_MSK)
 1801d18:	e0bffb17 	ldw	r2,-20(fp)
 1801d1c:	10bfffec 	andhi	r2,r2,65535
 1801d20:	1005003a 	cmpeq	r2,r2,zero
 1801d24:	1000101e 	bne	r2,zero,1801d68 <altera_avalon_jtag_uart_irq+0x12c>
      {
        /* If there is still data available here then the buffer is full 
         * so turn off receive interrupts until some space becomes available.
         */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 1801d28:	e0bffe17 	ldw	r2,-8(fp)
 1801d2c:	10c00817 	ldw	r3,32(r2)
 1801d30:	00bfff84 	movi	r2,-2
 1801d34:	1886703a 	and	r3,r3,r2
 1801d38:	e0bffe17 	ldw	r2,-8(fp)
 1801d3c:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(base, sp->irq_enable);
 1801d40:	e0bffd17 	ldw	r2,-12(fp)
 1801d44:	11000104 	addi	r4,r2,4
 1801d48:	e0bffe17 	ldw	r2,-8(fp)
 1801d4c:	10800817 	ldw	r2,32(r2)
 1801d50:	1007883a 	mov	r3,r2
 1801d54:	2005883a 	mov	r2,r4
 1801d58:	10c00035 	stwio	r3,0(r2)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 1801d5c:	e0bffd17 	ldw	r2,-12(fp)
 1801d60:	10800104 	addi	r2,r2,4
 1801d64:	10800037 	ldwio	r2,0(r2)
      }
    }

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
 1801d68:	e0bffc17 	ldw	r2,-16(fp)
 1801d6c:	1080800c 	andi	r2,r2,512
 1801d70:	1005003a 	cmpeq	r2,r2,zero
 1801d74:	103fbb1e 	bne	r2,zero,1801c64 <altera_avalon_jtag_uart_irq+0x28>
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
 1801d78:	e0bffc17 	ldw	r2,-16(fp)
 1801d7c:	10bfffec 	andhi	r2,r2,65535
 1801d80:	1004d43a 	srli	r2,r2,16
 1801d84:	e0bff915 	stw	r2,-28(fp)

      while (space > 0 && sp->tx_out != sp->tx_in)
 1801d88:	00001506 	br	1801de0 <altera_avalon_jtag_uart_irq+0x1a4>
      {
        IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, sp->tx_buf[sp->tx_out]);
 1801d8c:	e13ffd17 	ldw	r4,-12(fp)
 1801d90:	e0bffe17 	ldw	r2,-8(fp)
 1801d94:	10c00d17 	ldw	r3,52(r2)
 1801d98:	e0bffe17 	ldw	r2,-8(fp)
 1801d9c:	1885883a 	add	r2,r3,r2
 1801da0:	10820e04 	addi	r2,r2,2104
 1801da4:	10800003 	ldbu	r2,0(r2)
 1801da8:	10c03fcc 	andi	r3,r2,255
 1801dac:	18c0201c 	xori	r3,r3,128
 1801db0:	18ffe004 	addi	r3,r3,-128
 1801db4:	2005883a 	mov	r2,r4
 1801db8:	10c00035 	stwio	r3,0(r2)

        sp->tx_out = (sp->tx_out + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 1801dbc:	e0bffe17 	ldw	r2,-8(fp)
 1801dc0:	10800d17 	ldw	r2,52(r2)
 1801dc4:	10800044 	addi	r2,r2,1
 1801dc8:	10c1ffcc 	andi	r3,r2,2047
 1801dcc:	e0bffe17 	ldw	r2,-8(fp)
 1801dd0:	10c00d15 	stw	r3,52(r2)

        /* Post an event to notify jtag_uart_write that a character has been written */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
 1801dd4:	e0bff917 	ldw	r2,-28(fp)
 1801dd8:	10bfffc4 	addi	r2,r2,-1
 1801ddc:	e0bff915 	stw	r2,-28(fp)
    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;

      while (space > 0 && sp->tx_out != sp->tx_in)
 1801de0:	e0bff917 	ldw	r2,-28(fp)
 1801de4:	1005003a 	cmpeq	r2,r2,zero
 1801de8:	1000051e 	bne	r2,zero,1801e00 <altera_avalon_jtag_uart_irq+0x1c4>
 1801dec:	e0bffe17 	ldw	r2,-8(fp)
 1801df0:	10c00d17 	ldw	r3,52(r2)
 1801df4:	e0bffe17 	ldw	r2,-8(fp)
 1801df8:	10800c17 	ldw	r2,48(r2)
 1801dfc:	18bfe31e 	bne	r3,r2,1801d8c <altera_avalon_jtag_uart_irq+0x150>
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
      }

      if (space > 0)
 1801e00:	e0bff917 	ldw	r2,-28(fp)
 1801e04:	1005003a 	cmpeq	r2,r2,zero
 1801e08:	103f961e 	bne	r2,zero,1801c64 <altera_avalon_jtag_uart_irq+0x28>
      {
        /* If we don't have any more data available then turn off the TX interrupt */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
 1801e0c:	e0bffe17 	ldw	r2,-8(fp)
 1801e10:	10c00817 	ldw	r3,32(r2)
 1801e14:	00bfff44 	movi	r2,-3
 1801e18:	1886703a 	and	r3,r3,r2
 1801e1c:	e0bffe17 	ldw	r2,-8(fp)
 1801e20:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 1801e24:	e0bffe17 	ldw	r2,-8(fp)
 1801e28:	10800017 	ldw	r2,0(r2)
 1801e2c:	11000104 	addi	r4,r2,4
 1801e30:	e0bffe17 	ldw	r2,-8(fp)
 1801e34:	10800817 	ldw	r2,32(r2)
 1801e38:	1007883a 	mov	r3,r2
 1801e3c:	2005883a 	mov	r2,r4
 1801e40:	10c00035 	stwio	r3,0(r2)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 1801e44:	e0bffd17 	ldw	r2,-12(fp)
 1801e48:	10800104 	addi	r2,r2,4
 1801e4c:	10800037 	ldwio	r2,0(r2)
      }
    }
  }
 1801e50:	003f8406 	br	1801c64 <altera_avalon_jtag_uart_irq+0x28>
}
 1801e54:	e037883a 	mov	sp,fp
 1801e58:	df000017 	ldw	fp,0(sp)
 1801e5c:	dec00104 	addi	sp,sp,4
 1801e60:	f800283a 	ret

01801e64 <altera_avalon_jtag_uart_timeout>:
 * Timeout routine is called every second
 */

static alt_u32 
altera_avalon_jtag_uart_timeout(void* context) 
{
 1801e64:	defffc04 	addi	sp,sp,-16
 1801e68:	df000315 	stw	fp,12(sp)
 1801e6c:	df000304 	addi	fp,sp,12
 1801e70:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state *) context;
 1801e74:	e0bfff17 	ldw	r2,-4(fp)
 1801e78:	e0bffe15 	stw	r2,-8(fp)

  unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base);
 1801e7c:	e0bffe17 	ldw	r2,-8(fp)
 1801e80:	10800017 	ldw	r2,0(r2)
 1801e84:	10800104 	addi	r2,r2,4
 1801e88:	10800037 	ldwio	r2,0(r2)
 1801e8c:	e0bffd15 	stw	r2,-12(fp)

  if (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK)
 1801e90:	e0bffd17 	ldw	r2,-12(fp)
 1801e94:	1081000c 	andi	r2,r2,1024
 1801e98:	1005003a 	cmpeq	r2,r2,zero
 1801e9c:	10000c1e 	bne	r2,zero,1801ed0 <altera_avalon_jtag_uart_timeout+0x6c>
  {
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable | ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK);
 1801ea0:	e0bffe17 	ldw	r2,-8(fp)
 1801ea4:	10800017 	ldw	r2,0(r2)
 1801ea8:	11000104 	addi	r4,r2,4
 1801eac:	e0bffe17 	ldw	r2,-8(fp)
 1801eb0:	10800817 	ldw	r2,32(r2)
 1801eb4:	10810014 	ori	r2,r2,1024
 1801eb8:	1007883a 	mov	r3,r2
 1801ebc:	2005883a 	mov	r2,r4
 1801ec0:	10c00035 	stwio	r3,0(r2)
    sp->host_inactive = 0;
 1801ec4:	e0bffe17 	ldw	r2,-8(fp)
 1801ec8:	10000915 	stw	zero,36(r2)
 1801ecc:	00000a06 	br	1801ef8 <altera_avalon_jtag_uart_timeout+0x94>
  }
  else if (sp->host_inactive < INT_MAX - 2) {
 1801ed0:	e0bffe17 	ldw	r2,-8(fp)
 1801ed4:	10c00917 	ldw	r3,36(r2)
 1801ed8:	00a00034 	movhi	r2,32768
 1801edc:	10bfff04 	addi	r2,r2,-4
 1801ee0:	10c00536 	bltu	r2,r3,1801ef8 <altera_avalon_jtag_uart_timeout+0x94>
    sp->host_inactive++;
 1801ee4:	e0bffe17 	ldw	r2,-8(fp)
 1801ee8:	10800917 	ldw	r2,36(r2)
 1801eec:	10c00044 	addi	r3,r2,1
 1801ef0:	e0bffe17 	ldw	r2,-8(fp)
 1801ef4:	10c00915 	stw	r3,36(r2)
 1801ef8:	00806074 	movhi	r2,385
 1801efc:	10b2a404 	addi	r2,r2,-13680
 1801f00:	10800017 	ldw	r2,0(r2)
      ALT_FLAG_POST (sp->events, ALT_JTAG_UART_TIMEOUT, OS_FLAG_SET);
    }
  }

  return alt_ticks_per_second();
}
 1801f04:	e037883a 	mov	sp,fp
 1801f08:	df000017 	ldw	fp,0(sp)
 1801f0c:	dec00104 	addi	sp,sp,4
 1801f10:	f800283a 	ret

01801f14 <altera_avalon_jtag_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_jtag_uart_close(altera_avalon_jtag_uart_state* sp, int flags)
{
 1801f14:	defffc04 	addi	sp,sp,-16
 1801f18:	df000315 	stw	fp,12(sp)
 1801f1c:	df000304 	addi	fp,sp,12
 1801f20:	e13ffd15 	stw	r4,-12(fp)
 1801f24:	e17ffe15 	stw	r5,-8(fp)
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
 1801f28:	00000706 	br	1801f48 <altera_avalon_jtag_uart_close+0x34>
    if (flags & O_NONBLOCK) {
 1801f2c:	e0bffe17 	ldw	r2,-8(fp)
 1801f30:	1090000c 	andi	r2,r2,16384
 1801f34:	1005003a 	cmpeq	r2,r2,zero
 1801f38:	1000031e 	bne	r2,zero,1801f48 <altera_avalon_jtag_uart_close+0x34>
      return -EWOULDBLOCK; 
 1801f3c:	00bffd44 	movi	r2,-11
 1801f40:	e0bfff15 	stw	r2,-4(fp)
 1801f44:	00000b06 	br	1801f74 <altera_avalon_jtag_uart_close+0x60>
{
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
 1801f48:	e0bffd17 	ldw	r2,-12(fp)
 1801f4c:	10c00d17 	ldw	r3,52(r2)
 1801f50:	e0bffd17 	ldw	r2,-12(fp)
 1801f54:	10800c17 	ldw	r2,48(r2)
 1801f58:	18800526 	beq	r3,r2,1801f70 <altera_avalon_jtag_uart_close+0x5c>
 1801f5c:	e0bffd17 	ldw	r2,-12(fp)
 1801f60:	10c00917 	ldw	r3,36(r2)
 1801f64:	e0bffd17 	ldw	r2,-12(fp)
 1801f68:	10800117 	ldw	r2,4(r2)
 1801f6c:	18bfef36 	bltu	r3,r2,1801f2c <altera_avalon_jtag_uart_close+0x18>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
 1801f70:	e03fff15 	stw	zero,-4(fp)
 1801f74:	e0bfff17 	ldw	r2,-4(fp)
}
 1801f78:	e037883a 	mov	sp,fp
 1801f7c:	df000017 	ldw	fp,0(sp)
 1801f80:	dec00104 	addi	sp,sp,4
 1801f84:	f800283a 	ret

01801f88 <altera_avalon_jtag_uart_ioctl>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_ioctl(altera_avalon_jtag_uart_state* sp, int req,
  void* arg)
{
 1801f88:	defff804 	addi	sp,sp,-32
 1801f8c:	df000715 	stw	fp,28(sp)
 1801f90:	df000704 	addi	fp,sp,28
 1801f94:	e13ffb15 	stw	r4,-20(fp)
 1801f98:	e17ffc15 	stw	r5,-16(fp)
 1801f9c:	e1bffd15 	stw	r6,-12(fp)
  int rc = -ENOTTY;
 1801fa0:	00bff9c4 	movi	r2,-25
 1801fa4:	e0bffa15 	stw	r2,-24(fp)

  switch (req)
 1801fa8:	e0bffc17 	ldw	r2,-16(fp)
 1801fac:	e0bfff15 	stw	r2,-4(fp)
 1801fb0:	e0ffff17 	ldw	r3,-4(fp)
 1801fb4:	189a8060 	cmpeqi	r2,r3,27137
 1801fb8:	1000041e 	bne	r2,zero,1801fcc <altera_avalon_jtag_uart_ioctl+0x44>
 1801fbc:	e0ffff17 	ldw	r3,-4(fp)
 1801fc0:	189a80a0 	cmpeqi	r2,r3,27138
 1801fc4:	10001b1e 	bne	r2,zero,1802034 <altera_avalon_jtag_uart_ioctl+0xac>
 1801fc8:	00002706 	br	1802068 <altera_avalon_jtag_uart_ioctl+0xe0>
  {
  case TIOCSTIMEOUT:
    /* Set the time to wait until assuming host is not connected */
    if (sp->timeout != INT_MAX)
 1801fcc:	e0bffb17 	ldw	r2,-20(fp)
 1801fd0:	10c00117 	ldw	r3,4(r2)
 1801fd4:	00a00034 	movhi	r2,32768
 1801fd8:	10bfffc4 	addi	r2,r2,-1
 1801fdc:	18802226 	beq	r3,r2,1802068 <altera_avalon_jtag_uart_ioctl+0xe0>
    {
      int timeout = *((int *)arg);
 1801fe0:	e0bffd17 	ldw	r2,-12(fp)
 1801fe4:	10800017 	ldw	r2,0(r2)
 1801fe8:	e0bff915 	stw	r2,-28(fp)
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
 1801fec:	e0bff917 	ldw	r2,-28(fp)
 1801ff0:	10800090 	cmplti	r2,r2,2
 1801ff4:	1000071e 	bne	r2,zero,1802014 <altera_avalon_jtag_uart_ioctl+0x8c>
 1801ff8:	e0fff917 	ldw	r3,-28(fp)
 1801ffc:	00a00034 	movhi	r2,32768
 1802000:	10bfffc4 	addi	r2,r2,-1
 1802004:	18800326 	beq	r3,r2,1802014 <altera_avalon_jtag_uart_ioctl+0x8c>
 1802008:	e0bff917 	ldw	r2,-28(fp)
 180200c:	e0bffe15 	stw	r2,-8(fp)
 1802010:	00000306 	br	1802020 <altera_avalon_jtag_uart_ioctl+0x98>
 1802014:	00e00034 	movhi	r3,32768
 1802018:	18ffff84 	addi	r3,r3,-2
 180201c:	e0fffe15 	stw	r3,-8(fp)
 1802020:	e0bffb17 	ldw	r2,-20(fp)
 1802024:	e0fffe17 	ldw	r3,-8(fp)
 1802028:	10c00115 	stw	r3,4(r2)
      rc = 0;
 180202c:	e03ffa15 	stw	zero,-24(fp)
    }
    break;
 1802030:	00000d06 	br	1802068 <altera_avalon_jtag_uart_ioctl+0xe0>

  case TIOCGCONNECTED:
    /* Find out whether host is connected */
    if (sp->timeout != INT_MAX)
 1802034:	e0bffb17 	ldw	r2,-20(fp)
 1802038:	10c00117 	ldw	r3,4(r2)
 180203c:	00a00034 	movhi	r2,32768
 1802040:	10bfffc4 	addi	r2,r2,-1
 1802044:	18800826 	beq	r3,r2,1802068 <altera_avalon_jtag_uart_ioctl+0xe0>
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
 1802048:	e13ffd17 	ldw	r4,-12(fp)
 180204c:	e0bffb17 	ldw	r2,-20(fp)
 1802050:	10c00917 	ldw	r3,36(r2)
 1802054:	e0bffb17 	ldw	r2,-20(fp)
 1802058:	10800117 	ldw	r2,4(r2)
 180205c:	1885803a 	cmpltu	r2,r3,r2
 1802060:	20800015 	stw	r2,0(r4)
      rc = 0;
 1802064:	e03ffa15 	stw	zero,-24(fp)

  default:
    break;
  }

  return rc;
 1802068:	e0bffa17 	ldw	r2,-24(fp)
}
 180206c:	e037883a 	mov	sp,fp
 1802070:	df000017 	ldw	fp,0(sp)
 1802074:	dec00104 	addi	sp,sp,4
 1802078:	f800283a 	ret

0180207c <altera_avalon_jtag_uart_read>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_read(altera_avalon_jtag_uart_state* sp, 
  char * buffer, int space, int flags)
{
 180207c:	defff204 	addi	sp,sp,-56
 1802080:	dfc00d15 	stw	ra,52(sp)
 1802084:	df000c15 	stw	fp,48(sp)
 1802088:	df000c04 	addi	fp,sp,48
 180208c:	e13ffb15 	stw	r4,-20(fp)
 1802090:	e17ffc15 	stw	r5,-16(fp)
 1802094:	e1bffd15 	stw	r6,-12(fp)
 1802098:	e1fffe15 	stw	r7,-8(fp)
  char * ptr = buffer;
 180209c:	e0bffc17 	ldw	r2,-16(fp)
 18020a0:	e0bffa15 	stw	r2,-24(fp)
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
 18020a4:	00004806 	br	18021c8 <altera_avalon_jtag_uart_read+0x14c>
    unsigned int in, out;

    /* Read as much data as possible */
    do
    {
      in  = sp->rx_in;
 18020a8:	e0bffb17 	ldw	r2,-20(fp)
 18020ac:	10800a17 	ldw	r2,40(r2)
 18020b0:	e0bff715 	stw	r2,-36(fp)
      out = sp->rx_out;
 18020b4:	e0bffb17 	ldw	r2,-20(fp)
 18020b8:	10800b17 	ldw	r2,44(r2)
 18020bc:	e0bff615 	stw	r2,-40(fp)

      if (in >= out)
 18020c0:	e0fff717 	ldw	r3,-36(fp)
 18020c4:	e0bff617 	ldw	r2,-40(fp)
 18020c8:	18800536 	bltu	r3,r2,18020e0 <altera_avalon_jtag_uart_read+0x64>
        n = in - out;
 18020cc:	e0bff717 	ldw	r2,-36(fp)
 18020d0:	e0fff617 	ldw	r3,-40(fp)
 18020d4:	10c5c83a 	sub	r2,r2,r3
 18020d8:	e0bff815 	stw	r2,-32(fp)
 18020dc:	00000406 	br	18020f0 <altera_avalon_jtag_uart_read+0x74>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;
 18020e0:	00820004 	movi	r2,2048
 18020e4:	e0fff617 	ldw	r3,-40(fp)
 18020e8:	10c5c83a 	sub	r2,r2,r3
 18020ec:	e0bff815 	stw	r2,-32(fp)

      if (n == 0)
 18020f0:	e0bff817 	ldw	r2,-32(fp)
 18020f4:	1005003a 	cmpeq	r2,r2,zero
 18020f8:	10001f1e 	bne	r2,zero,1802178 <altera_avalon_jtag_uart_read+0xfc>
        break; /* No more data available */

      if (n > space)
 18020fc:	e0fffd17 	ldw	r3,-12(fp)
 1802100:	e0bff817 	ldw	r2,-32(fp)
 1802104:	1880022e 	bgeu	r3,r2,1802110 <altera_avalon_jtag_uart_read+0x94>
        n = space;
 1802108:	e0bffd17 	ldw	r2,-12(fp)
 180210c:	e0bff815 	stw	r2,-32(fp)

      memcpy(ptr, sp->rx_buf + out, n);
 1802110:	e0bffb17 	ldw	r2,-20(fp)
 1802114:	10c00e04 	addi	r3,r2,56
 1802118:	e0bff617 	ldw	r2,-40(fp)
 180211c:	1887883a 	add	r3,r3,r2
 1802120:	e0bffa17 	ldw	r2,-24(fp)
 1802124:	1009883a 	mov	r4,r2
 1802128:	180b883a 	mov	r5,r3
 180212c:	e1bff817 	ldw	r6,-32(fp)
 1802130:	18069680 	call	1806968 <memcpy>
      ptr   += n;
 1802134:	e0fff817 	ldw	r3,-32(fp)
 1802138:	e0bffa17 	ldw	r2,-24(fp)
 180213c:	10c5883a 	add	r2,r2,r3
 1802140:	e0bffa15 	stw	r2,-24(fp)
      space -= n;
 1802144:	e0fffd17 	ldw	r3,-12(fp)
 1802148:	e0bff817 	ldw	r2,-32(fp)
 180214c:	1885c83a 	sub	r2,r3,r2
 1802150:	e0bffd15 	stw	r2,-12(fp)

      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 1802154:	e0fff617 	ldw	r3,-40(fp)
 1802158:	e0bff817 	ldw	r2,-32(fp)
 180215c:	1885883a 	add	r2,r3,r2
 1802160:	10c1ffcc 	andi	r3,r2,2047
 1802164:	e0bffb17 	ldw	r2,-20(fp)
 1802168:	10c00b15 	stw	r3,44(r2)
    }
    while (space > 0);
 180216c:	e0bffd17 	ldw	r2,-12(fp)
 1802170:	10800048 	cmpgei	r2,r2,1
 1802174:	103fcc1e 	bne	r2,zero,18020a8 <altera_avalon_jtag_uart_read+0x2c>

    /* If we read any data then return it */
    if (ptr != buffer)
 1802178:	e0fffa17 	ldw	r3,-24(fp)
 180217c:	e0bffc17 	ldw	r2,-16(fp)
 1802180:	1880141e 	bne	r3,r2,18021d4 <altera_avalon_jtag_uart_read+0x158>
      break;

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
 1802184:	e0bffe17 	ldw	r2,-8(fp)
 1802188:	1090000c 	andi	r2,r2,16384
 180218c:	1004c03a 	cmpne	r2,r2,zero
 1802190:	1000101e 	bne	r2,zero,18021d4 <altera_avalon_jtag_uart_read+0x158>
      while (in == sp->rx_in && sp->host_inactive < sp->timeout)
        ;
    }
#else
    /* No OS: Always spin */
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
 1802194:	e0bffb17 	ldw	r2,-20(fp)
 1802198:	10c00a17 	ldw	r3,40(r2)
 180219c:	e0bff717 	ldw	r2,-36(fp)
 18021a0:	1880051e 	bne	r3,r2,18021b8 <altera_avalon_jtag_uart_read+0x13c>
 18021a4:	e0bffb17 	ldw	r2,-20(fp)
 18021a8:	10c00917 	ldw	r3,36(r2)
 18021ac:	e0bffb17 	ldw	r2,-20(fp)
 18021b0:	10800117 	ldw	r2,4(r2)
 18021b4:	18bff736 	bltu	r3,r2,1802194 <altera_avalon_jtag_uart_read+0x118>
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
 18021b8:	e0bffb17 	ldw	r2,-20(fp)
 18021bc:	10c00a17 	ldw	r3,40(r2)
 18021c0:	e0bff717 	ldw	r2,-36(fp)
 18021c4:	18800326 	beq	r3,r2,18021d4 <altera_avalon_jtag_uart_read+0x158>
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
 18021c8:	e0bffd17 	ldw	r2,-12(fp)
 18021cc:	10800048 	cmpgei	r2,r2,1
 18021d0:	103fb51e 	bne	r2,zero,18020a8 <altera_avalon_jtag_uart_read+0x2c>
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);

  if (ptr != buffer)
 18021d4:	e0fffa17 	ldw	r3,-24(fp)
 18021d8:	e0bffc17 	ldw	r2,-16(fp)
 18021dc:	18801926 	beq	r3,r2,1802244 <altera_avalon_jtag_uart_read+0x1c8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 18021e0:	0005303a 	rdctl	r2,status
 18021e4:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 18021e8:	e0fff517 	ldw	r3,-44(fp)
 18021ec:	00bfff84 	movi	r2,-2
 18021f0:	1884703a 	and	r2,r3,r2
 18021f4:	1001703a 	wrctl	status,r2
  
  return context;
 18021f8:	e0bff517 	ldw	r2,-44(fp)
  {
    /* If we read any data then there is space in the buffer so enable interrupts */
    context = alt_irq_disable_all();
 18021fc:	e0bff915 	stw	r2,-28(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 1802200:	e0bffb17 	ldw	r2,-20(fp)
 1802204:	10800817 	ldw	r2,32(r2)
 1802208:	10c00054 	ori	r3,r2,1
 180220c:	e0bffb17 	ldw	r2,-20(fp)
 1802210:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 1802214:	e0bffb17 	ldw	r2,-20(fp)
 1802218:	10800017 	ldw	r2,0(r2)
 180221c:	11000104 	addi	r4,r2,4
 1802220:	e0bffb17 	ldw	r2,-20(fp)
 1802224:	10800817 	ldw	r2,32(r2)
 1802228:	1007883a 	mov	r3,r2
 180222c:	2005883a 	mov	r2,r4
 1802230:	10c00035 	stwio	r3,0(r2)
 1802234:	e0bff917 	ldw	r2,-28(fp)
 1802238:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 180223c:	e0bff417 	ldw	r2,-48(fp)
 1802240:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
  }

  if (ptr != buffer)
 1802244:	e0fffa17 	ldw	r3,-24(fp)
 1802248:	e0bffc17 	ldw	r2,-16(fp)
 180224c:	18800526 	beq	r3,r2,1802264 <altera_avalon_jtag_uart_read+0x1e8>
    return ptr - buffer;
 1802250:	e0fffa17 	ldw	r3,-24(fp)
 1802254:	e0bffc17 	ldw	r2,-16(fp)
 1802258:	1887c83a 	sub	r3,r3,r2
 180225c:	e0ffff15 	stw	r3,-4(fp)
 1802260:	00000906 	br	1802288 <altera_avalon_jtag_uart_read+0x20c>
  else if (flags & O_NONBLOCK)
 1802264:	e0bffe17 	ldw	r2,-8(fp)
 1802268:	1090000c 	andi	r2,r2,16384
 180226c:	1005003a 	cmpeq	r2,r2,zero
 1802270:	1000031e 	bne	r2,zero,1802280 <altera_avalon_jtag_uart_read+0x204>
    return -EWOULDBLOCK;
 1802274:	00bffd44 	movi	r2,-11
 1802278:	e0bfff15 	stw	r2,-4(fp)
 180227c:	00000206 	br	1802288 <altera_avalon_jtag_uart_read+0x20c>
  else
    return -EIO;
 1802280:	00bffec4 	movi	r2,-5
 1802284:	e0bfff15 	stw	r2,-4(fp)
 1802288:	e0bfff17 	ldw	r2,-4(fp)
}
 180228c:	e037883a 	mov	sp,fp
 1802290:	dfc00117 	ldw	ra,4(sp)
 1802294:	df000017 	ldw	fp,0(sp)
 1802298:	dec00204 	addi	sp,sp,8
 180229c:	f800283a 	ret

018022a0 <altera_avalon_jtag_uart_write>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
 18022a0:	defff204 	addi	sp,sp,-56
 18022a4:	dfc00d15 	stw	ra,52(sp)
 18022a8:	df000c15 	stw	fp,48(sp)
 18022ac:	df000c04 	addi	fp,sp,48
 18022b0:	e13ffb15 	stw	r4,-20(fp)
 18022b4:	e17ffc15 	stw	r5,-16(fp)
 18022b8:	e1bffd15 	stw	r6,-12(fp)
 18022bc:	e1fffe15 	stw	r7,-8(fp)
  /* Remove warning at optimisation level 03 by seting out to 0 */
  unsigned int in, out=0;
 18022c0:	e03ff915 	stw	zero,-28(fp)
  unsigned int n;
  alt_irq_context context;

  const char * start = ptr;
 18022c4:	e0bffc17 	ldw	r2,-16(fp)
 18022c8:	e0bff615 	stw	r2,-40(fp)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
 18022cc:	00003a06 	br	18023b8 <altera_avalon_jtag_uart_write+0x118>
    {
      /* We need a stable value of the out pointer to calculate the space available */
      in  = sp->tx_in;
 18022d0:	e0bffb17 	ldw	r2,-20(fp)
 18022d4:	10800c17 	ldw	r2,48(r2)
 18022d8:	e0bffa15 	stw	r2,-24(fp)
      out = sp->tx_out;
 18022dc:	e0bffb17 	ldw	r2,-20(fp)
 18022e0:	10800d17 	ldw	r2,52(r2)
 18022e4:	e0bff915 	stw	r2,-28(fp)

      if (in < out)
 18022e8:	e0fffa17 	ldw	r3,-24(fp)
 18022ec:	e0bff917 	ldw	r2,-28(fp)
 18022f0:	1880062e 	bgeu	r3,r2,180230c <altera_avalon_jtag_uart_write+0x6c>
        n = out - 1 - in;
 18022f4:	e0fff917 	ldw	r3,-28(fp)
 18022f8:	e0bffa17 	ldw	r2,-24(fp)
 18022fc:	1885c83a 	sub	r2,r3,r2
 1802300:	10bfffc4 	addi	r2,r2,-1
 1802304:	e0bff815 	stw	r2,-32(fp)
 1802308:	00000c06 	br	180233c <altera_avalon_jtag_uart_write+0x9c>
      else if (out > 0)
 180230c:	e0bff917 	ldw	r2,-28(fp)
 1802310:	1005003a 	cmpeq	r2,r2,zero
 1802314:	1000051e 	bne	r2,zero,180232c <altera_avalon_jtag_uart_write+0x8c>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
 1802318:	00820004 	movi	r2,2048
 180231c:	e0fffa17 	ldw	r3,-24(fp)
 1802320:	10c5c83a 	sub	r2,r2,r3
 1802324:	e0bff815 	stw	r2,-32(fp)
 1802328:	00000406 	br	180233c <altera_avalon_jtag_uart_write+0x9c>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;
 180232c:	0081ffc4 	movi	r2,2047
 1802330:	e0fffa17 	ldw	r3,-24(fp)
 1802334:	10c5c83a 	sub	r2,r2,r3
 1802338:	e0bff815 	stw	r2,-32(fp)

      if (n == 0)
 180233c:	e0bff817 	ldw	r2,-32(fp)
 1802340:	1005003a 	cmpeq	r2,r2,zero
 1802344:	10001f1e 	bne	r2,zero,18023c4 <altera_avalon_jtag_uart_write+0x124>
        break;

      if (n > count)
 1802348:	e0fffd17 	ldw	r3,-12(fp)
 180234c:	e0bff817 	ldw	r2,-32(fp)
 1802350:	1880022e 	bgeu	r3,r2,180235c <altera_avalon_jtag_uart_write+0xbc>
        n = count;
 1802354:	e0bffd17 	ldw	r2,-12(fp)
 1802358:	e0bff815 	stw	r2,-32(fp)

      memcpy(sp->tx_buf + in, ptr, n);
 180235c:	e0bffb17 	ldw	r2,-20(fp)
 1802360:	10c20e04 	addi	r3,r2,2104
 1802364:	e0bffa17 	ldw	r2,-24(fp)
 1802368:	1885883a 	add	r2,r3,r2
 180236c:	e0fffc17 	ldw	r3,-16(fp)
 1802370:	1009883a 	mov	r4,r2
 1802374:	180b883a 	mov	r5,r3
 1802378:	e1bff817 	ldw	r6,-32(fp)
 180237c:	18069680 	call	1806968 <memcpy>
      ptr   += n;
 1802380:	e0fff817 	ldw	r3,-32(fp)
 1802384:	e0bffc17 	ldw	r2,-16(fp)
 1802388:	10c5883a 	add	r2,r2,r3
 180238c:	e0bffc15 	stw	r2,-16(fp)
      count -= n;
 1802390:	e0fffd17 	ldw	r3,-12(fp)
 1802394:	e0bff817 	ldw	r2,-32(fp)
 1802398:	1885c83a 	sub	r2,r3,r2
 180239c:	e0bffd15 	stw	r2,-12(fp)

      sp->tx_in = (in + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 18023a0:	e0fffa17 	ldw	r3,-24(fp)
 18023a4:	e0bff817 	ldw	r2,-32(fp)
 18023a8:	1885883a 	add	r2,r3,r2
 18023ac:	10c1ffcc 	andi	r3,r2,2047
 18023b0:	e0bffb17 	ldw	r2,-20(fp)
 18023b4:	10c00c15 	stw	r3,48(r2)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
 18023b8:	e0bffd17 	ldw	r2,-12(fp)
 18023bc:	10800048 	cmpgei	r2,r2,1
 18023c0:	103fc31e 	bne	r2,zero,18022d0 <altera_avalon_jtag_uart_write+0x30>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 18023c4:	0005303a 	rdctl	r2,status
 18023c8:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 18023cc:	e0fff517 	ldw	r3,-44(fp)
 18023d0:	00bfff84 	movi	r2,-2
 18023d4:	1884703a 	and	r2,r3,r2
 18023d8:	1001703a 	wrctl	status,r2
  
  return context;
 18023dc:	e0bff517 	ldw	r2,-44(fp)
     * to enable interrupts if there is no space left in the FIFO
     *
     * For now kick the interrupt routine every time to make it transmit 
     * the data 
     */
    context = alt_irq_disable_all();
 18023e0:	e0bff715 	stw	r2,-36(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
 18023e4:	e0bffb17 	ldw	r2,-20(fp)
 18023e8:	10800817 	ldw	r2,32(r2)
 18023ec:	10c00094 	ori	r3,r2,2
 18023f0:	e0bffb17 	ldw	r2,-20(fp)
 18023f4:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 18023f8:	e0bffb17 	ldw	r2,-20(fp)
 18023fc:	10800017 	ldw	r2,0(r2)
 1802400:	11000104 	addi	r4,r2,4
 1802404:	e0bffb17 	ldw	r2,-20(fp)
 1802408:	10800817 	ldw	r2,32(r2)
 180240c:	1007883a 	mov	r3,r2
 1802410:	2005883a 	mov	r2,r4
 1802414:	10c00035 	stwio	r3,0(r2)
 1802418:	e0bff717 	ldw	r2,-36(fp)
 180241c:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 1802420:	e0bff417 	ldw	r2,-48(fp)
 1802424:	1001703a 	wrctl	status,r2
    /* 
     * If there is any data left then either return now or block until 
     * some has been sent 
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
 1802428:	e0bffd17 	ldw	r2,-12(fp)
 180242c:	10800050 	cmplti	r2,r2,1
 1802430:	1000111e 	bne	r2,zero,1802478 <altera_avalon_jtag_uart_write+0x1d8>
    {
      if (flags & O_NONBLOCK)
 1802434:	e0bffe17 	ldw	r2,-8(fp)
 1802438:	1090000c 	andi	r2,r2,16384
 180243c:	1004c03a 	cmpne	r2,r2,zero
 1802440:	1000101e 	bne	r2,zero,1802484 <altera_avalon_jtag_uart_write+0x1e4>
      /*
       * No OS present: Always wait for data to be removed from buffer.  Once
       * the interrupt routine has removed some data then we will be able to
       * insert some more.
       */
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
 1802444:	e0bffb17 	ldw	r2,-20(fp)
 1802448:	10c00d17 	ldw	r3,52(r2)
 180244c:	e0bff917 	ldw	r2,-28(fp)
 1802450:	1880051e 	bne	r3,r2,1802468 <altera_avalon_jtag_uart_write+0x1c8>
 1802454:	e0bffb17 	ldw	r2,-20(fp)
 1802458:	10c00917 	ldw	r3,36(r2)
 180245c:	e0bffb17 	ldw	r2,-20(fp)
 1802460:	10800117 	ldw	r2,4(r2)
 1802464:	18bff736 	bltu	r3,r2,1802444 <altera_avalon_jtag_uart_write+0x1a4>
        ;
#endif /* __ucosii__ */

      if (out == sp->tx_out)
 1802468:	e0bffb17 	ldw	r2,-20(fp)
 180246c:	10c00d17 	ldw	r3,52(r2)
 1802470:	e0bff917 	ldw	r2,-28(fp)
 1802474:	18800326 	beq	r3,r2,1802484 <altera_avalon_jtag_uart_write+0x1e4>
        break;
    }
  }
  while (count > 0);
 1802478:	e0bffd17 	ldw	r2,-12(fp)
 180247c:	10800048 	cmpgei	r2,r2,1
 1802480:	103fcd1e 	bne	r2,zero,18023b8 <altera_avalon_jtag_uart_write+0x118>
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */
  ALT_SEM_POST (sp->write_lock);

  if (ptr != start)
 1802484:	e0fffc17 	ldw	r3,-16(fp)
 1802488:	e0bff617 	ldw	r2,-40(fp)
 180248c:	18800526 	beq	r3,r2,18024a4 <altera_avalon_jtag_uart_write+0x204>
    return ptr - start;
 1802490:	e0fffc17 	ldw	r3,-16(fp)
 1802494:	e0bff617 	ldw	r2,-40(fp)
 1802498:	1887c83a 	sub	r3,r3,r2
 180249c:	e0ffff15 	stw	r3,-4(fp)
 18024a0:	00000906 	br	18024c8 <altera_avalon_jtag_uart_write+0x228>
  else if (flags & O_NONBLOCK)
 18024a4:	e0bffe17 	ldw	r2,-8(fp)
 18024a8:	1090000c 	andi	r2,r2,16384
 18024ac:	1005003a 	cmpeq	r2,r2,zero
 18024b0:	1000031e 	bne	r2,zero,18024c0 <altera_avalon_jtag_uart_write+0x220>
    return -EWOULDBLOCK;
 18024b4:	00bffd44 	movi	r2,-11
 18024b8:	e0bfff15 	stw	r2,-4(fp)
 18024bc:	00000206 	br	18024c8 <altera_avalon_jtag_uart_write+0x228>
  else
    return -EIO; /* Host not connected */
 18024c0:	00bffec4 	movi	r2,-5
 18024c4:	e0bfff15 	stw	r2,-4(fp)
 18024c8:	e0bfff17 	ldw	r2,-4(fp)
}
 18024cc:	e037883a 	mov	sp,fp
 18024d0:	dfc00117 	ldw	ra,4(sp)
 18024d4:	df000017 	ldw	fp,0(sp)
 18024d8:	dec00204 	addi	sp,sp,8
 18024dc:	f800283a 	ret

018024e0 <alt_avalon_timer_sc_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_timer_sc_irq (void* base)
#else
static void alt_avalon_timer_sc_irq (void* base, alt_u32 id)
#endif
{
 18024e0:	defffa04 	addi	sp,sp,-24
 18024e4:	dfc00515 	stw	ra,20(sp)
 18024e8:	df000415 	stw	fp,16(sp)
 18024ec:	df000404 	addi	fp,sp,16
 18024f0:	e13fff15 	stw	r4,-4(fp)
  alt_irq_context cpu_sr;
  
  /* clear the interrupt */
  IOWR_ALTERA_AVALON_TIMER_STATUS (base, 0);
 18024f4:	e0bfff17 	ldw	r2,-4(fp)
 18024f8:	10000035 	stwio	zero,0(r2)
  /* 
   * Dummy read to ensure IRQ is negated before the ISR returns.
   * The control register is read because reading the status
   * register has side-effects per the register map documentation.
   */
  IORD_ALTERA_AVALON_TIMER_CONTROL (base);
 18024fc:	e0bfff17 	ldw	r2,-4(fp)
 1802500:	10800104 	addi	r2,r2,4
 1802504:	10800037 	ldwio	r2,0(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 1802508:	0005303a 	rdctl	r2,status
 180250c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 1802510:	e0fffd17 	ldw	r3,-12(fp)
 1802514:	00bfff84 	movi	r2,-2
 1802518:	1884703a 	and	r2,r3,r2
 180251c:	1001703a 	wrctl	status,r2
  
  return context;
 1802520:	e0bffd17 	ldw	r2,-12(fp)

  /* 
   * Notify the system of a clock tick. disable interrupts 
   * during this time to safely support ISR preemption
   */
  cpu_sr = alt_irq_disable_all();
 1802524:	e0bffe15 	stw	r2,-8(fp)
  alt_tick ();
 1802528:	18057540 	call	1805754 <alt_tick>
 180252c:	e0bffe17 	ldw	r2,-8(fp)
 1802530:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 1802534:	e0bffc17 	ldw	r2,-16(fp)
 1802538:	1001703a 	wrctl	status,r2
  alt_irq_enable_all(cpu_sr);
}
 180253c:	e037883a 	mov	sp,fp
 1802540:	dfc00117 	ldw	ra,4(sp)
 1802544:	df000017 	ldw	fp,0(sp)
 1802548:	dec00204 	addi	sp,sp,8
 180254c:	f800283a 	ret

01802550 <alt_avalon_timer_sc_init>:
 * auto-generated alt_sys_init() function.
 */

void alt_avalon_timer_sc_init (void* base, alt_u32 irq_controller_id, 
                                alt_u32 irq, alt_u32 freq)
{
 1802550:	defff804 	addi	sp,sp,-32
 1802554:	dfc00715 	stw	ra,28(sp)
 1802558:	df000615 	stw	fp,24(sp)
 180255c:	df000604 	addi	fp,sp,24
 1802560:	e13ffc15 	stw	r4,-16(fp)
 1802564:	e17ffd15 	stw	r5,-12(fp)
 1802568:	e1bffe15 	stw	r6,-8(fp)
 180256c:	e1ffff15 	stw	r7,-4(fp)
 1802570:	e0bfff17 	ldw	r2,-4(fp)
 1802574:	e0bffb15 	stw	r2,-20(fp)
 * in order to initialise the value of the clock frequency.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sysclk_init (alt_u32 nticks)
{
  if (! _alt_tick_rate)
 1802578:	00806074 	movhi	r2,385
 180257c:	10b2a404 	addi	r2,r2,-13680
 1802580:	10800017 	ldw	r2,0(r2)
 1802584:	1004c03a 	cmpne	r2,r2,zero
 1802588:	1000041e 	bne	r2,zero,180259c <alt_avalon_timer_sc_init+0x4c>
  {
    _alt_tick_rate = nticks;
 180258c:	00c06074 	movhi	r3,385
 1802590:	18f2a404 	addi	r3,r3,-13680
 1802594:	e0bffb17 	ldw	r2,-20(fp)
 1802598:	18800015 	stw	r2,0(r3)
  
  alt_sysclk_init (freq);
  
  /* set to free running mode */
  
  IOWR_ALTERA_AVALON_TIMER_CONTROL (base, 
 180259c:	e0bffc17 	ldw	r2,-16(fp)
 18025a0:	10800104 	addi	r2,r2,4
 18025a4:	1007883a 	mov	r3,r2
 18025a8:	008001c4 	movi	r2,7
 18025ac:	18800035 	stwio	r2,0(r3)
            ALTERA_AVALON_TIMER_CONTROL_CONT_MSK |
            ALTERA_AVALON_TIMER_CONTROL_START_MSK);

  /* register the interrupt handler, and enable the interrupt */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, alt_avalon_timer_sc_irq, 
 18025b0:	d8000015 	stw	zero,0(sp)
 18025b4:	e13ffd17 	ldw	r4,-12(fp)
 18025b8:	e17ffe17 	ldw	r5,-8(fp)
 18025bc:	01806034 	movhi	r6,384
 18025c0:	31893804 	addi	r6,r6,9440
 18025c4:	e1fffc17 	ldw	r7,-16(fp)
 18025c8:	1804f440 	call	1804f44 <alt_ic_isr_register>
                      base, NULL);
#else
  alt_irq_register (irq, base, alt_avalon_timer_sc_irq);
#endif  
}
 18025cc:	e037883a 	mov	sp,fp
 18025d0:	dfc00117 	ldw	ra,4(sp)
 18025d4:	df000017 	ldw	fp,0(sp)
 18025d8:	dec00204 	addi	sp,sp,8
 18025dc:	f800283a 	ret

018025e0 <altera_avalon_uart_read_fd>:
 *
 */

int 
altera_avalon_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
 18025e0:	defffa04 	addi	sp,sp,-24
 18025e4:	dfc00515 	stw	ra,20(sp)
 18025e8:	df000415 	stw	fp,16(sp)
 18025ec:	df000404 	addi	fp,sp,16
 18025f0:	e13ffd15 	stw	r4,-12(fp)
 18025f4:	e17ffe15 	stw	r5,-8(fp)
 18025f8:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
 18025fc:	e0bffd17 	ldw	r2,-12(fp)
 1802600:	10800017 	ldw	r2,0(r2)
 1802604:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_uart_read(&dev->state, buffer, space,
 1802608:	e0bffc17 	ldw	r2,-16(fp)
 180260c:	11000a04 	addi	r4,r2,40
 1802610:	e0bffd17 	ldw	r2,-12(fp)
 1802614:	11c00217 	ldw	r7,8(r2)
 1802618:	e17ffe17 	ldw	r5,-8(fp)
 180261c:	e1bfff17 	ldw	r6,-4(fp)
 1802620:	1802ad80 	call	1802ad8 <altera_avalon_uart_read>
      fd->fd_flags);
}
 1802624:	e037883a 	mov	sp,fp
 1802628:	dfc00117 	ldw	ra,4(sp)
 180262c:	df000017 	ldw	fp,0(sp)
 1802630:	dec00204 	addi	sp,sp,8
 1802634:	f800283a 	ret

01802638 <altera_avalon_uart_write_fd>:

int 
altera_avalon_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
 1802638:	defffa04 	addi	sp,sp,-24
 180263c:	dfc00515 	stw	ra,20(sp)
 1802640:	df000415 	stw	fp,16(sp)
 1802644:	df000404 	addi	fp,sp,16
 1802648:	e13ffd15 	stw	r4,-12(fp)
 180264c:	e17ffe15 	stw	r5,-8(fp)
 1802650:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
 1802654:	e0bffd17 	ldw	r2,-12(fp)
 1802658:	10800017 	ldw	r2,0(r2)
 180265c:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_uart_write(&dev->state, buffer, space,
 1802660:	e0bffc17 	ldw	r2,-16(fp)
 1802664:	11000a04 	addi	r4,r2,40
 1802668:	e0bffd17 	ldw	r2,-12(fp)
 180266c:	11c00217 	ldw	r7,8(r2)
 1802670:	e17ffe17 	ldw	r5,-8(fp)
 1802674:	e1bfff17 	ldw	r6,-4(fp)
 1802678:	1802d680 	call	1802d68 <altera_avalon_uart_write>
      fd->fd_flags);
}
 180267c:	e037883a 	mov	sp,fp
 1802680:	dfc00117 	ldw	ra,4(sp)
 1802684:	df000017 	ldw	fp,0(sp)
 1802688:	dec00204 	addi	sp,sp,8
 180268c:	f800283a 	ret

01802690 <altera_avalon_uart_close_fd>:

#endif /* ALTERA_AVALON_UART_USE_IOCTL */

int 
altera_avalon_uart_close_fd(alt_fd* fd)
{
 1802690:	defffc04 	addi	sp,sp,-16
 1802694:	dfc00315 	stw	ra,12(sp)
 1802698:	df000215 	stw	fp,8(sp)
 180269c:	df000204 	addi	fp,sp,8
 18026a0:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
 18026a4:	e0bfff17 	ldw	r2,-4(fp)
 18026a8:	10800017 	ldw	r2,0(r2)
 18026ac:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_uart_close(&dev->state, fd->fd_flags);
 18026b0:	e0bffe17 	ldw	r2,-8(fp)
 18026b4:	11000a04 	addi	r4,r2,40
 18026b8:	e0bfff17 	ldw	r2,-4(fp)
 18026bc:	11400217 	ldw	r5,8(r2)
 18026c0:	1802a780 	call	1802a78 <altera_avalon_uart_close>
}
 18026c4:	e037883a 	mov	sp,fp
 18026c8:	dfc00117 	ldw	ra,4(sp)
 18026cc:	df000017 	ldw	fp,0(sp)
 18026d0:	dec00204 	addi	sp,sp,8
 18026d4:	f800283a 	ret

018026d8 <altera_avalon_uart_init>:
  alt_u32 status);

void 
altera_avalon_uart_init(altera_avalon_uart_state* sp, 
  alt_u32 irq_controller_id,  alt_u32 irq)
{
 18026d8:	defff704 	addi	sp,sp,-36
 18026dc:	dfc00815 	stw	ra,32(sp)
 18026e0:	df000715 	stw	fp,28(sp)
 18026e4:	df000704 	addi	fp,sp,28
 18026e8:	e13ffc15 	stw	r4,-16(fp)
 18026ec:	e17ffd15 	stw	r5,-12(fp)
 18026f0:	e1bffe15 	stw	r6,-8(fp)
  void* base = sp->base;
 18026f4:	e0bffc17 	ldw	r2,-16(fp)
 18026f8:	10800017 	ldw	r2,0(r2)
 18026fc:	e0bffb15 	stw	r2,-20(fp)
 * HAL.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_no_error (void)
{
  return 0;
 1802700:	0005883a 	mov	r2,zero
  /* 
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
 1802704:	1004c03a 	cmpne	r2,r2,zero
 1802708:	1000061e 	bne	r2,zero,1802724 <altera_avalon_uart_init+0x4c>
 180270c:	0005883a 	mov	r2,zero
 1802710:	1004c03a 	cmpne	r2,r2,zero
 1802714:	1000031e 	bne	r2,zero,1802724 <altera_avalon_uart_init+0x4c>
 1802718:	0005883a 	mov	r2,zero
 180271c:	1005003a 	cmpeq	r2,r2,zero
 1802720:	1000031e 	bne	r2,zero,1802730 <altera_avalon_uart_init+0x58>
 1802724:	00800044 	movi	r2,1
 1802728:	e0bfff15 	stw	r2,-4(fp)
 180272c:	00000106 	br	1802734 <altera_avalon_uart_init+0x5c>
 1802730:	e03fff15 	stw	zero,-4(fp)
 1802734:	e0bfff17 	ldw	r2,-4(fp)
 1802738:	e0bffa15 	stw	r2,-24(fp)
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
          ALT_SEM_CREATE (&sp->write_lock, 1);

  if (!error)
 180273c:	e0bffa17 	ldw	r2,-24(fp)
 1802740:	1004c03a 	cmpne	r2,r2,zero
 1802744:	1000111e 	bne	r2,zero,180278c <altera_avalon_uart_init+0xb4>
  {
    /* enable interrupts at the device */
    sp->ctrl = ALTERA_AVALON_UART_CONTROL_RTS_MSK  |
 1802748:	e0fffc17 	ldw	r3,-16(fp)
 180274c:	00832004 	movi	r2,3200
 1802750:	18800115 	stw	r2,4(r3)
                ALTERA_AVALON_UART_CONTROL_RRDY_MSK |
                ALTERA_AVALON_UART_CONTROL_DCTS_MSK;

    IOWR_ALTERA_AVALON_UART_CONTROL(base, sp->ctrl); 
 1802754:	e0bffb17 	ldw	r2,-20(fp)
 1802758:	11000304 	addi	r4,r2,12
 180275c:	e0bffc17 	ldw	r2,-16(fp)
 1802760:	10800117 	ldw	r2,4(r2)
 1802764:	1007883a 	mov	r3,r2
 1802768:	2005883a 	mov	r2,r4
 180276c:	10c00035 	stwio	r3,0(r2)
  
    /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
    alt_ic_isr_register(irq_controller_id, irq, altera_avalon_uart_irq, sp, 
 1802770:	d8000015 	stw	zero,0(sp)
 1802774:	e13ffd17 	ldw	r4,-12(fp)
 1802778:	e17ffe17 	ldw	r5,-8(fp)
 180277c:	01806034 	movhi	r6,384
 1802780:	3189e804 	addi	r6,r6,10144
 1802784:	e1fffc17 	ldw	r7,-16(fp)
 1802788:	1804f440 	call	1804f44 <alt_ic_isr_register>
      0x0);
#else
    alt_irq_register (irq, sp, altera_avalon_uart_irq);
#endif  
  }
}
 180278c:	e037883a 	mov	sp,fp
 1802790:	dfc00117 	ldw	ra,4(sp)
 1802794:	df000017 	ldw	fp,0(sp)
 1802798:	dec00204 	addi	sp,sp,8
 180279c:	f800283a 	ret

018027a0 <altera_avalon_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_uart_irq(void* context)
#else
static void altera_avalon_uart_irq(void* context, alt_u32 id)
#endif
{
 18027a0:	defffa04 	addi	sp,sp,-24
 18027a4:	dfc00515 	stw	ra,20(sp)
 18027a8:	df000415 	stw	fp,16(sp)
 18027ac:	df000404 	addi	fp,sp,16
 18027b0:	e13fff15 	stw	r4,-4(fp)
  alt_u32 status;

  altera_avalon_uart_state* sp = (altera_avalon_uart_state*) context;
 18027b4:	e0bfff17 	ldw	r2,-4(fp)
 18027b8:	e0bffd15 	stw	r2,-12(fp)
  void* base               = sp->base;
 18027bc:	e0bffd17 	ldw	r2,-12(fp)
 18027c0:	10800017 	ldw	r2,0(r2)
 18027c4:	e0bffc15 	stw	r2,-16(fp)
  /*
   * Read the status register in order to determine the cause of the
   * interrupt.
   */

  status = IORD_ALTERA_AVALON_UART_STATUS(base);
 18027c8:	e0bffc17 	ldw	r2,-16(fp)
 18027cc:	10800204 	addi	r2,r2,8
 18027d0:	10800037 	ldwio	r2,0(r2)
 18027d4:	e0bffe15 	stw	r2,-8(fp)

  /* Clear any error flags set at the device */
  IOWR_ALTERA_AVALON_UART_STATUS(base, 0);
 18027d8:	e0bffc17 	ldw	r2,-16(fp)
 18027dc:	10800204 	addi	r2,r2,8
 18027e0:	10000035 	stwio	zero,0(r2)

  /* Dummy read to ensure IRQ is negated before ISR returns */
  IORD_ALTERA_AVALON_UART_STATUS(base);
 18027e4:	e0bffc17 	ldw	r2,-16(fp)
 18027e8:	10800204 	addi	r2,r2,8
 18027ec:	10800037 	ldwio	r2,0(r2)
  
  /* process a read irq */
  if (status & ALTERA_AVALON_UART_STATUS_RRDY_MSK)
 18027f0:	e0bffe17 	ldw	r2,-8(fp)
 18027f4:	1080200c 	andi	r2,r2,128
 18027f8:	1005003a 	cmpeq	r2,r2,zero
 18027fc:	1000031e 	bne	r2,zero,180280c <altera_avalon_uart_irq+0x6c>
  {
    altera_avalon_uart_rxirq(sp, status);
 1802800:	e13ffd17 	ldw	r4,-12(fp)
 1802804:	e17ffe17 	ldw	r5,-8(fp)
 1802808:	180283c0 	call	180283c <altera_avalon_uart_rxirq>
  }

  /* process a write irq */
  if (status & (ALTERA_AVALON_UART_STATUS_TRDY_MSK | 
 180280c:	e0bffe17 	ldw	r2,-8(fp)
 1802810:	1081100c 	andi	r2,r2,1088
 1802814:	1005003a 	cmpeq	r2,r2,zero
 1802818:	1000031e 	bne	r2,zero,1802828 <altera_avalon_uart_irq+0x88>
                  ALTERA_AVALON_UART_STATUS_DCTS_MSK))
  {
    altera_avalon_uart_txirq(sp, status);
 180281c:	e13ffd17 	ldw	r4,-12(fp)
 1802820:	e17ffe17 	ldw	r5,-8(fp)
 1802824:	180291c0 	call	180291c <altera_avalon_uart_txirq>
  }
  

}
 1802828:	e037883a 	mov	sp,fp
 180282c:	dfc00117 	ldw	ra,4(sp)
 1802830:	df000017 	ldw	fp,0(sp)
 1802834:	dec00204 	addi	sp,sp,8
 1802838:	f800283a 	ret

0180283c <altera_avalon_uart_rxirq>:
 * the receive circular buffer, and sets the apropriate flags to indicate 
 * that there is data ready to be processed.
 */
static void 
altera_avalon_uart_rxirq(altera_avalon_uart_state* sp, alt_u32 status)
{
 180283c:	defffc04 	addi	sp,sp,-16
 1802840:	df000315 	stw	fp,12(sp)
 1802844:	df000304 	addi	fp,sp,12
 1802848:	e13ffe15 	stw	r4,-8(fp)
 180284c:	e17fff15 	stw	r5,-4(fp)
  alt_u32 next;
  
  /* If there was an error, discard the data */

  if (status & (ALTERA_AVALON_UART_STATUS_PE_MSK | 
 1802850:	e0bfff17 	ldw	r2,-4(fp)
 1802854:	108000cc 	andi	r2,r2,3
 1802858:	1004c03a 	cmpne	r2,r2,zero
 180285c:	10002b1e 	bne	r2,zero,180290c <altera_avalon_uart_rxirq+0xd0>
   * In a multi-threaded environment, set the read event flag to indicate
   * that there is data ready. This is only done if the circular buffer was
   * previously empty.
   */

  if (sp->rx_end == sp->rx_start)
 1802860:	e0bffe17 	ldw	r2,-8(fp)
 1802864:	10800317 	ldw	r2,12(r2)
    ALT_FLAG_POST (sp->events, ALT_UART_READ_RDY, OS_FLAG_SET);
  }

  /* Determine which slot to use next in the circular buffer */

  next = (sp->rx_end + 1) & ALT_AVALON_UART_BUF_MSK;
 1802868:	e0bffe17 	ldw	r2,-8(fp)
 180286c:	10800317 	ldw	r2,12(r2)
 1802870:	10800044 	addi	r2,r2,1
 1802874:	10800fcc 	andi	r2,r2,63
 1802878:	e0bffd15 	stw	r2,-12(fp)

  /* Transfer data from the device to the circular buffer */

  sp->rx_buf[sp->rx_end] = IORD_ALTERA_AVALON_UART_RXDATA(sp->base);
 180287c:	e0bffe17 	ldw	r2,-8(fp)
 1802880:	11000317 	ldw	r4,12(r2)
 1802884:	e0bffe17 	ldw	r2,-8(fp)
 1802888:	10800017 	ldw	r2,0(r2)
 180288c:	10800037 	ldwio	r2,0(r2)
 1802890:	1007883a 	mov	r3,r2
 1802894:	e0bffe17 	ldw	r2,-8(fp)
 1802898:	2085883a 	add	r2,r4,r2
 180289c:	10800704 	addi	r2,r2,28
 18028a0:	10c00005 	stb	r3,0(r2)

  sp->rx_end = next;
 18028a4:	e0fffe17 	ldw	r3,-8(fp)
 18028a8:	e0bffd17 	ldw	r2,-12(fp)
 18028ac:	18800315 	stw	r2,12(r3)

  next = (sp->rx_end + 1) & ALT_AVALON_UART_BUF_MSK;
 18028b0:	e0bffe17 	ldw	r2,-8(fp)
 18028b4:	10800317 	ldw	r2,12(r2)
 18028b8:	10800044 	addi	r2,r2,1
 18028bc:	10800fcc 	andi	r2,r2,63
 18028c0:	e0bffd15 	stw	r2,-12(fp)
  /*
   * If the cicular buffer was full, disable interrupts. Interrupts will be
   * re-enabled when data is removed from the buffer.
   */

  if (next == sp->rx_start)
 18028c4:	e0bffe17 	ldw	r2,-8(fp)
 18028c8:	10c00217 	ldw	r3,8(r2)
 18028cc:	e0bffd17 	ldw	r2,-12(fp)
 18028d0:	18800e1e 	bne	r3,r2,180290c <altera_avalon_uart_rxirq+0xd0>
  {
    sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
 18028d4:	e0bffe17 	ldw	r2,-8(fp)
 18028d8:	10c00117 	ldw	r3,4(r2)
 18028dc:	00bfdfc4 	movi	r2,-129
 18028e0:	1886703a 	and	r3,r3,r2
 18028e4:	e0bffe17 	ldw	r2,-8(fp)
 18028e8:	10c00115 	stw	r3,4(r2)
    IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl); 
 18028ec:	e0bffe17 	ldw	r2,-8(fp)
 18028f0:	10800017 	ldw	r2,0(r2)
 18028f4:	11000304 	addi	r4,r2,12
 18028f8:	e0bffe17 	ldw	r2,-8(fp)
 18028fc:	10800117 	ldw	r2,4(r2)
 1802900:	1007883a 	mov	r3,r2
 1802904:	2005883a 	mov	r2,r4
 1802908:	10c00035 	stwio	r3,0(r2)
  }   
}
 180290c:	e037883a 	mov	sp,fp
 1802910:	df000017 	ldw	fp,0(sp)
 1802914:	dec00104 	addi	sp,sp,4
 1802918:	f800283a 	ret

0180291c <altera_avalon_uart_txirq>:
 * buffer to the device, and sets the apropriate flags to indicate that 
 * there is data ready to be processed.
 */
static void 
altera_avalon_uart_txirq(altera_avalon_uart_state* sp, alt_u32 status)
{
 180291c:	defffd04 	addi	sp,sp,-12
 1802920:	df000215 	stw	fp,8(sp)
 1802924:	df000204 	addi	fp,sp,8
 1802928:	e13ffe15 	stw	r4,-8(fp)
 180292c:	e17fff15 	stw	r5,-4(fp)
  /* Transfer data if there is some ready to be transfered */

  if (sp->tx_start != sp->tx_end)
 1802930:	e0bffe17 	ldw	r2,-8(fp)
 1802934:	10c00417 	ldw	r3,16(r2)
 1802938:	e0bffe17 	ldw	r2,-8(fp)
 180293c:	10800517 	ldw	r2,20(r2)
 1802940:	18803626 	beq	r3,r2,1802a1c <altera_avalon_uart_txirq+0x100>
    /* 
     * If the device is using flow control (i.e. RTS/CTS), then the
     * transmitter is required to throttle if CTS is high.
     */

    if (!(sp->flags & ALT_AVALON_UART_FC) ||
 1802944:	e0bffe17 	ldw	r2,-8(fp)
 1802948:	10800617 	ldw	r2,24(r2)
 180294c:	1080008c 	andi	r2,r2,2
 1802950:	1005003a 	cmpeq	r2,r2,zero
 1802954:	1000041e 	bne	r2,zero,1802968 <altera_avalon_uart_txirq+0x4c>
 1802958:	e0bfff17 	ldw	r2,-4(fp)
 180295c:	1082000c 	andi	r2,r2,2048
 1802960:	1005003a 	cmpeq	r2,r2,zero
 1802964:	10001e1e 	bne	r2,zero,18029e0 <altera_avalon_uart_txirq+0xc4>
       * In a multi-threaded environment, set the write event flag to indicate
       * that there is space in the circular buffer. This is only done if the
       * buffer was previously empty.
       */

      if (sp->tx_start == ((sp->tx_end + 1) & ALT_AVALON_UART_BUF_MSK))
 1802968:	e0bffe17 	ldw	r2,-8(fp)
 180296c:	10800417 	ldw	r2,16(r2)
                       OS_FLAG_SET);
      }

      /* Write the data to the device */

      IOWR_ALTERA_AVALON_UART_TXDATA(sp->base, sp->tx_buf[sp->tx_start]);
 1802970:	e0bffe17 	ldw	r2,-8(fp)
 1802974:	10800017 	ldw	r2,0(r2)
 1802978:	11000104 	addi	r4,r2,4
 180297c:	e0bffe17 	ldw	r2,-8(fp)
 1802980:	10c00417 	ldw	r3,16(r2)
 1802984:	e0bffe17 	ldw	r2,-8(fp)
 1802988:	1885883a 	add	r2,r3,r2
 180298c:	10801704 	addi	r2,r2,92
 1802990:	10800003 	ldbu	r2,0(r2)
 1802994:	10c03fcc 	andi	r3,r2,255
 1802998:	2005883a 	mov	r2,r4
 180299c:	10c00035 	stwio	r3,0(r2)

      sp->tx_start = (++sp->tx_start) & ALT_AVALON_UART_BUF_MSK;
 18029a0:	e0bffe17 	ldw	r2,-8(fp)
 18029a4:	10800417 	ldw	r2,16(r2)
 18029a8:	10c00044 	addi	r3,r2,1
 18029ac:	e0bffe17 	ldw	r2,-8(fp)
 18029b0:	10c00415 	stw	r3,16(r2)
 18029b4:	e0bffe17 	ldw	r2,-8(fp)
 18029b8:	10800417 	ldw	r2,16(r2)
 18029bc:	10c00fcc 	andi	r3,r2,63
 18029c0:	e0bffe17 	ldw	r2,-8(fp)
 18029c4:	10c00415 	stw	r3,16(r2)
      /*
       * In case the tranmit interrupt had previously been disabled by 
       * detecting a low value on CTS, it is reenabled here.
       */ 

      sp->ctrl |= ALTERA_AVALON_UART_CONTROL_TRDY_MSK;
 18029c8:	e0bffe17 	ldw	r2,-8(fp)
 18029cc:	10800117 	ldw	r2,4(r2)
 18029d0:	10c01014 	ori	r3,r2,64
 18029d4:	e0bffe17 	ldw	r2,-8(fp)
 18029d8:	10c00115 	stw	r3,4(r2)
    /* 
     * If the device is using flow control (i.e. RTS/CTS), then the
     * transmitter is required to throttle if CTS is high.
     */

    if (!(sp->flags & ALT_AVALON_UART_FC) ||
 18029dc:	00000f06 	br	1802a1c <altera_avalon_uart_txirq+0x100>
       * the last write to the status register. To avoid this resulting in
       * deadlock, it's necessary to re-check the status register here
       * before throttling.
       */
 
      status = IORD_ALTERA_AVALON_UART_STATUS(sp->base); 
 18029e0:	e0bffe17 	ldw	r2,-8(fp)
 18029e4:	10800017 	ldw	r2,0(r2)
 18029e8:	10800204 	addi	r2,r2,8
 18029ec:	10800037 	ldwio	r2,0(r2)
 18029f0:	e0bfff15 	stw	r2,-4(fp)

      if (!(status & ALTERA_AVALON_UART_STATUS_CTS_MSK))
 18029f4:	e0bfff17 	ldw	r2,-4(fp)
 18029f8:	1082000c 	andi	r2,r2,2048
 18029fc:	1004c03a 	cmpne	r2,r2,zero
 1802a00:	1000061e 	bne	r2,zero,1802a1c <altera_avalon_uart_txirq+0x100>
      {
        sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_TRDY_MSK;
 1802a04:	e0bffe17 	ldw	r2,-8(fp)
 1802a08:	10c00117 	ldw	r3,4(r2)
 1802a0c:	00bfefc4 	movi	r2,-65
 1802a10:	1886703a 	and	r3,r3,r2
 1802a14:	e0bffe17 	ldw	r2,-8(fp)
 1802a18:	10c00115 	stw	r3,4(r2)
  /*
   * If the circular buffer is empty, disable the interrupt. This will be
   * re-enabled when new data is placed in the buffer.
   */

  if (sp->tx_start == sp->tx_end)
 1802a1c:	e0bffe17 	ldw	r2,-8(fp)
 1802a20:	10c00417 	ldw	r3,16(r2)
 1802a24:	e0bffe17 	ldw	r2,-8(fp)
 1802a28:	10800517 	ldw	r2,20(r2)
 1802a2c:	1880061e 	bne	r3,r2,1802a48 <altera_avalon_uart_txirq+0x12c>
  {
    sp->ctrl &= ~(ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
 1802a30:	e0bffe17 	ldw	r2,-8(fp)
 1802a34:	10c00117 	ldw	r3,4(r2)
 1802a38:	00beefc4 	movi	r2,-1089
 1802a3c:	1886703a 	and	r3,r3,r2
 1802a40:	e0bffe17 	ldw	r2,-8(fp)
 1802a44:	10c00115 	stw	r3,4(r2)
                    ALTERA_AVALON_UART_CONTROL_DCTS_MSK);
  }

  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
 1802a48:	e0bffe17 	ldw	r2,-8(fp)
 1802a4c:	10800017 	ldw	r2,0(r2)
 1802a50:	11000304 	addi	r4,r2,12
 1802a54:	e0bffe17 	ldw	r2,-8(fp)
 1802a58:	10800117 	ldw	r2,4(r2)
 1802a5c:	1007883a 	mov	r3,r2
 1802a60:	2005883a 	mov	r2,r4
 1802a64:	10c00035 	stwio	r3,0(r2)
}
 1802a68:	e037883a 	mov	sp,fp
 1802a6c:	df000017 	ldw	fp,0(sp)
 1802a70:	dec00104 	addi	sp,sp,4
 1802a74:	f800283a 	ret

01802a78 <altera_avalon_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_uart_close(altera_avalon_uart_state* sp, int flags)
{
 1802a78:	defffc04 	addi	sp,sp,-16
 1802a7c:	df000315 	stw	fp,12(sp)
 1802a80:	df000304 	addi	fp,sp,12
 1802a84:	e13ffd15 	stw	r4,-12(fp)
 1802a88:	e17ffe15 	stw	r5,-8(fp)
  /* 
   * Wait for all transmit data to be emptied by the UART ISR.
   */
  while (sp->tx_start != sp->tx_end) {
 1802a8c:	00000706 	br	1802aac <altera_avalon_uart_close+0x34>
    if (flags & O_NONBLOCK) {
 1802a90:	e0bffe17 	ldw	r2,-8(fp)
 1802a94:	1090000c 	andi	r2,r2,16384
 1802a98:	1005003a 	cmpeq	r2,r2,zero
 1802a9c:	1000031e 	bne	r2,zero,1802aac <altera_avalon_uart_close+0x34>
      return -EWOULDBLOCK; 
 1802aa0:	00bffd44 	movi	r2,-11
 1802aa4:	e0bfff15 	stw	r2,-4(fp)
 1802aa8:	00000606 	br	1802ac4 <altera_avalon_uart_close+0x4c>
int altera_avalon_uart_close(altera_avalon_uart_state* sp, int flags)
{
  /* 
   * Wait for all transmit data to be emptied by the UART ISR.
   */
  while (sp->tx_start != sp->tx_end) {
 1802aac:	e0bffd17 	ldw	r2,-12(fp)
 1802ab0:	10c00417 	ldw	r3,16(r2)
 1802ab4:	e0bffd17 	ldw	r2,-12(fp)
 1802ab8:	10800517 	ldw	r2,20(r2)
 1802abc:	18bff41e 	bne	r3,r2,1802a90 <altera_avalon_uart_close+0x18>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
 1802ac0:	e03fff15 	stw	zero,-4(fp)
 1802ac4:	e0bfff17 	ldw	r2,-4(fp)
}
 1802ac8:	e037883a 	mov	sp,fp
 1802acc:	df000017 	ldw	fp,0(sp)
 1802ad0:	dec00104 	addi	sp,sp,4
 1802ad4:	f800283a 	ret

01802ad8 <altera_avalon_uart_read>:
 */

int 
altera_avalon_uart_read(altera_avalon_uart_state* sp, char* ptr, int len,
  int flags)
{
 1802ad8:	defff004 	addi	sp,sp,-64
 1802adc:	dfc00f15 	stw	ra,60(sp)
 1802ae0:	df000e15 	stw	fp,56(sp)
 1802ae4:	df000e04 	addi	fp,sp,56
 1802ae8:	e13ffb15 	stw	r4,-20(fp)
 1802aec:	e17ffc15 	stw	r5,-16(fp)
 1802af0:	e1bffd15 	stw	r6,-12(fp)
 1802af4:	e1fffe15 	stw	r7,-8(fp)
  alt_irq_context context;
  int             block;
  alt_u32         next;
  alt_u8          read_would_block = 0;
 1802af8:	e03ff705 	stb	zero,-36(fp)
  int             count = 0;
 1802afc:	e03ff615 	stw	zero,-40(fp)
  /* 
   * Construct a flag to indicate whether the device is being accessed in
   * blocking or non-blocking mode.
   */

  block = !(flags & O_NONBLOCK);
 1802b00:	e0bffe17 	ldw	r2,-8(fp)
 1802b04:	1090000c 	andi	r2,r2,16384
 1802b08:	1005003a 	cmpeq	r2,r2,zero
 1802b0c:	e0bff915 	stw	r2,-28(fp)
  /*
   * Calculate which slot in the circular buffer is the next one to read
   * data from.
   */

  next = (sp->rx_start + 1) & ALT_AVALON_UART_BUF_MSK;
 1802b10:	e0bffb17 	ldw	r2,-20(fp)
 1802b14:	10800217 	ldw	r2,8(r2)
 1802b18:	10800044 	addi	r2,r2,1
 1802b1c:	10800fcc 	andi	r2,r2,63
 1802b20:	e0bff815 	stw	r2,-32(fp)
    /*
     * Read the required amount of data, until the circular buffer runs
     * empty
     */

    while ((count < len) && (sp->rx_start != sp->rx_end))
 1802b24:	00001906 	br	1802b8c <altera_avalon_uart_read+0xb4>
    {
      count++;
 1802b28:	e0bff617 	ldw	r2,-40(fp)
 1802b2c:	10800044 	addi	r2,r2,1
 1802b30:	e0bff615 	stw	r2,-40(fp)
      *ptr++ = sp->rx_buf[sp->rx_start];
 1802b34:	e0bffb17 	ldw	r2,-20(fp)
 1802b38:	10c00217 	ldw	r3,8(r2)
 1802b3c:	e0bffb17 	ldw	r2,-20(fp)
 1802b40:	1885883a 	add	r2,r3,r2
 1802b44:	10800704 	addi	r2,r2,28
 1802b48:	10800003 	ldbu	r2,0(r2)
 1802b4c:	1007883a 	mov	r3,r2
 1802b50:	e0bffc17 	ldw	r2,-16(fp)
 1802b54:	10c00005 	stb	r3,0(r2)
 1802b58:	e0bffc17 	ldw	r2,-16(fp)
 1802b5c:	10800044 	addi	r2,r2,1
 1802b60:	e0bffc15 	stw	r2,-16(fp)
      
      sp->rx_start = (++sp->rx_start) & ALT_AVALON_UART_BUF_MSK;
 1802b64:	e0bffb17 	ldw	r2,-20(fp)
 1802b68:	10800217 	ldw	r2,8(r2)
 1802b6c:	10c00044 	addi	r3,r2,1
 1802b70:	e0bffb17 	ldw	r2,-20(fp)
 1802b74:	10c00215 	stw	r3,8(r2)
 1802b78:	e0bffb17 	ldw	r2,-20(fp)
 1802b7c:	10800217 	ldw	r2,8(r2)
 1802b80:	10c00fcc 	andi	r3,r2,63
 1802b84:	e0bffb17 	ldw	r2,-20(fp)
 1802b88:	10c00215 	stw	r3,8(r2)
    /*
     * Read the required amount of data, until the circular buffer runs
     * empty
     */

    while ((count < len) && (sp->rx_start != sp->rx_end))
 1802b8c:	e0fff617 	ldw	r3,-40(fp)
 1802b90:	e0bffd17 	ldw	r2,-12(fp)
 1802b94:	1880050e 	bge	r3,r2,1802bac <altera_avalon_uart_read+0xd4>
 1802b98:	e0bffb17 	ldw	r2,-20(fp)
 1802b9c:	10c00217 	ldw	r3,8(r2)
 1802ba0:	e0bffb17 	ldw	r2,-20(fp)
 1802ba4:	10800317 	ldw	r2,12(r2)
 1802ba8:	18bfdf1e 	bne	r3,r2,1802b28 <altera_avalon_uart_read+0x50>
    /*
     * If no data has been transferred, the circular buffer is empty, and
     * this is not a non-blocking access, block waiting for data to arrive.
     */

    if (!count && (sp->rx_start == sp->rx_end))
 1802bac:	e0bff617 	ldw	r2,-40(fp)
 1802bb0:	1004c03a 	cmpne	r2,r2,zero
 1802bb4:	1000271e 	bne	r2,zero,1802c54 <altera_avalon_uart_read+0x17c>
 1802bb8:	e0bffb17 	ldw	r2,-20(fp)
 1802bbc:	10c00217 	ldw	r3,8(r2)
 1802bc0:	e0bffb17 	ldw	r2,-20(fp)
 1802bc4:	10800317 	ldw	r2,12(r2)
 1802bc8:	1880221e 	bne	r3,r2,1802c54 <altera_avalon_uart_read+0x17c>
    {
      if (!block)
 1802bcc:	e0bff917 	ldw	r2,-28(fp)
 1802bd0:	1004c03a 	cmpne	r2,r2,zero
 1802bd4:	1000061e 	bne	r2,zero,1802bf0 <altera_avalon_uart_read+0x118>
      {
        /* Set errno to indicate the reason we're not returning any data */

        ALT_ERRNO = EWOULDBLOCK;
 1802bd8:	1802d080 	call	1802d08 <alt_get_errno>
 1802bdc:	00c002c4 	movi	r3,11
 1802be0:	10c00015 	stw	r3,0(r2)
        read_would_block = 1;
 1802be4:	00800044 	movi	r2,1
 1802be8:	e0bff705 	stb	r2,-36(fp)
        break;
 1802bec:	00001f06 	br	1802c6c <altera_avalon_uart_read+0x194>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 1802bf0:	0005303a 	rdctl	r2,status
 1802bf4:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 1802bf8:	e0fff517 	ldw	r3,-44(fp)
 1802bfc:	00bfff84 	movi	r2,-2
 1802c00:	1884703a 	and	r2,r3,r2
 1802c04:	1001703a 	wrctl	status,r2
  
  return context;
 1802c08:	e0bff517 	ldw	r2,-44(fp)
      {
       /* Block waiting for some data to arrive */

       /* First, ensure read interrupts are enabled to avoid deadlock */

       context = alt_irq_disable_all ();
 1802c0c:	e0bffa15 	stw	r2,-24(fp)
       sp->ctrl |= ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
 1802c10:	e0bffb17 	ldw	r2,-20(fp)
 1802c14:	10800117 	ldw	r2,4(r2)
 1802c18:	10c02014 	ori	r3,r2,128
 1802c1c:	e0bffb17 	ldw	r2,-20(fp)
 1802c20:	10c00115 	stw	r3,4(r2)
       IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
 1802c24:	e0bffb17 	ldw	r2,-20(fp)
 1802c28:	10800017 	ldw	r2,0(r2)
 1802c2c:	11000304 	addi	r4,r2,12
 1802c30:	e0bffb17 	ldw	r2,-20(fp)
 1802c34:	10800117 	ldw	r2,4(r2)
 1802c38:	1007883a 	mov	r3,r2
 1802c3c:	2005883a 	mov	r2,r4
 1802c40:	10c00035 	stwio	r3,0(r2)
 1802c44:	e0bffa17 	ldw	r2,-24(fp)
 1802c48:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 1802c4c:	e0bff417 	ldw	r2,-48(fp)
 1802c50:	1001703a 	wrctl	status,r2
                      OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                      0);
      }
    }
  }
  while (!count && len);
 1802c54:	e0bff617 	ldw	r2,-40(fp)
 1802c58:	1004c03a 	cmpne	r2,r2,zero
 1802c5c:	1000031e 	bne	r2,zero,1802c6c <altera_avalon_uart_read+0x194>
 1802c60:	e0bffd17 	ldw	r2,-12(fp)
 1802c64:	1004c03a 	cmpne	r2,r2,zero
 1802c68:	103fc81e 	bne	r2,zero,1802b8c <altera_avalon_uart_read+0xb4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 1802c6c:	0005303a 	rdctl	r2,status
 1802c70:	e0bff315 	stw	r2,-52(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 1802c74:	e0fff317 	ldw	r3,-52(fp)
 1802c78:	00bfff84 	movi	r2,-2
 1802c7c:	1884703a 	and	r2,r3,r2
 1802c80:	1001703a 	wrctl	status,r2
  
  return context;
 1802c84:	e0bff317 	ldw	r2,-52(fp)
  /*
   * Ensure that interrupts are enabled, so that the circular buffer can
   * re-fill.
   */

  context = alt_irq_disable_all ();
 1802c88:	e0bffa15 	stw	r2,-24(fp)
  sp->ctrl |= ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
 1802c8c:	e0bffb17 	ldw	r2,-20(fp)
 1802c90:	10800117 	ldw	r2,4(r2)
 1802c94:	10c02014 	ori	r3,r2,128
 1802c98:	e0bffb17 	ldw	r2,-20(fp)
 1802c9c:	10c00115 	stw	r3,4(r2)
  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
 1802ca0:	e0bffb17 	ldw	r2,-20(fp)
 1802ca4:	10800017 	ldw	r2,0(r2)
 1802ca8:	11000304 	addi	r4,r2,12
 1802cac:	e0bffb17 	ldw	r2,-20(fp)
 1802cb0:	10800117 	ldw	r2,4(r2)
 1802cb4:	1007883a 	mov	r3,r2
 1802cb8:	2005883a 	mov	r2,r4
 1802cbc:	10c00035 	stwio	r3,0(r2)
 1802cc0:	e0bffa17 	ldw	r2,-24(fp)
 1802cc4:	e0bff215 	stw	r2,-56(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 1802cc8:	e0bff217 	ldw	r2,-56(fp)
 1802ccc:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (context);

  /* Return the number of bytes read */
  if(read_would_block) {
 1802cd0:	e0bff703 	ldbu	r2,-36(fp)
 1802cd4:	1005003a 	cmpeq	r2,r2,zero
 1802cd8:	1000031e 	bne	r2,zero,1802ce8 <altera_avalon_uart_read+0x210>
    return ~EWOULDBLOCK;
 1802cdc:	00bffd04 	movi	r2,-12
 1802ce0:	e0bfff15 	stw	r2,-4(fp)
 1802ce4:	00000206 	br	1802cf0 <altera_avalon_uart_read+0x218>
  }
  else {
    return count;
 1802ce8:	e0bff617 	ldw	r2,-40(fp)
 1802cec:	e0bfff15 	stw	r2,-4(fp)
 1802cf0:	e0bfff17 	ldw	r2,-4(fp)
  }
}
 1802cf4:	e037883a 	mov	sp,fp
 1802cf8:	dfc00117 	ldw	ra,4(sp)
 1802cfc:	df000017 	ldw	fp,0(sp)
 1802d00:	dec00204 	addi	sp,sp,8
 1802d04:	f800283a 	ret

01802d08 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 1802d08:	defffd04 	addi	sp,sp,-12
 1802d0c:	dfc00215 	stw	ra,8(sp)
 1802d10:	df000115 	stw	fp,4(sp)
 1802d14:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
 1802d18:	00806074 	movhi	r2,385
 1802d1c:	10abd204 	addi	r2,r2,-20664
 1802d20:	10800017 	ldw	r2,0(r2)
 1802d24:	1005003a 	cmpeq	r2,r2,zero
 1802d28:	1000061e 	bne	r2,zero,1802d44 <alt_get_errno+0x3c>
 1802d2c:	00806074 	movhi	r2,385
 1802d30:	10abd204 	addi	r2,r2,-20664
 1802d34:	10800017 	ldw	r2,0(r2)
 1802d38:	103ee83a 	callr	r2
 1802d3c:	e0bfff15 	stw	r2,-4(fp)
 1802d40:	00000306 	br	1802d50 <alt_get_errno+0x48>
 1802d44:	00806074 	movhi	r2,385
 1802d48:	10b2a604 	addi	r2,r2,-13672
 1802d4c:	e0bfff15 	stw	r2,-4(fp)
 1802d50:	e0bfff17 	ldw	r2,-4(fp)
}
 1802d54:	e037883a 	mov	sp,fp
 1802d58:	dfc00117 	ldw	ra,4(sp)
 1802d5c:	df000017 	ldw	fp,0(sp)
 1802d60:	dec00204 	addi	sp,sp,8
 1802d64:	f800283a 	ret

01802d68 <altera_avalon_uart_write>:
 */

int
altera_avalon_uart_write(altera_avalon_uart_state* sp, const char* ptr, int len,
  int flags)
{
 1802d68:	defff204 	addi	sp,sp,-56
 1802d6c:	dfc00d15 	stw	ra,52(sp)
 1802d70:	df000c15 	stw	fp,48(sp)
 1802d74:	df000c04 	addi	fp,sp,48
 1802d78:	e13ffc15 	stw	r4,-16(fp)
 1802d7c:	e17ffd15 	stw	r5,-12(fp)
 1802d80:	e1bffe15 	stw	r6,-8(fp)
 1802d84:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context context;
  int             no_block;
  alt_u32         next;
  int             count = len;
 1802d88:	e0bffe17 	ldw	r2,-8(fp)
 1802d8c:	e0bff815 	stw	r2,-32(fp)
  /* 
   * Construct a flag to indicate whether the device is being accessed in
   * blocking or non-blocking mode.
   */

  no_block = (flags & O_NONBLOCK);
 1802d90:	e0bfff17 	ldw	r2,-4(fp)
 1802d94:	1090000c 	andi	r2,r2,16384
 1802d98:	e0bffa15 	stw	r2,-24(fp)
   * Loop transferring data from the input buffer to the transmit circular
   * buffer. The loop is terminated once all the data has been transferred,
   * or, (if in non-blocking mode) the buffer becomes full.
   */

  while (count)
 1802d9c:	00004006 	br	1802ea0 <altera_avalon_uart_write+0x138>
  {
    /* Determine the next slot in the buffer to access */

    next = (sp->tx_end + 1) & ALT_AVALON_UART_BUF_MSK;
 1802da0:	e0bffc17 	ldw	r2,-16(fp)
 1802da4:	10800517 	ldw	r2,20(r2)
 1802da8:	10800044 	addi	r2,r2,1
 1802dac:	10800fcc 	andi	r2,r2,63
 1802db0:	e0bff915 	stw	r2,-28(fp)

    /* block waiting for space if necessary */

    if (next == sp->tx_start)
 1802db4:	e0bffc17 	ldw	r2,-16(fp)
 1802db8:	10c00417 	ldw	r3,16(r2)
 1802dbc:	e0bff917 	ldw	r2,-28(fp)
 1802dc0:	1880251e 	bne	r3,r2,1802e58 <altera_avalon_uart_write+0xf0>
    {
      if (no_block)
 1802dc4:	e0bffa17 	ldw	r2,-24(fp)
 1802dc8:	1005003a 	cmpeq	r2,r2,zero
 1802dcc:	1000051e 	bne	r2,zero,1802de4 <altera_avalon_uart_write+0x7c>
      {
        /* Set errno to indicate why this function returned early */
 
        ALT_ERRNO = EWOULDBLOCK;
 1802dd0:	1802f300 	call	1802f30 <alt_get_errno>
 1802dd4:	1007883a 	mov	r3,r2
 1802dd8:	008002c4 	movi	r2,11
 1802ddc:	18800015 	stw	r2,0(r3)
        break;
 1802de0:	00003206 	br	1802eac <altera_avalon_uart_write+0x144>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 1802de4:	0005303a 	rdctl	r2,status
 1802de8:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 1802dec:	e0fff717 	ldw	r3,-36(fp)
 1802df0:	00bfff84 	movi	r2,-2
 1802df4:	1884703a 	and	r2,r3,r2
 1802df8:	1001703a 	wrctl	status,r2
  
  return context;
 1802dfc:	e0bff717 	ldw	r2,-36(fp)
      {
        /* Block waiting for space in the circular buffer */

        /* First, ensure transmit interrupts are enabled to avoid deadlock */

        context = alt_irq_disable_all ();
 1802e00:	e0bffb15 	stw	r2,-20(fp)
        sp->ctrl |= (ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
 1802e04:	e0bffc17 	ldw	r2,-16(fp)
 1802e08:	10800117 	ldw	r2,4(r2)
 1802e0c:	10c11014 	ori	r3,r2,1088
 1802e10:	e0bffc17 	ldw	r2,-16(fp)
 1802e14:	10c00115 	stw	r3,4(r2)
                        ALTERA_AVALON_UART_CONTROL_DCTS_MSK);
        IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
 1802e18:	e0bffc17 	ldw	r2,-16(fp)
 1802e1c:	10800017 	ldw	r2,0(r2)
 1802e20:	11000304 	addi	r4,r2,12
 1802e24:	e0bffc17 	ldw	r2,-16(fp)
 1802e28:	10800117 	ldw	r2,4(r2)
 1802e2c:	1007883a 	mov	r3,r2
 1802e30:	2005883a 	mov	r2,r4
 1802e34:	10c00035 	stwio	r3,0(r2)
 1802e38:	e0bffb17 	ldw	r2,-20(fp)
 1802e3c:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 1802e40:	e0bff617 	ldw	r2,-40(fp)
 1802e44:	1001703a 	wrctl	status,r2
          ALT_FLAG_PEND (sp->events, 
                         ALT_UART_WRITE_RDY,
                         OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                         0);
        }
        while ((next == sp->tx_start));
 1802e48:	e0bffc17 	ldw	r2,-16(fp)
 1802e4c:	10c00417 	ldw	r3,16(r2)
 1802e50:	e0bff917 	ldw	r2,-28(fp)
 1802e54:	18bffc26 	beq	r3,r2,1802e48 <altera_avalon_uart_write+0xe0>
      }
    }

    count--;
 1802e58:	e0bff817 	ldw	r2,-32(fp)
 1802e5c:	10bfffc4 	addi	r2,r2,-1
 1802e60:	e0bff815 	stw	r2,-32(fp)

    /* Add the next character to the transmit buffer */

    sp->tx_buf[sp->tx_end] = *ptr++;
 1802e64:	e0bffc17 	ldw	r2,-16(fp)
 1802e68:	10c00517 	ldw	r3,20(r2)
 1802e6c:	e0bffd17 	ldw	r2,-12(fp)
 1802e70:	10800003 	ldbu	r2,0(r2)
 1802e74:	1009883a 	mov	r4,r2
 1802e78:	e0bffc17 	ldw	r2,-16(fp)
 1802e7c:	1885883a 	add	r2,r3,r2
 1802e80:	10801704 	addi	r2,r2,92
 1802e84:	11000005 	stb	r4,0(r2)
 1802e88:	e0bffd17 	ldw	r2,-12(fp)
 1802e8c:	10800044 	addi	r2,r2,1
 1802e90:	e0bffd15 	stw	r2,-12(fp)
    sp->tx_end = next;
 1802e94:	e0fffc17 	ldw	r3,-16(fp)
 1802e98:	e0bff917 	ldw	r2,-28(fp)
 1802e9c:	18800515 	stw	r2,20(r3)
   * Loop transferring data from the input buffer to the transmit circular
   * buffer. The loop is terminated once all the data has been transferred,
   * or, (if in non-blocking mode) the buffer becomes full.
   */

  while (count)
 1802ea0:	e0bff817 	ldw	r2,-32(fp)
 1802ea4:	1004c03a 	cmpne	r2,r2,zero
 1802ea8:	103fbd1e 	bne	r2,zero,1802da0 <altera_avalon_uart_write+0x38>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 1802eac:	0005303a 	rdctl	r2,status
 1802eb0:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 1802eb4:	e0fff517 	ldw	r3,-44(fp)
 1802eb8:	00bfff84 	movi	r2,-2
 1802ebc:	1884703a 	and	r2,r3,r2
 1802ec0:	1001703a 	wrctl	status,r2
  
  return context;
 1802ec4:	e0bff517 	ldw	r2,-44(fp)
  /* 
   * Ensure that interrupts are enabled, so that the circular buffer can 
   * drain.
   */

  context = alt_irq_disable_all ();
 1802ec8:	e0bffb15 	stw	r2,-20(fp)
  sp->ctrl |= ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
 1802ecc:	e0bffc17 	ldw	r2,-16(fp)
 1802ed0:	10800117 	ldw	r2,4(r2)
 1802ed4:	10c11014 	ori	r3,r2,1088
 1802ed8:	e0bffc17 	ldw	r2,-16(fp)
 1802edc:	10c00115 	stw	r3,4(r2)
                 ALTERA_AVALON_UART_CONTROL_DCTS_MSK;
  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
 1802ee0:	e0bffc17 	ldw	r2,-16(fp)
 1802ee4:	10800017 	ldw	r2,0(r2)
 1802ee8:	11000304 	addi	r4,r2,12
 1802eec:	e0bffc17 	ldw	r2,-16(fp)
 1802ef0:	10800117 	ldw	r2,4(r2)
 1802ef4:	1007883a 	mov	r3,r2
 1802ef8:	2005883a 	mov	r2,r4
 1802efc:	10c00035 	stwio	r3,0(r2)
 1802f00:	e0bffb17 	ldw	r2,-20(fp)
 1802f04:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 1802f08:	e0bff417 	ldw	r2,-48(fp)
 1802f0c:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (context);

  /* return the number of bytes written */

  return (len - count);
 1802f10:	e0fffe17 	ldw	r3,-8(fp)
 1802f14:	e0bff817 	ldw	r2,-32(fp)
 1802f18:	1885c83a 	sub	r2,r3,r2
}
 1802f1c:	e037883a 	mov	sp,fp
 1802f20:	dfc00117 	ldw	ra,4(sp)
 1802f24:	df000017 	ldw	fp,0(sp)
 1802f28:	dec00204 	addi	sp,sp,8
 1802f2c:	f800283a 	ret

01802f30 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 1802f30:	defffd04 	addi	sp,sp,-12
 1802f34:	dfc00215 	stw	ra,8(sp)
 1802f38:	df000115 	stw	fp,4(sp)
 1802f3c:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
 1802f40:	00806074 	movhi	r2,385
 1802f44:	10abd204 	addi	r2,r2,-20664
 1802f48:	10800017 	ldw	r2,0(r2)
 1802f4c:	1005003a 	cmpeq	r2,r2,zero
 1802f50:	1000061e 	bne	r2,zero,1802f6c <alt_get_errno+0x3c>
 1802f54:	00806074 	movhi	r2,385
 1802f58:	10abd204 	addi	r2,r2,-20664
 1802f5c:	10800017 	ldw	r2,0(r2)
 1802f60:	103ee83a 	callr	r2
 1802f64:	e0bfff15 	stw	r2,-4(fp)
 1802f68:	00000306 	br	1802f78 <alt_get_errno+0x48>
 1802f6c:	00806074 	movhi	r2,385
 1802f70:	10b2a604 	addi	r2,r2,-13672
 1802f74:	e0bfff15 	stw	r2,-4(fp)
 1802f78:	e0bfff17 	ldw	r2,-4(fp)
}
 1802f7c:	e037883a 	mov	sp,fp
 1802f80:	dfc00117 	ldw	ra,4(sp)
 1802f84:	df000017 	ldw	fp,0(sp)
 1802f88:	dec00204 	addi	sp,sp,8
 1802f8c:	f800283a 	ret

01802f90 <chThdAddRef>:
 * @return              The same thread pointer passed as parameter
 *                      representing the new reference.
 *
 * @api
 */
Thread *chThdAddRef(Thread *tp) {
 1802f90:	defffc04 	addi	sp,sp,-16
 1802f94:	df000315 	stw	fp,12(sp)
 1802f98:	df000304 	addi	fp,sp,12
 1802f9c:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 1802fa0:	0005303a 	rdctl	r2,status
 1802fa4:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 1802fa8:	e0fffe17 	ldw	r3,-8(fp)
 1802fac:	00bfff84 	movi	r2,-2
 1802fb0:	1884703a 	and	r2,r3,r2
 1802fb4:	1001703a 	wrctl	status,r2

  chSysLock();
  chDbgAssert(tp->p_refs < 255, "chThdAddRef(), #1", "too many references");
  tp->p_refs++;
 1802fb8:	e0bfff17 	ldw	r2,-4(fp)
 1802fbc:	10800783 	ldbu	r2,30(r2)
 1802fc0:	10800044 	addi	r2,r2,1
 1802fc4:	1007883a 	mov	r3,r2
 1802fc8:	e0bfff17 	ldw	r2,-4(fp)
 1802fcc:	10c00785 	stb	r3,30(r2)
 1802fd0:	00800044 	movi	r2,1
 1802fd4:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 1802fd8:	e0bffd17 	ldw	r2,-12(fp)
 1802fdc:	1001703a 	wrctl	status,r2
  chSysUnlock();
  return tp;
 1802fe0:	e0bfff17 	ldw	r2,-4(fp)
}
 1802fe4:	e037883a 	mov	sp,fp
 1802fe8:	df000017 	ldw	fp,0(sp)
 1802fec:	dec00104 	addi	sp,sp,4
 1802ff0:	f800283a 	ret

01802ff4 <chThdRelease>:
 *
 * @param[in] tp        pointer to the thread
 *
 * @api
 */
void chThdRelease(Thread *tp) {
 1802ff4:	defff904 	addi	sp,sp,-28
 1802ff8:	dfc00615 	stw	ra,24(sp)
 1802ffc:	df000515 	stw	fp,20(sp)
 1803000:	df000504 	addi	fp,sp,20
 1803004:	e13ffe15 	stw	r4,-8(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 1803008:	0005303a 	rdctl	r2,status
 180300c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 1803010:	e0fffc17 	ldw	r3,-16(fp)
 1803014:	00bfff84 	movi	r2,-2
 1803018:	1884703a 	and	r2,r3,r2
 180301c:	1001703a 	wrctl	status,r2
  trefs_t refs;

  chSysLock();
  chDbgAssert(tp->p_refs > 0, "chThdRelease(), #1", "not referenced");
  refs = --tp->p_refs;
 1803020:	e0bffe17 	ldw	r2,-8(fp)
 1803024:	10800783 	ldbu	r2,30(r2)
 1803028:	10bfffc4 	addi	r2,r2,-1
 180302c:	1007883a 	mov	r3,r2
 1803030:	e0bffe17 	ldw	r2,-8(fp)
 1803034:	10c00785 	stb	r3,30(r2)
 1803038:	e0bffe17 	ldw	r2,-8(fp)
 180303c:	10800783 	ldbu	r2,30(r2)
 1803040:	e0bffd05 	stb	r2,-12(fp)
 1803044:	00800044 	movi	r2,1
 1803048:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 180304c:	e0bffb17 	ldw	r2,-20(fp)
 1803050:	1001703a 	wrctl	status,r2
  chSysUnlock();

  /* If the references counter reaches zero and the thread is in its
     terminated state then the memory can be returned to the proper
     allocator. Of course static threads are not affected.*/
  if ((refs == 0) && (tp->p_state == THD_STATE_FINAL)) {
 1803054:	e0bffd03 	ldbu	r2,-12(fp)
 1803058:	1004c03a 	cmpne	r2,r2,zero
 180305c:	10002d1e 	bne	r2,zero,1803114 <chThdRelease+0x120>
 1803060:	e0bffe17 	ldw	r2,-8(fp)
 1803064:	10800703 	ldbu	r2,28(r2)
 1803068:	10803fcc 	andi	r2,r2,255
 180306c:	10800398 	cmpnei	r2,r2,14
 1803070:	1000281e 	bne	r2,zero,1803114 <chThdRelease+0x120>
    switch (tp->p_flags & THD_MEM_MODE_MASK) {
 1803074:	e0bffe17 	ldw	r2,-8(fp)
 1803078:	10800743 	ldbu	r2,29(r2)
 180307c:	10803fcc 	andi	r2,r2,255
 1803080:	108000cc 	andi	r2,r2,3
 1803084:	e0bfff15 	stw	r2,-4(fp)
 1803088:	e0ffff17 	ldw	r3,-4(fp)
 180308c:	18800060 	cmpeqi	r2,r3,1
 1803090:	1000041e 	bne	r2,zero,18030a4 <chThdRelease+0xb0>
 1803094:	e0ffff17 	ldw	r3,-4(fp)
 1803098:	188000a0 	cmpeqi	r2,r3,2
 180309c:	10000e1e 	bne	r2,zero,18030d8 <chThdRelease+0xe4>
 18030a0:	00001c06 	br	1803114 <chThdRelease+0x120>
#if CH_USE_HEAP
    case THD_MEM_MODE_HEAP:
#if CH_USE_REGISTRY
      REG_REMOVE(tp);
 18030a4:	e0bffe17 	ldw	r2,-8(fp)
 18030a8:	10c00517 	ldw	r3,20(r2)
 18030ac:	e0bffe17 	ldw	r2,-8(fp)
 18030b0:	10800417 	ldw	r2,16(r2)
 18030b4:	18800415 	stw	r2,16(r3)
 18030b8:	e0bffe17 	ldw	r2,-8(fp)
 18030bc:	10c00417 	ldw	r3,16(r2)
 18030c0:	e0bffe17 	ldw	r2,-8(fp)
 18030c4:	10800517 	ldw	r2,20(r2)
 18030c8:	18800515 	stw	r2,20(r3)
#endif
      chHeapFree(tp);
 18030cc:	e13ffe17 	ldw	r4,-8(fp)
 18030d0:	18035580 	call	1803558 <chHeapFree>
      break;
 18030d4:	00000f06 	br	1803114 <chThdRelease+0x120>
#endif
#if CH_USE_MEMPOOLS
    case THD_MEM_MODE_MEMPOOL:
#if CH_USE_REGISTRY
      REG_REMOVE(tp);
 18030d8:	e0bffe17 	ldw	r2,-8(fp)
 18030dc:	10c00517 	ldw	r3,20(r2)
 18030e0:	e0bffe17 	ldw	r2,-8(fp)
 18030e4:	10800417 	ldw	r2,16(r2)
 18030e8:	18800415 	stw	r2,16(r3)
 18030ec:	e0bffe17 	ldw	r2,-8(fp)
 18030f0:	10c00417 	ldw	r3,16(r2)
 18030f4:	e0bffe17 	ldw	r2,-8(fp)
 18030f8:	10800517 	ldw	r2,20(r2)
 18030fc:	18800515 	stw	r2,20(r3)
#endif
      chPoolFree(tp->p_mpool, tp);
 1803100:	e0bffe17 	ldw	r2,-8(fp)
 1803104:	10801117 	ldw	r2,68(r2)
 1803108:	1009883a 	mov	r4,r2
 180310c:	e17ffe17 	ldw	r5,-8(fp)
 1803110:	1803aa00 	call	1803aa0 <chPoolFree>
      break;
#endif
    }
  }
}
 1803114:	e037883a 	mov	sp,fp
 1803118:	dfc00117 	ldw	ra,4(sp)
 180311c:	df000017 	ldw	fp,0(sp)
 1803120:	dec00204 	addi	sp,sp,8
 1803124:	f800283a 	ret

01803128 <chThdCreateFromHeap>:
 * @retval NULL         if the memory cannot be allocated.
 *
 * @api
 */
Thread *chThdCreateFromHeap(MemoryHeap *heapp, size_t size,
                            tprio_t prio, tfunc_t pf, void *arg) {
 1803128:	defff404 	addi	sp,sp,-48
 180312c:	dfc00b15 	stw	ra,44(sp)
 1803130:	df000a15 	stw	fp,40(sp)
 1803134:	df000a04 	addi	fp,sp,40
 1803138:	e13ffb15 	stw	r4,-20(fp)
 180313c:	e17ffc15 	stw	r5,-16(fp)
 1803140:	e1bffd15 	stw	r6,-12(fp)
 1803144:	e1fffe15 	stw	r7,-8(fp)
  void *wsp;
  Thread *tp;

  wsp = chHeapAlloc(heapp, size);
 1803148:	e13ffb17 	ldw	r4,-20(fp)
 180314c:	e17ffc17 	ldw	r5,-16(fp)
 1803150:	18033a00 	call	18033a0 <chHeapAlloc>
 1803154:	e0bffa15 	stw	r2,-24(fp)
  if (wsp == NULL)
 1803158:	e0bffa17 	ldw	r2,-24(fp)
 180315c:	1004c03a 	cmpne	r2,r2,zero
 1803160:	1000021e 	bne	r2,zero,180316c <chThdCreateFromHeap+0x44>
    return NULL;
 1803164:	e03fff15 	stw	zero,-4(fp)
 1803168:	00001a06 	br	18031d4 <chThdCreateFromHeap+0xac>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 180316c:	0005303a 	rdctl	r2,status
 1803170:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 1803174:	e0fff817 	ldw	r3,-32(fp)
 1803178:	00bfff84 	movi	r2,-2
 180317c:	1884703a 	and	r2,r3,r2
 1803180:	1001703a 	wrctl	status,r2
                  (uint8_t *)wsp + size,
                  CH_STACK_FILL_VALUE);
#endif
  
  chSysLock();
  tp = chThdCreateI(wsp, size, prio, pf, arg);
 1803184:	e0800217 	ldw	r2,8(fp)
 1803188:	d8800015 	stw	r2,0(sp)
 180318c:	e13ffa17 	ldw	r4,-24(fp)
 1803190:	e17ffc17 	ldw	r5,-16(fp)
 1803194:	e1bffd17 	ldw	r6,-12(fp)
 1803198:	e1fffe17 	ldw	r7,-8(fp)
 180319c:	1800aec0 	call	1800aec <chThdCreateI>
 18031a0:	e0bff915 	stw	r2,-28(fp)
  tp->p_flags = THD_MEM_MODE_HEAP;
 18031a4:	e0fff917 	ldw	r3,-28(fp)
 18031a8:	00800044 	movi	r2,1
 18031ac:	18800745 	stb	r2,29(r3)
  chSchWakeupS(tp, RDY_OK);
 18031b0:	e13ff917 	ldw	r4,-28(fp)
 18031b4:	000b883a 	mov	r5,zero
 18031b8:	180463c0 	call	180463c <chSchWakeupS>
 18031bc:	00800044 	movi	r2,1
 18031c0:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 18031c4:	e0bff717 	ldw	r2,-36(fp)
 18031c8:	1001703a 	wrctl	status,r2
  chSysUnlock();
  return tp;
 18031cc:	e0bff917 	ldw	r2,-28(fp)
 18031d0:	e0bfff15 	stw	r2,-4(fp)
 18031d4:	e0bfff17 	ldw	r2,-4(fp)
}
 18031d8:	e037883a 	mov	sp,fp
 18031dc:	dfc00117 	ldw	ra,4(sp)
 18031e0:	df000017 	ldw	fp,0(sp)
 18031e4:	dec00204 	addi	sp,sp,8
 18031e8:	f800283a 	ret

018031ec <chThdCreateFromMemoryPool>:
 * @retval  NULL        if the memory pool is empty.
 *
 * @api
 */
Thread *chThdCreateFromMemoryPool(MemoryPool *mp, tprio_t prio,
                                  tfunc_t pf, void *arg) {
 18031ec:	defff404 	addi	sp,sp,-48
 18031f0:	dfc00b15 	stw	ra,44(sp)
 18031f4:	df000a15 	stw	fp,40(sp)
 18031f8:	df000a04 	addi	fp,sp,40
 18031fc:	e13ffb15 	stw	r4,-20(fp)
 1803200:	e17ffc15 	stw	r5,-16(fp)
 1803204:	e1bffd15 	stw	r6,-12(fp)
 1803208:	e1fffe15 	stw	r7,-8(fp)
  void *wsp;
  Thread *tp;

  chDbgCheck(mp != NULL, "chThdCreateFromMemoryPool");

  wsp = chPoolAlloc(mp);
 180320c:	e13ffb17 	ldw	r4,-20(fp)
 1803210:	18039e00 	call	18039e0 <chPoolAlloc>
 1803214:	e0bffa15 	stw	r2,-24(fp)
  if (wsp == NULL)
 1803218:	e0bffa17 	ldw	r2,-24(fp)
 180321c:	1004c03a 	cmpne	r2,r2,zero
 1803220:	1000021e 	bne	r2,zero,180322c <chThdCreateFromMemoryPool+0x40>
    return NULL;
 1803224:	e03fff15 	stw	zero,-4(fp)
 1803228:	00001e06 	br	18032a4 <chThdCreateFromMemoryPool+0xb8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 180322c:	0005303a 	rdctl	r2,status
 1803230:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 1803234:	e0fff817 	ldw	r3,-32(fp)
 1803238:	00bfff84 	movi	r2,-2
 180323c:	1884703a 	and	r2,r3,r2
 1803240:	1001703a 	wrctl	status,r2
                  (uint8_t *)wsp + mp->mp_object_size,
                  CH_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateI(wsp, mp->mp_object_size, prio, pf, arg);
 1803244:	e0bffb17 	ldw	r2,-20(fp)
 1803248:	11400117 	ldw	r5,4(r2)
 180324c:	e0bffe17 	ldw	r2,-8(fp)
 1803250:	d8800015 	stw	r2,0(sp)
 1803254:	e13ffa17 	ldw	r4,-24(fp)
 1803258:	e1bffc17 	ldw	r6,-16(fp)
 180325c:	e1fffd17 	ldw	r7,-12(fp)
 1803260:	1800aec0 	call	1800aec <chThdCreateI>
 1803264:	e0bff915 	stw	r2,-28(fp)
  tp->p_flags = THD_MEM_MODE_MEMPOOL;
 1803268:	e0fff917 	ldw	r3,-28(fp)
 180326c:	00800084 	movi	r2,2
 1803270:	18800745 	stb	r2,29(r3)
  tp->p_mpool = mp;
 1803274:	e0fff917 	ldw	r3,-28(fp)
 1803278:	e0bffb17 	ldw	r2,-20(fp)
 180327c:	18801115 	stw	r2,68(r3)
  chSchWakeupS(tp, RDY_OK);
 1803280:	e13ff917 	ldw	r4,-28(fp)
 1803284:	000b883a 	mov	r5,zero
 1803288:	180463c0 	call	180463c <chSchWakeupS>
 180328c:	00800044 	movi	r2,1
 1803290:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 1803294:	e0bff717 	ldw	r2,-36(fp)
 1803298:	1001703a 	wrctl	status,r2
  chSysUnlock();
  return tp;
 180329c:	e0bff917 	ldw	r2,-28(fp)
 18032a0:	e0bfff15 	stw	r2,-4(fp)
 18032a4:	e0bfff17 	ldw	r2,-4(fp)
}
 18032a8:	e037883a 	mov	sp,fp
 18032ac:	dfc00117 	ldw	ra,4(sp)
 18032b0:	df000017 	ldw	fp,0(sp)
 18032b4:	dec00204 	addi	sp,sp,8
 18032b8:	f800283a 	ret

018032bc <_heap_init>:
/**
 * @brief   Initializes the default heap.
 *
 * @notapi
 */
void _heap_init(void) {
 18032bc:	defffe04 	addi	sp,sp,-8
 18032c0:	dfc00115 	stw	ra,4(sp)
 18032c4:	df000015 	stw	fp,0(sp)
 18032c8:	d839883a 	mov	fp,sp
  default_heap.h_provider = chCoreAlloc;
 18032cc:	00c06074 	movhi	r3,385
 18032d0:	18f2aa04 	addi	r3,r3,-13656
 18032d4:	00806034 	movhi	r2,384
 18032d8:	108dfd04 	addi	r2,r2,14324
 18032dc:	18800015 	stw	r2,0(r3)
  default_heap.h_free.h.u.next = (union heap_header *)NULL;
 18032e0:	00806074 	movhi	r2,385
 18032e4:	10b2aa04 	addi	r2,r2,-13656
 18032e8:	10000115 	stw	zero,4(r2)
  default_heap.h_free.h.size = 0;
 18032ec:	00806074 	movhi	r2,385
 18032f0:	10b2aa04 	addi	r2,r2,-13656
 18032f4:	10000215 	stw	zero,8(r2)
#if CH_USE_MUTEXES || defined(__DOXYGEN__)
  chMtxInit(&default_heap.h_mtx);
 18032f8:	01006074 	movhi	r4,385
 18032fc:	2132ad04 	addi	r4,r4,-13644
 1803300:	1803b000 	call	1803b00 <chMtxInit>
#else
  chSemInit(&default_heap.h_sem, 1);
#endif
}
 1803304:	e037883a 	mov	sp,fp
 1803308:	dfc00117 	ldw	ra,4(sp)
 180330c:	df000017 	ldw	fp,0(sp)
 1803310:	dec00204 	addi	sp,sp,8
 1803314:	f800283a 	ret

01803318 <chHeapInit>:
 * @param[in] buf       heap buffer base
 * @param[in] size      heap size
 *
 * @init
 */
void chHeapInit(MemoryHeap *heapp, void *buf, size_t size) {
 1803318:	defffa04 	addi	sp,sp,-24
 180331c:	dfc00515 	stw	ra,20(sp)
 1803320:	df000415 	stw	fp,16(sp)
 1803324:	df000404 	addi	fp,sp,16
 1803328:	e13ffd15 	stw	r4,-12(fp)
 180332c:	e17ffe15 	stw	r5,-8(fp)
 1803330:	e1bfff15 	stw	r6,-4(fp)
  union heap_header *hp;

  chDbgCheck(MEM_IS_ALIGNED(buf) && MEM_IS_ALIGNED(size), "chHeapInit");
 1803334:	e0bffe17 	ldw	r2,-8(fp)
 1803338:	108000cc 	andi	r2,r2,3
 180333c:	1004c03a 	cmpne	r2,r2,zero
 1803340:	1000001e 	bne	r2,zero,1803344 <chHeapInit+0x2c>

  heapp->h_provider = (memgetfunc_t)NULL;
 1803344:	e0bffd17 	ldw	r2,-12(fp)
 1803348:	10000015 	stw	zero,0(r2)
  heapp->h_free.h.u.next = hp = buf;
 180334c:	e0bffe17 	ldw	r2,-8(fp)
 1803350:	e0bffc15 	stw	r2,-16(fp)
 1803354:	e0fffd17 	ldw	r3,-12(fp)
 1803358:	e0bffc17 	ldw	r2,-16(fp)
 180335c:	18800115 	stw	r2,4(r3)
  heapp->h_free.h.size = 0;
 1803360:	e0bffd17 	ldw	r2,-12(fp)
 1803364:	10000215 	stw	zero,8(r2)
  hp->h.u.next = NULL;
 1803368:	e0bffc17 	ldw	r2,-16(fp)
 180336c:	10000015 	stw	zero,0(r2)
  hp->h.size = size - sizeof(union heap_header);
 1803370:	e0bfff17 	ldw	r2,-4(fp)
 1803374:	10fffe04 	addi	r3,r2,-8
 1803378:	e0bffc17 	ldw	r2,-16(fp)
 180337c:	10c00115 	stw	r3,4(r2)
#if CH_USE_MUTEXES || defined(__DOXYGEN__)
  chMtxInit(&heapp->h_mtx);
 1803380:	e0bffd17 	ldw	r2,-12(fp)
 1803384:	11000304 	addi	r4,r2,12
 1803388:	1803b000 	call	1803b00 <chMtxInit>
#else
  chSemInit(&heapp->h_sem, 1);
#endif
}
 180338c:	e037883a 	mov	sp,fp
 1803390:	dfc00117 	ldw	ra,4(sp)
 1803394:	df000017 	ldw	fp,0(sp)
 1803398:	dec00204 	addi	sp,sp,8
 180339c:	f800283a 	ret

018033a0 <chHeapAlloc>:
 * @return              A pointer to the allocated block.
 * @retval NULL         if the block cannot be allocated.
 *
 * @api
 */
void *chHeapAlloc(MemoryHeap *heapp, size_t size) {
 18033a0:	defff804 	addi	sp,sp,-32
 18033a4:	dfc00715 	stw	ra,28(sp)
 18033a8:	df000615 	stw	fp,24(sp)
 18033ac:	df000604 	addi	fp,sp,24
 18033b0:	e13ffd15 	stw	r4,-12(fp)
 18033b4:	e17ffe15 	stw	r5,-8(fp)
  union heap_header *qp, *hp, *fp;

  if (heapp == NULL)
 18033b8:	e0bffd17 	ldw	r2,-12(fp)
 18033bc:	1004c03a 	cmpne	r2,r2,zero
 18033c0:	1000031e 	bne	r2,zero,18033d0 <chHeapAlloc+0x30>
    heapp = &default_heap;
 18033c4:	00806074 	movhi	r2,385
 18033c8:	10b2aa04 	addi	r2,r2,-13656
 18033cc:	e0bffd15 	stw	r2,-12(fp)

  size = MEM_ALIGN_NEXT(size);
 18033d0:	e0bffe17 	ldw	r2,-8(fp)
 18033d4:	10c000c4 	addi	r3,r2,3
 18033d8:	00bfff04 	movi	r2,-4
 18033dc:	1884703a 	and	r2,r3,r2
 18033e0:	e0bffe15 	stw	r2,-8(fp)
  qp = &heapp->h_free;
 18033e4:	e0bffd17 	ldw	r2,-12(fp)
 18033e8:	10800104 	addi	r2,r2,4
 18033ec:	e0bffc15 	stw	r2,-16(fp)
  H_LOCK(heapp);
 18033f0:	e0bffd17 	ldw	r2,-12(fp)
 18033f4:	11000304 	addi	r4,r2,12
 18033f8:	1803b480 	call	1803b48 <chMtxLock>

  while (qp->h.u.next != NULL) {
 18033fc:	00003106 	br	18034c4 <chHeapAlloc+0x124>
    hp = qp->h.u.next;
 1803400:	e0bffc17 	ldw	r2,-16(fp)
 1803404:	10800017 	ldw	r2,0(r2)
 1803408:	e0bffb15 	stw	r2,-20(fp)
    if (hp->h.size >= size) {
 180340c:	e0bffb17 	ldw	r2,-20(fp)
 1803410:	10c00117 	ldw	r3,4(r2)
 1803414:	e0bffe17 	ldw	r2,-8(fp)
 1803418:	18802836 	bltu	r3,r2,18034bc <chHeapAlloc+0x11c>
      if (hp->h.size < size + sizeof(union heap_header)) {
 180341c:	e0bffb17 	ldw	r2,-20(fp)
 1803420:	10c00117 	ldw	r3,4(r2)
 1803424:	e0bffe17 	ldw	r2,-8(fp)
 1803428:	10800204 	addi	r2,r2,8
 180342c:	1880052e 	bgeu	r3,r2,1803444 <chHeapAlloc+0xa4>
        /* Gets the whole block even if it is slightly bigger than the
           requested size because the fragment would be too small to be
           useful.*/
        qp->h.u.next = hp->h.u.next;
 1803430:	e0bffb17 	ldw	r2,-20(fp)
 1803434:	10c00017 	ldw	r3,0(r2)
 1803438:	e0bffc17 	ldw	r2,-16(fp)
 180343c:	10c00015 	stw	r3,0(r2)
 1803440:	00001606 	br	180349c <chHeapAlloc+0xfc>
      }
      else {
        /* Block bigger enough, must split it.*/
        fp = (void *)((uint8_t *)(hp) + sizeof(union heap_header) + size);
 1803444:	e0fffb17 	ldw	r3,-20(fp)
 1803448:	e0bffe17 	ldw	r2,-8(fp)
 180344c:	1885883a 	add	r2,r3,r2
 1803450:	10800204 	addi	r2,r2,8
 1803454:	e0bffa15 	stw	r2,-24(fp)
        fp->h.u.next = hp->h.u.next;
 1803458:	e0bffb17 	ldw	r2,-20(fp)
 180345c:	10c00017 	ldw	r3,0(r2)
 1803460:	e0bffa17 	ldw	r2,-24(fp)
 1803464:	10c00015 	stw	r3,0(r2)
        fp->h.size = hp->h.size - sizeof(union heap_header) - size;
 1803468:	e0bffb17 	ldw	r2,-20(fp)
 180346c:	10c00117 	ldw	r3,4(r2)
 1803470:	e0bffe17 	ldw	r2,-8(fp)
 1803474:	1885c83a 	sub	r2,r3,r2
 1803478:	10fffe04 	addi	r3,r2,-8
 180347c:	e0bffa17 	ldw	r2,-24(fp)
 1803480:	10c00115 	stw	r3,4(r2)
        qp->h.u.next = fp;
 1803484:	e0fffc17 	ldw	r3,-16(fp)
 1803488:	e0bffa17 	ldw	r2,-24(fp)
 180348c:	18800015 	stw	r2,0(r3)
        hp->h.size = size;
 1803490:	e0fffb17 	ldw	r3,-20(fp)
 1803494:	e0bffe17 	ldw	r2,-8(fp)
 1803498:	18800115 	stw	r2,4(r3)
      }
      hp->h.u.heap = heapp;
 180349c:	e0bffb17 	ldw	r2,-20(fp)
 18034a0:	e0fffd17 	ldw	r3,-12(fp)
 18034a4:	10c00015 	stw	r3,0(r2)

      H_UNLOCK(heapp);
 18034a8:	1803ec80 	call	1803ec8 <chMtxUnlock>
      return (void *)(hp + 1);
 18034ac:	e0bffb17 	ldw	r2,-20(fp)
 18034b0:	10800204 	addi	r2,r2,8
 18034b4:	e0bfff15 	stw	r2,-4(fp)
 18034b8:	00002106 	br	1803540 <chHeapAlloc+0x1a0>
    }
    qp = hp;
 18034bc:	e0bffb17 	ldw	r2,-20(fp)
 18034c0:	e0bffc15 	stw	r2,-16(fp)

  size = MEM_ALIGN_NEXT(size);
  qp = &heapp->h_free;
  H_LOCK(heapp);

  while (qp->h.u.next != NULL) {
 18034c4:	e0bffc17 	ldw	r2,-16(fp)
 18034c8:	10800017 	ldw	r2,0(r2)
 18034cc:	1004c03a 	cmpne	r2,r2,zero
 18034d0:	103fcb1e 	bne	r2,zero,1803400 <chHeapAlloc+0x60>
      return (void *)(hp + 1);
    }
    qp = hp;
  }

  H_UNLOCK(heapp);
 18034d4:	1803ec80 	call	1803ec8 <chMtxUnlock>

  /* More memory is required, tries to get it from the associated provider
     else fails.*/
  if (heapp->h_provider) {
 18034d8:	e0bffd17 	ldw	r2,-12(fp)
 18034dc:	10800017 	ldw	r2,0(r2)
 18034e0:	1005003a 	cmpeq	r2,r2,zero
 18034e4:	1000151e 	bne	r2,zero,180353c <chHeapAlloc+0x19c>
    hp = heapp->h_provider(size + sizeof(union heap_header));
 18034e8:	e0bffd17 	ldw	r2,-12(fp)
 18034ec:	10c00017 	ldw	r3,0(r2)
 18034f0:	e0bffe17 	ldw	r2,-8(fp)
 18034f4:	11000204 	addi	r4,r2,8
 18034f8:	183ee83a 	callr	r3
 18034fc:	e0bffb15 	stw	r2,-20(fp)
    if (hp != NULL) {
 1803500:	e0bffb17 	ldw	r2,-20(fp)
 1803504:	1005003a 	cmpeq	r2,r2,zero
 1803508:	10000c1e 	bne	r2,zero,180353c <chHeapAlloc+0x19c>
      hp->h.u.heap = heapp;
 180350c:	e0fffb17 	ldw	r3,-20(fp)
 1803510:	e0bffd17 	ldw	r2,-12(fp)
 1803514:	18800015 	stw	r2,0(r3)
      hp->h.size = size;
 1803518:	e0fffb17 	ldw	r3,-20(fp)
 180351c:	e0bffe17 	ldw	r2,-8(fp)
 1803520:	18800115 	stw	r2,4(r3)
      hp++;
 1803524:	e0bffb17 	ldw	r2,-20(fp)
 1803528:	10800204 	addi	r2,r2,8
 180352c:	e0bffb15 	stw	r2,-20(fp)
      return (void *)hp;
 1803530:	e0bffb17 	ldw	r2,-20(fp)
 1803534:	e0bfff15 	stw	r2,-4(fp)
 1803538:	00000106 	br	1803540 <chHeapAlloc+0x1a0>
    }
  }
  return NULL;
 180353c:	e03fff15 	stw	zero,-4(fp)
 1803540:	e0bfff17 	ldw	r2,-4(fp)
}
 1803544:	e037883a 	mov	sp,fp
 1803548:	dfc00117 	ldw	ra,4(sp)
 180354c:	df000017 	ldw	fp,0(sp)
 1803550:	dec00204 	addi	sp,sp,8
 1803554:	f800283a 	ret

01803558 <chHeapFree>:
 *
 * @param[in] p         pointer to the memory block to be freed
 *
 * @api
 */
void chHeapFree(void *p) {
 1803558:	defffa04 	addi	sp,sp,-24
 180355c:	dfc00515 	stw	ra,20(sp)
 1803560:	df000415 	stw	fp,16(sp)
 1803564:	df000404 	addi	fp,sp,16
 1803568:	e13fff15 	stw	r4,-4(fp)
  union heap_header *qp, *hp;
  MemoryHeap *heapp;

  chDbgCheck(p != NULL, "chHeapFree");

  hp = (union heap_header *)p - 1;
 180356c:	e0bfff17 	ldw	r2,-4(fp)
 1803570:	10bffe04 	addi	r2,r2,-8
 1803574:	e0bffd15 	stw	r2,-12(fp)
  heapp = hp->h.u.heap;
 1803578:	e0bffd17 	ldw	r2,-12(fp)
 180357c:	10800017 	ldw	r2,0(r2)
 1803580:	e0bffc15 	stw	r2,-16(fp)
  qp = &heapp->h_free;
 1803584:	e0bffc17 	ldw	r2,-16(fp)
 1803588:	10800104 	addi	r2,r2,4
 180358c:	e0bffe15 	stw	r2,-8(fp)
  H_LOCK(heapp);
 1803590:	e0bffc17 	ldw	r2,-16(fp)
 1803594:	11000304 	addi	r4,r2,12
 1803598:	1803b480 	call	1803b48 <chMtxLock>

  while (TRUE) {
    chDbgAssert((hp < qp) || (hp >= LIMIT(qp)),
 180359c:	e0fffd17 	ldw	r3,-12(fp)
 18035a0:	e0bffe17 	ldw	r2,-8(fp)
 18035a4:	18800036 	bltu	r3,r2,18035a8 <chHeapFree+0x50>
                "chHeapFree(), #1",
                "within free block");

    if (((qp == &heapp->h_free) || (hp > qp)) &&
 18035a8:	e0bffc17 	ldw	r2,-16(fp)
 18035ac:	10c00104 	addi	r3,r2,4
 18035b0:	e0bffe17 	ldw	r2,-8(fp)
 18035b4:	18800326 	beq	r3,r2,18035c4 <chHeapFree+0x6c>
 18035b8:	e0fffd17 	ldw	r3,-12(fp)
 18035bc:	e0bffe17 	ldw	r2,-8(fp)
 18035c0:	10c03e2e 	bgeu	r2,r3,18036bc <chHeapFree+0x164>
 18035c4:	e0bffe17 	ldw	r2,-8(fp)
 18035c8:	10800017 	ldw	r2,0(r2)
 18035cc:	1005003a 	cmpeq	r2,r2,zero
 18035d0:	1000041e 	bne	r2,zero,18035e4 <chHeapFree+0x8c>
 18035d4:	e0bffe17 	ldw	r2,-8(fp)
 18035d8:	10c00017 	ldw	r3,0(r2)
 18035dc:	e0bffd17 	ldw	r2,-12(fp)
 18035e0:	10c0362e 	bgeu	r2,r3,18036bc <chHeapFree+0x164>
        ((qp->h.u.next == NULL) || (hp < qp->h.u.next))) {
      /* Insertion after qp.*/
      hp->h.u.next = qp->h.u.next;
 18035e4:	e0bffe17 	ldw	r2,-8(fp)
 18035e8:	10c00017 	ldw	r3,0(r2)
 18035ec:	e0bffd17 	ldw	r2,-12(fp)
 18035f0:	10c00015 	stw	r3,0(r2)
      qp->h.u.next = hp;
 18035f4:	e0fffe17 	ldw	r3,-8(fp)
 18035f8:	e0bffd17 	ldw	r2,-12(fp)
 18035fc:	18800015 	stw	r2,0(r3)
      /* Verifies if the newly inserted block should be merged.*/
      if (LIMIT(hp) == hp->h.u.next) {
 1803600:	e0bffd17 	ldw	r2,-12(fp)
 1803604:	10800117 	ldw	r2,4(r2)
 1803608:	1007883a 	mov	r3,r2
 180360c:	e0bffd17 	ldw	r2,-12(fp)
 1803610:	1885883a 	add	r2,r3,r2
 1803614:	10800204 	addi	r2,r2,8
 1803618:	1007883a 	mov	r3,r2
 180361c:	e0bffd17 	ldw	r2,-12(fp)
 1803620:	10800017 	ldw	r2,0(r2)
 1803624:	18800e1e 	bne	r3,r2,1803660 <chHeapFree+0x108>
        /* Merge with the next block.*/
        hp->h.size += hp->h.u.next->h.size + sizeof(union heap_header);
 1803628:	e0bffd17 	ldw	r2,-12(fp)
 180362c:	10c00117 	ldw	r3,4(r2)
 1803630:	e0bffd17 	ldw	r2,-12(fp)
 1803634:	10800017 	ldw	r2,0(r2)
 1803638:	10800117 	ldw	r2,4(r2)
 180363c:	1885883a 	add	r2,r3,r2
 1803640:	10c00204 	addi	r3,r2,8
 1803644:	e0bffd17 	ldw	r2,-12(fp)
 1803648:	10c00115 	stw	r3,4(r2)
        hp->h.u.next = hp->h.u.next->h.u.next;
 180364c:	e0bffd17 	ldw	r2,-12(fp)
 1803650:	10800017 	ldw	r2,0(r2)
 1803654:	10c00017 	ldw	r3,0(r2)
 1803658:	e0bffd17 	ldw	r2,-12(fp)
 180365c:	10c00015 	stw	r3,0(r2)
      }
      if ((LIMIT(qp) == hp)) {
 1803660:	e0bffe17 	ldw	r2,-8(fp)
 1803664:	10800117 	ldw	r2,4(r2)
 1803668:	1007883a 	mov	r3,r2
 180366c:	e0bffe17 	ldw	r2,-8(fp)
 1803670:	1885883a 	add	r2,r3,r2
 1803674:	10800204 	addi	r2,r2,8
 1803678:	1007883a 	mov	r3,r2
 180367c:	e0bffd17 	ldw	r2,-12(fp)
 1803680:	18800c1e 	bne	r3,r2,18036b4 <chHeapFree+0x15c>
        /* Merge with the previous block.*/
        qp->h.size += hp->h.size + sizeof(union heap_header);
 1803684:	e0bffe17 	ldw	r2,-8(fp)
 1803688:	10c00117 	ldw	r3,4(r2)
 180368c:	e0bffd17 	ldw	r2,-12(fp)
 1803690:	10800117 	ldw	r2,4(r2)
 1803694:	1885883a 	add	r2,r3,r2
 1803698:	10c00204 	addi	r3,r2,8
 180369c:	e0bffe17 	ldw	r2,-8(fp)
 18036a0:	10c00115 	stw	r3,4(r2)
        qp->h.u.next = hp->h.u.next;
 18036a4:	e0bffd17 	ldw	r2,-12(fp)
 18036a8:	10c00017 	ldw	r3,0(r2)
 18036ac:	e0bffe17 	ldw	r2,-8(fp)
 18036b0:	10c00015 	stw	r3,0(r2)
      break;
    }
    qp = qp->h.u.next;
  }

  H_UNLOCK(heapp);
 18036b4:	1803ec80 	call	1803ec8 <chMtxUnlock>
 18036b8:	00000406 	br	18036cc <chHeapFree+0x174>
        qp->h.size += hp->h.size + sizeof(union heap_header);
        qp->h.u.next = hp->h.u.next;
      }
      break;
    }
    qp = qp->h.u.next;
 18036bc:	e0bffe17 	ldw	r2,-8(fp)
 18036c0:	10800017 	ldw	r2,0(r2)
 18036c4:	e0bffe15 	stw	r2,-8(fp)
  }
 18036c8:	003fb406 	br	180359c <chHeapFree+0x44>

  H_UNLOCK(heapp);
  return;
}
 18036cc:	e037883a 	mov	sp,fp
 18036d0:	dfc00117 	ldw	ra,4(sp)
 18036d4:	df000017 	ldw	fp,0(sp)
 18036d8:	dec00204 	addi	sp,sp,8
 18036dc:	f800283a 	ret

018036e0 <chHeapStatus>:
 *                      fragmented free space
 * @return              The number of fragments in the heap.
 *
 * @api
 */
size_t chHeapStatus(MemoryHeap *heapp, size_t *sizep) {
 18036e0:	defff904 	addi	sp,sp,-28
 18036e4:	dfc00615 	stw	ra,24(sp)
 18036e8:	df000515 	stw	fp,20(sp)
 18036ec:	df000504 	addi	fp,sp,20
 18036f0:	e13ffe15 	stw	r4,-8(fp)
 18036f4:	e17fff15 	stw	r5,-4(fp)
  union heap_header *qp;
  size_t n, sz;

  if (heapp == NULL)
 18036f8:	e0bffe17 	ldw	r2,-8(fp)
 18036fc:	1004c03a 	cmpne	r2,r2,zero
 1803700:	1000031e 	bne	r2,zero,1803710 <chHeapStatus+0x30>
    heapp = &default_heap;
 1803704:	00806074 	movhi	r2,385
 1803708:	10b2aa04 	addi	r2,r2,-13656
 180370c:	e0bffe15 	stw	r2,-8(fp)

  H_LOCK(heapp);
 1803710:	e0bffe17 	ldw	r2,-8(fp)
 1803714:	11000304 	addi	r4,r2,12
 1803718:	1803b480 	call	1803b48 <chMtxLock>

  sz = 0;
 180371c:	e03ffb15 	stw	zero,-20(fp)
  for (n = 0, qp = &heapp->h_free; qp->h.u.next; n++, qp = qp->h.u.next)
 1803720:	e03ffc15 	stw	zero,-16(fp)
 1803724:	e0bffe17 	ldw	r2,-8(fp)
 1803728:	10800104 	addi	r2,r2,4
 180372c:	e0bffd15 	stw	r2,-12(fp)
 1803730:	00000c06 	br	1803764 <chHeapStatus+0x84>
    sz += qp->h.u.next->h.size;
 1803734:	e0bffd17 	ldw	r2,-12(fp)
 1803738:	10800017 	ldw	r2,0(r2)
 180373c:	10c00117 	ldw	r3,4(r2)
 1803740:	e0bffb17 	ldw	r2,-20(fp)
 1803744:	10c5883a 	add	r2,r2,r3
 1803748:	e0bffb15 	stw	r2,-20(fp)
    heapp = &default_heap;

  H_LOCK(heapp);

  sz = 0;
  for (n = 0, qp = &heapp->h_free; qp->h.u.next; n++, qp = qp->h.u.next)
 180374c:	e0bffc17 	ldw	r2,-16(fp)
 1803750:	10800044 	addi	r2,r2,1
 1803754:	e0bffc15 	stw	r2,-16(fp)
 1803758:	e0bffd17 	ldw	r2,-12(fp)
 180375c:	10800017 	ldw	r2,0(r2)
 1803760:	e0bffd15 	stw	r2,-12(fp)
 1803764:	e0bffd17 	ldw	r2,-12(fp)
 1803768:	10800017 	ldw	r2,0(r2)
 180376c:	1004c03a 	cmpne	r2,r2,zero
 1803770:	103ff01e 	bne	r2,zero,1803734 <chHeapStatus+0x54>
    sz += qp->h.u.next->h.size;
  if (sizep)
 1803774:	e0bfff17 	ldw	r2,-4(fp)
 1803778:	1005003a 	cmpeq	r2,r2,zero
 180377c:	1000031e 	bne	r2,zero,180378c <chHeapStatus+0xac>
    *sizep = sz;
 1803780:	e0ffff17 	ldw	r3,-4(fp)
 1803784:	e0bffb17 	ldw	r2,-20(fp)
 1803788:	18800015 	stw	r2,0(r3)

  H_UNLOCK(heapp);
 180378c:	1803ec80 	call	1803ec8 <chMtxUnlock>
  return n;
 1803790:	e0bffc17 	ldw	r2,-16(fp)
}
 1803794:	e037883a 	mov	sp,fp
 1803798:	dfc00117 	ldw	ra,4(sp)
 180379c:	df000017 	ldw	fp,0(sp)
 18037a0:	dec00204 	addi	sp,sp,8
 18037a4:	f800283a 	ret

018037a8 <_core_init>:
/**
 * @brief   Low level memory manager initialization.
 *
 * @notapi
 */
void _core_init(void) {
 18037a8:	deffff04 	addi	sp,sp,-4
 18037ac:	df000015 	stw	fp,0(sp)
 18037b0:	d839883a 	mov	fp,sp
#if CH_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];
  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
 18037b4:	00806074 	movhi	r2,385
 18037b8:	10b3ed04 	addi	r2,r2,-12364
 18037bc:	10c000c4 	addi	r3,r2,3
 18037c0:	00bfff04 	movi	r2,-4
 18037c4:	1884703a 	and	r2,r3,r2
 18037c8:	d0a6d415 	stw	r2,-25776(gp)
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
 18037cc:	00808034 	movhi	r2,512
 18037d0:	10800004 	addi	r2,r2,0
 18037d4:	1007883a 	mov	r3,r2
 18037d8:	00bfff04 	movi	r2,-4
 18037dc:	1884703a 	and	r2,r3,r2
 18037e0:	d0a6d515 	stw	r2,-25772(gp)
#else
  static stkalign_t buffer[MEM_ALIGN_NEXT(CH_MEMCORE_SIZE)/MEM_ALIGN_SIZE];
  nextmem = (uint8_t *)&buffer[0];
  endmem = (uint8_t *)&buffer[MEM_ALIGN_NEXT(CH_MEMCORE_SIZE)/MEM_ALIGN_SIZE];
#endif
}
 18037e4:	e037883a 	mov	sp,fp
 18037e8:	df000017 	ldw	fp,0(sp)
 18037ec:	dec00104 	addi	sp,sp,4
 18037f0:	f800283a 	ret

018037f4 <chCoreAlloc>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAlloc(size_t size) {
 18037f4:	defffa04 	addi	sp,sp,-24
 18037f8:	dfc00515 	stw	ra,20(sp)
 18037fc:	df000415 	stw	fp,16(sp)
 1803800:	df000404 	addi	fp,sp,16
 1803804:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 1803808:	0005303a 	rdctl	r2,status
 180380c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 1803810:	e0fffd17 	ldw	r3,-12(fp)
 1803814:	00bfff84 	movi	r2,-2
 1803818:	1884703a 	and	r2,r3,r2
 180381c:	1001703a 	wrctl	status,r2
  void *p;

  chSysLock();
  p = chCoreAllocI(size);
 1803820:	e13fff17 	ldw	r4,-4(fp)
 1803824:	18038540 	call	1803854 <chCoreAllocI>
 1803828:	e0bffe15 	stw	r2,-8(fp)
 180382c:	00800044 	movi	r2,1
 1803830:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 1803834:	e0bffc17 	ldw	r2,-16(fp)
 1803838:	1001703a 	wrctl	status,r2
  chSysUnlock();
  return p;
 180383c:	e0bffe17 	ldw	r2,-8(fp)
}
 1803840:	e037883a 	mov	sp,fp
 1803844:	dfc00117 	ldw	ra,4(sp)
 1803848:	df000017 	ldw	fp,0(sp)
 180384c:	dec00204 	addi	sp,sp,8
 1803850:	f800283a 	ret

01803854 <chCoreAllocI>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
void *chCoreAllocI(size_t size) {
 1803854:	defffc04 	addi	sp,sp,-16
 1803858:	df000315 	stw	fp,12(sp)
 180385c:	df000304 	addi	fp,sp,12
 1803860:	e13ffe15 	stw	r4,-8(fp)
  void *p;

  chDbgCheckClassI();

  size = MEM_ALIGN_NEXT(size);
 1803864:	e0bffe17 	ldw	r2,-8(fp)
 1803868:	10c000c4 	addi	r3,r2,3
 180386c:	00bfff04 	movi	r2,-4
 1803870:	1884703a 	and	r2,r3,r2
 1803874:	e0bffe15 	stw	r2,-8(fp)
  if ((size_t)(endmem - nextmem) < size)
 1803878:	d0a6d517 	ldw	r2,-25772(gp)
 180387c:	1007883a 	mov	r3,r2
 1803880:	d0a6d417 	ldw	r2,-25776(gp)
 1803884:	1885c83a 	sub	r2,r3,r2
 1803888:	1007883a 	mov	r3,r2
 180388c:	e0bffe17 	ldw	r2,-8(fp)
 1803890:	1880022e 	bgeu	r3,r2,180389c <chCoreAllocI+0x48>
    return NULL;
 1803894:	e03fff15 	stw	zero,-4(fp)
 1803898:	00000806 	br	18038bc <chCoreAllocI+0x68>
  p = nextmem;
 180389c:	d0a6d417 	ldw	r2,-25776(gp)
 18038a0:	e0bffd15 	stw	r2,-12(fp)
  nextmem += size;
 18038a4:	d0e6d417 	ldw	r3,-25776(gp)
 18038a8:	e0bffe17 	ldw	r2,-8(fp)
 18038ac:	1885883a 	add	r2,r3,r2
 18038b0:	d0a6d415 	stw	r2,-25776(gp)
  return p;
 18038b4:	e0bffd17 	ldw	r2,-12(fp)
 18038b8:	e0bfff15 	stw	r2,-4(fp)
 18038bc:	e0bfff17 	ldw	r2,-4(fp)
}
 18038c0:	e037883a 	mov	sp,fp
 18038c4:	df000017 	ldw	fp,0(sp)
 18038c8:	dec00104 	addi	sp,sp,4
 18038cc:	f800283a 	ret

018038d0 <chCoreStatus>:
 *
 * @return              The size, in bytes, of the free core memory.
 *
 * @api
 */
size_t chCoreStatus(void) {
 18038d0:	deffff04 	addi	sp,sp,-4
 18038d4:	df000015 	stw	fp,0(sp)
 18038d8:	d839883a 	mov	fp,sp

  return (size_t)(endmem - nextmem);
 18038dc:	d0a6d517 	ldw	r2,-25772(gp)
 18038e0:	1007883a 	mov	r3,r2
 18038e4:	d0a6d417 	ldw	r2,-25776(gp)
 18038e8:	1885c83a 	sub	r2,r3,r2
}
 18038ec:	e037883a 	mov	sp,fp
 18038f0:	df000017 	ldw	fp,0(sp)
 18038f4:	dec00104 	addi	sp,sp,4
 18038f8:	f800283a 	ret

018038fc <chPoolInit>:
 *                      @p NULL if the pool is not allowed to grow
 *                      automatically
 *
 * @init
 */
void chPoolInit(MemoryPool *mp, size_t size, memgetfunc_t provider) {
 18038fc:	defffc04 	addi	sp,sp,-16
 1803900:	df000315 	stw	fp,12(sp)
 1803904:	df000304 	addi	fp,sp,12
 1803908:	e13ffd15 	stw	r4,-12(fp)
 180390c:	e17ffe15 	stw	r5,-8(fp)
 1803910:	e1bfff15 	stw	r6,-4(fp)

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)), "chPoolInit");
 1803914:	e0bffd17 	ldw	r2,-12(fp)
 1803918:	1005003a 	cmpeq	r2,r2,zero
 180391c:	1000001e 	bne	r2,zero,1803920 <chPoolInit+0x24>

  mp->mp_next = NULL;
 1803920:	e0bffd17 	ldw	r2,-12(fp)
 1803924:	10000015 	stw	zero,0(r2)
  mp->mp_object_size = MEM_ALIGN_NEXT(size);
 1803928:	e0bffe17 	ldw	r2,-8(fp)
 180392c:	10c000c4 	addi	r3,r2,3
 1803930:	00bfff04 	movi	r2,-4
 1803934:	1886703a 	and	r3,r3,r2
 1803938:	e0bffd17 	ldw	r2,-12(fp)
 180393c:	10c00115 	stw	r3,4(r2)
  mp->mp_provider = provider;
 1803940:	e0fffd17 	ldw	r3,-12(fp)
 1803944:	e0bfff17 	ldw	r2,-4(fp)
 1803948:	18800215 	stw	r2,8(r3)
}
 180394c:	e037883a 	mov	sp,fp
 1803950:	df000017 	ldw	fp,0(sp)
 1803954:	dec00104 	addi	sp,sp,4
 1803958:	f800283a 	ret

0180395c <chPoolAllocI>:
 * @return              The pointer to the allocated object.
 * @retval NULL         if pool is empty.
 *
 * @iclass
 */
void *chPoolAllocI(MemoryPool *mp) {
 180395c:	defffc04 	addi	sp,sp,-16
 1803960:	dfc00315 	stw	ra,12(sp)
 1803964:	df000215 	stw	fp,8(sp)
 1803968:	df000204 	addi	fp,sp,8
 180396c:	e13fff15 	stw	r4,-4(fp)
  void *objp;

  chDbgCheckClassI();
  chDbgCheck(mp != NULL, "chPoolAllocI");

  if ((objp = mp->mp_next) != NULL)
 1803970:	e0bfff17 	ldw	r2,-4(fp)
 1803974:	10800017 	ldw	r2,0(r2)
 1803978:	e0bffe15 	stw	r2,-8(fp)
 180397c:	e0bffe17 	ldw	r2,-8(fp)
 1803980:	1005003a 	cmpeq	r2,r2,zero
 1803984:	1000061e 	bne	r2,zero,18039a0 <chPoolAllocI+0x44>
    mp->mp_next = mp->mp_next->ph_next;
 1803988:	e0bfff17 	ldw	r2,-4(fp)
 180398c:	10800017 	ldw	r2,0(r2)
 1803990:	10c00017 	ldw	r3,0(r2)
 1803994:	e0bfff17 	ldw	r2,-4(fp)
 1803998:	10c00015 	stw	r3,0(r2)
 180399c:	00000a06 	br	18039c8 <chPoolAllocI+0x6c>
  else if (mp->mp_provider != NULL)
 18039a0:	e0bfff17 	ldw	r2,-4(fp)
 18039a4:	10800217 	ldw	r2,8(r2)
 18039a8:	1005003a 	cmpeq	r2,r2,zero
 18039ac:	1000061e 	bne	r2,zero,18039c8 <chPoolAllocI+0x6c>
    objp = mp->mp_provider(mp->mp_object_size);
 18039b0:	e0bfff17 	ldw	r2,-4(fp)
 18039b4:	10c00217 	ldw	r3,8(r2)
 18039b8:	e0bfff17 	ldw	r2,-4(fp)
 18039bc:	11000117 	ldw	r4,4(r2)
 18039c0:	183ee83a 	callr	r3
 18039c4:	e0bffe15 	stw	r2,-8(fp)
  return objp;
 18039c8:	e0bffe17 	ldw	r2,-8(fp)
}
 18039cc:	e037883a 	mov	sp,fp
 18039d0:	dfc00117 	ldw	ra,4(sp)
 18039d4:	df000017 	ldw	fp,0(sp)
 18039d8:	dec00204 	addi	sp,sp,8
 18039dc:	f800283a 	ret

018039e0 <chPoolAlloc>:
 * @return              The pointer to the allocated object.
 * @retval NULL         if pool is empty.
 *
 * @api
 */
void *chPoolAlloc(MemoryPool *mp) {
 18039e0:	defffa04 	addi	sp,sp,-24
 18039e4:	dfc00515 	stw	ra,20(sp)
 18039e8:	df000415 	stw	fp,16(sp)
 18039ec:	df000404 	addi	fp,sp,16
 18039f0:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 18039f4:	0005303a 	rdctl	r2,status
 18039f8:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 18039fc:	e0fffd17 	ldw	r3,-12(fp)
 1803a00:	00bfff84 	movi	r2,-2
 1803a04:	1884703a 	and	r2,r3,r2
 1803a08:	1001703a 	wrctl	status,r2
  void *objp;

  chSysLock();
  objp = chPoolAllocI(mp);
 1803a0c:	e13fff17 	ldw	r4,-4(fp)
 1803a10:	180395c0 	call	180395c <chPoolAllocI>
 1803a14:	e0bffe15 	stw	r2,-8(fp)
 1803a18:	00800044 	movi	r2,1
 1803a1c:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 1803a20:	e0bffc17 	ldw	r2,-16(fp)
 1803a24:	1001703a 	wrctl	status,r2
  chSysUnlock();
  return objp;
 1803a28:	e0bffe17 	ldw	r2,-8(fp)
}
 1803a2c:	e037883a 	mov	sp,fp
 1803a30:	dfc00117 	ldw	ra,4(sp)
 1803a34:	df000017 	ldw	fp,0(sp)
 1803a38:	dec00204 	addi	sp,sp,8
 1803a3c:	f800283a 	ret

01803a40 <chPoolFreeI>:
 * @param[in] mp        pointer to a @p MemoryPool structure
 * @param[in] objp      the pointer to the object to be released or added
 *
 * @iclass
 */
void chPoolFreeI(MemoryPool *mp, void *objp) {
 1803a40:	defffc04 	addi	sp,sp,-16
 1803a44:	df000315 	stw	fp,12(sp)
 1803a48:	df000304 	addi	fp,sp,12
 1803a4c:	e13ffe15 	stw	r4,-8(fp)
 1803a50:	e17fff15 	stw	r5,-4(fp)
  struct pool_header *php = objp;
 1803a54:	e0bfff17 	ldw	r2,-4(fp)
 1803a58:	e0bffd15 	stw	r2,-12(fp)

  chDbgCheckClassI();
  chDbgCheck((mp != NULL) && (objp != NULL) && MEM_IS_ALIGNED(objp),
 1803a5c:	e0bffe17 	ldw	r2,-8(fp)
 1803a60:	1005003a 	cmpeq	r2,r2,zero
 1803a64:	1000031e 	bne	r2,zero,1803a74 <chPoolFreeI+0x34>
 1803a68:	e0bfff17 	ldw	r2,-4(fp)
 1803a6c:	1005003a 	cmpeq	r2,r2,zero
 1803a70:	1000001e 	bne	r2,zero,1803a74 <chPoolFreeI+0x34>
             "chPoolFreeI");

  php->ph_next = mp->mp_next;
 1803a74:	e0bffe17 	ldw	r2,-8(fp)
 1803a78:	10c00017 	ldw	r3,0(r2)
 1803a7c:	e0bffd17 	ldw	r2,-12(fp)
 1803a80:	10c00015 	stw	r3,0(r2)
  mp->mp_next = php;
 1803a84:	e0fffe17 	ldw	r3,-8(fp)
 1803a88:	e0bffd17 	ldw	r2,-12(fp)
 1803a8c:	18800015 	stw	r2,0(r3)
}
 1803a90:	e037883a 	mov	sp,fp
 1803a94:	df000017 	ldw	fp,0(sp)
 1803a98:	dec00104 	addi	sp,sp,4
 1803a9c:	f800283a 	ret

01803aa0 <chPoolFree>:
 * @param[in] mp        pointer to a @p MemoryPool structure
 * @param[in] objp      the pointer to the object to be released or added
 *
 * @api
 */
void chPoolFree(MemoryPool *mp, void *objp) {
 1803aa0:	defffa04 	addi	sp,sp,-24
 1803aa4:	dfc00515 	stw	ra,20(sp)
 1803aa8:	df000415 	stw	fp,16(sp)
 1803aac:	df000404 	addi	fp,sp,16
 1803ab0:	e13ffe15 	stw	r4,-8(fp)
 1803ab4:	e17fff15 	stw	r5,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 1803ab8:	0005303a 	rdctl	r2,status
 1803abc:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 1803ac0:	e0fffd17 	ldw	r3,-12(fp)
 1803ac4:	00bfff84 	movi	r2,-2
 1803ac8:	1884703a 	and	r2,r3,r2
 1803acc:	1001703a 	wrctl	status,r2

  chSysLock();
  chPoolFreeI(mp, objp);
 1803ad0:	e13ffe17 	ldw	r4,-8(fp)
 1803ad4:	e17fff17 	ldw	r5,-4(fp)
 1803ad8:	1803a400 	call	1803a40 <chPoolFreeI>
 1803adc:	00800044 	movi	r2,1
 1803ae0:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 1803ae4:	e0bffc17 	ldw	r2,-16(fp)
 1803ae8:	1001703a 	wrctl	status,r2
  chSysUnlock();
}
 1803aec:	e037883a 	mov	sp,fp
 1803af0:	dfc00117 	ldw	ra,4(sp)
 1803af4:	df000017 	ldw	fp,0(sp)
 1803af8:	dec00204 	addi	sp,sp,8
 1803afc:	f800283a 	ret

01803b00 <chMtxInit>:
 *
 * @param[out] mp       pointer to a @p Mutex structure
 *
 * @init
 */
void chMtxInit(Mutex *mp) {
 1803b00:	defffe04 	addi	sp,sp,-8
 1803b04:	df000115 	stw	fp,4(sp)
 1803b08:	df000104 	addi	fp,sp,4
 1803b0c:	e13fff15 	stw	r4,-4(fp)

  chDbgCheck(mp != NULL, "chMtxInit");

  queue_init(&mp->m_queue);
 1803b10:	e0bfff17 	ldw	r2,-4(fp)
 1803b14:	1007883a 	mov	r3,r2
 1803b18:	e0bfff17 	ldw	r2,-4(fp)
 1803b1c:	10c00115 	stw	r3,4(r2)
 1803b20:	e0bfff17 	ldw	r2,-4(fp)
 1803b24:	10c00117 	ldw	r3,4(r2)
 1803b28:	e0bfff17 	ldw	r2,-4(fp)
 1803b2c:	10c00015 	stw	r3,0(r2)
  mp->m_owner = NULL;
 1803b30:	e0bfff17 	ldw	r2,-4(fp)
 1803b34:	10000215 	stw	zero,8(r2)
}
 1803b38:	e037883a 	mov	sp,fp
 1803b3c:	df000017 	ldw	fp,0(sp)
 1803b40:	dec00104 	addi	sp,sp,4
 1803b44:	f800283a 	ret

01803b48 <chMtxLock>:
 *
 * @param[in] mp        pointer to the @p Mutex structure
 *
 * @api
 */
void chMtxLock(Mutex *mp) {
 1803b48:	defffb04 	addi	sp,sp,-20
 1803b4c:	dfc00415 	stw	ra,16(sp)
 1803b50:	df000315 	stw	fp,12(sp)
 1803b54:	df000304 	addi	fp,sp,12
 1803b58:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 1803b5c:	0005303a 	rdctl	r2,status
 1803b60:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 1803b64:	e0fffe17 	ldw	r3,-8(fp)
 1803b68:	00bfff84 	movi	r2,-2
 1803b6c:	1884703a 	and	r2,r3,r2
 1803b70:	1001703a 	wrctl	status,r2

  chSysLock();

  chMtxLockS(mp);
 1803b74:	e13fff17 	ldw	r4,-4(fp)
 1803b78:	1803ba00 	call	1803ba0 <chMtxLockS>
 1803b7c:	00800044 	movi	r2,1
 1803b80:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 1803b84:	e0bffd17 	ldw	r2,-12(fp)
 1803b88:	1001703a 	wrctl	status,r2

  chSysUnlock();
}
 1803b8c:	e037883a 	mov	sp,fp
 1803b90:	dfc00117 	ldw	ra,4(sp)
 1803b94:	df000017 	ldw	fp,0(sp)
 1803b98:	dec00204 	addi	sp,sp,8
 1803b9c:	f800283a 	ret

01803ba0 <chMtxLockS>:
 *
 * @param[in] mp        pointer to the @p Mutex structure
 *
 * @sclass
 */
void chMtxLockS(Mutex *mp) {
 1803ba0:	defffa04 	addi	sp,sp,-24
 1803ba4:	dfc00515 	stw	ra,20(sp)
 1803ba8:	df000415 	stw	fp,16(sp)
 1803bac:	df000404 	addi	fp,sp,16
 1803bb0:	e13ffe15 	stw	r4,-8(fp)
  Thread *ctp = currp;
 1803bb4:	00806074 	movhi	r2,385
 1803bb8:	10b2d104 	addi	r2,r2,-13500
 1803bbc:	10800717 	ldw	r2,28(r2)
 1803bc0:	e0bffd15 	stw	r2,-12(fp)

  chDbgCheckClassS();
  chDbgCheck(mp != NULL, "chMtxLockS");

  /* Ia the mutex already locked? */
  if (mp->m_owner != NULL) {
 1803bc4:	e0bffe17 	ldw	r2,-8(fp)
 1803bc8:	10800217 	ldw	r2,8(r2)
 1803bcc:	1005003a 	cmpeq	r2,r2,zero
 1803bd0:	10003d1e 	bne	r2,zero,1803cc8 <chMtxLockS+0x128>
    /* Priority inheritance protocol; explores the thread-mutex dependencies
       boosting the priority of all the affected threads to equal the priority
       of the running thread requesting the mutex.*/
    Thread *tp = mp->m_owner;
 1803bd4:	e0bffe17 	ldw	r2,-8(fp)
 1803bd8:	10800217 	ldw	r2,8(r2)
 1803bdc:	e0bffc15 	stw	r2,-16(fp)
    /* Does the running thread have higher priority than the mutex
       ownning thread? */
    while (tp->p_prio < ctp->p_prio) {
 1803be0:	00002b06 	br	1803c90 <chMtxLockS+0xf0>
      /* Make priority of thread tp match the running thread's priority.*/
      tp->p_prio = ctp->p_prio;
 1803be4:	e0bffd17 	ldw	r2,-12(fp)
 1803be8:	10c00217 	ldw	r3,8(r2)
 1803bec:	e0bffc17 	ldw	r2,-16(fp)
 1803bf0:	10c00215 	stw	r3,8(r2)
      /* The following states need priority queues reordering.*/
      switch (tp->p_state) {
 1803bf4:	e0bffc17 	ldw	r2,-16(fp)
 1803bf8:	10800703 	ldbu	r2,28(r2)
 1803bfc:	10803fcc 	andi	r2,r2,255
 1803c00:	e0bfff15 	stw	r2,-4(fp)
 1803c04:	e0ffff17 	ldw	r3,-4(fp)
 1803c08:	18800120 	cmpeqi	r2,r3,4
 1803c0c:	1000071e 	bne	r2,zero,1803c2c <chMtxLockS+0x8c>
 1803c10:	e0ffff17 	ldw	r3,-4(fp)
 1803c14:	18800160 	cmpeqi	r2,r3,5
 1803c18:	1000101e 	bne	r2,zero,1803c5c <chMtxLockS+0xbc>
 1803c1c:	e0ffff17 	ldw	r3,-4(fp)
 1803c20:	1805003a 	cmpeq	r2,r3,zero
 1803c24:	1000151e 	bne	r2,zero,1803c7c <chMtxLockS+0xdc>
 1803c28:	00001e06 	br	1803ca4 <chMtxLockS+0x104>
      case THD_STATE_WTMTX:
        /* Re-enqueues the mutex owner with its new priority.*/
        prio_insert(dequeue(tp), (ThreadsQueue *)tp->p_u.wtobjp);
 1803c2c:	e13ffc17 	ldw	r4,-16(fp)
 1803c30:	1803d040 	call	1803d04 <dequeue>
 1803c34:	1009883a 	mov	r4,r2
 1803c38:	e0bffc17 	ldw	r2,-16(fp)
 1803c3c:	10800917 	ldw	r2,36(r2)
 1803c40:	100b883a 	mov	r5,r2
 1803c44:	1803d500 	call	1803d50 <prio_insert>
        tp = ((Mutex *)tp->p_u.wtobjp)->m_owner;
 1803c48:	e0bffc17 	ldw	r2,-16(fp)
 1803c4c:	10800917 	ldw	r2,36(r2)
 1803c50:	10800217 	ldw	r2,8(r2)
 1803c54:	e0bffc15 	stw	r2,-16(fp)
        continue;
 1803c58:	00000d06 	br	1803c90 <chMtxLockS+0xf0>
#endif
#if CH_USE_MESSAGES && CH_USE_MESSAGES_PRIORITY
      case THD_STATE_SNDMSGQ:
#endif
        /* Re-enqueues tp with its new priority on the queue.*/
        prio_insert(dequeue(tp), (ThreadsQueue *)tp->p_u.wtobjp);
 1803c5c:	e13ffc17 	ldw	r4,-16(fp)
 1803c60:	1803d040 	call	1803d04 <dequeue>
 1803c64:	1009883a 	mov	r4,r2
 1803c68:	e0bffc17 	ldw	r2,-16(fp)
 1803c6c:	10800917 	ldw	r2,36(r2)
 1803c70:	100b883a 	mov	r5,r2
 1803c74:	1803d500 	call	1803d50 <prio_insert>
        break;
 1803c78:	00000a06 	br	1803ca4 <chMtxLockS+0x104>
#if CH_DBG_ENABLE_ASSERTS
        /* Prevents an assertion in chSchReadyI().*/
        tp->p_state = THD_STATE_CURRENT;
#endif
        /* Re-enqueues tp with its new priority on the ready list.*/
        chSchReadyI(dequeue(tp));
 1803c7c:	e13ffc17 	ldw	r4,-16(fp)
 1803c80:	1803d040 	call	1803d04 <dequeue>
 1803c84:	1009883a 	mov	r4,r2
 1803c88:	18043180 	call	1804318 <chSchReadyI>
        break;
      }
      break;
 1803c8c:	00000506 	br	1803ca4 <chMtxLockS+0x104>
       boosting the priority of all the affected threads to equal the priority
       of the running thread requesting the mutex.*/
    Thread *tp = mp->m_owner;
    /* Does the running thread have higher priority than the mutex
       ownning thread? */
    while (tp->p_prio < ctp->p_prio) {
 1803c90:	e0bffc17 	ldw	r2,-16(fp)
 1803c94:	10c00217 	ldw	r3,8(r2)
 1803c98:	e0bffd17 	ldw	r2,-12(fp)
 1803c9c:	10800217 	ldw	r2,8(r2)
 1803ca0:	18bfd036 	bltu	r3,r2,1803be4 <chMtxLockS+0x44>
        break;
      }
      break;
    }
    /* Sleep on the mutex.*/
    prio_insert(ctp, &mp->m_queue);
 1803ca4:	e17ffe17 	ldw	r5,-8(fp)
 1803ca8:	e13ffd17 	ldw	r4,-12(fp)
 1803cac:	1803d500 	call	1803d50 <prio_insert>
    ctp->p_u.wtobjp = mp;
 1803cb0:	e0fffd17 	ldw	r3,-12(fp)
 1803cb4:	e0bffe17 	ldw	r2,-8(fp)
 1803cb8:	18800915 	stw	r2,36(r3)
    chSchGoSleepS(THD_STATE_WTMTX);
 1803cbc:	01000104 	movi	r4,4
 1803cc0:	18043c00 	call	18043c0 <chSchGoSleepS>
    /* It is assumed that the thread performing the unlock operation assigns
       the mutex to this thread.*/
    chDbgAssert(mp->m_owner == ctp, "chMtxLockS(), #1", "not owner");
    chDbgAssert(ctp->p_mtxlist == mp, "chMtxLockS(), #2", "not owned");
 1803cc4:	00000a06 	br	1803cf0 <chMtxLockS+0x150>
  }
  else {
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->m_owner = ctp;
 1803cc8:	e0fffe17 	ldw	r3,-8(fp)
 1803ccc:	e0bffd17 	ldw	r2,-12(fp)
 1803cd0:	18800215 	stw	r2,8(r3)
    mp->m_next = ctp->p_mtxlist;
 1803cd4:	e0bffd17 	ldw	r2,-12(fp)
 1803cd8:	10c00f17 	ldw	r3,60(r2)
 1803cdc:	e0bffe17 	ldw	r2,-8(fp)
 1803ce0:	10c00315 	stw	r3,12(r2)
    ctp->p_mtxlist = mp;
 1803ce4:	e0fffd17 	ldw	r3,-12(fp)
 1803ce8:	e0bffe17 	ldw	r2,-8(fp)
 1803cec:	18800f15 	stw	r2,60(r3)
  }
}
 1803cf0:	e037883a 	mov	sp,fp
 1803cf4:	dfc00117 	ldw	ra,4(sp)
 1803cf8:	df000017 	ldw	fp,0(sp)
 1803cfc:	dec00204 	addi	sp,sp,8
 1803d00:	f800283a 	ret

01803d04 <dequeue>:

  (tqp->p_prev = tp->p_prev)->p_next = (Thread *)tqp;
  return tp;
}

static INLINE Thread *dequeue(Thread *tp) {
 1803d04:	defffe04 	addi	sp,sp,-8
 1803d08:	df000115 	stw	fp,4(sp)
 1803d0c:	df000104 	addi	fp,sp,4
 1803d10:	e13fff15 	stw	r4,-4(fp)

  tp->p_prev->p_next = tp->p_next;
 1803d14:	e0bfff17 	ldw	r2,-4(fp)
 1803d18:	10c00117 	ldw	r3,4(r2)
 1803d1c:	e0bfff17 	ldw	r2,-4(fp)
 1803d20:	10800017 	ldw	r2,0(r2)
 1803d24:	18800015 	stw	r2,0(r3)
  tp->p_next->p_prev = tp->p_prev;
 1803d28:	e0bfff17 	ldw	r2,-4(fp)
 1803d2c:	10c00017 	ldw	r3,0(r2)
 1803d30:	e0bfff17 	ldw	r2,-4(fp)
 1803d34:	10800117 	ldw	r2,4(r2)
 1803d38:	18800115 	stw	r2,4(r3)
  return tp;
 1803d3c:	e0bfff17 	ldw	r2,-4(fp)
}
 1803d40:	e037883a 	mov	sp,fp
 1803d44:	df000017 	ldw	fp,0(sp)
 1803d48:	dec00104 	addi	sp,sp,4
 1803d4c:	f800283a 	ret

01803d50 <prio_insert>:
#define _CHINLINE_H_

/* If the performance code path has been chosen then all the following
   functions are inlined into the various kernel modules.*/
#if CH_OPTIMIZE_SPEED
static INLINE void prio_insert(Thread *tp, ThreadsQueue *tqp) {
 1803d50:	defffc04 	addi	sp,sp,-16
 1803d54:	df000315 	stw	fp,12(sp)
 1803d58:	df000304 	addi	fp,sp,12
 1803d5c:	e13ffe15 	stw	r4,-8(fp)
 1803d60:	e17fff15 	stw	r5,-4(fp)

  Thread *cp = (Thread *)tqp;
 1803d64:	e0bfff17 	ldw	r2,-4(fp)
 1803d68:	e0bffd15 	stw	r2,-12(fp)
  do {
    cp = cp->p_next;
 1803d6c:	e0bffd17 	ldw	r2,-12(fp)
 1803d70:	10800017 	ldw	r2,0(r2)
 1803d74:	e0bffd15 	stw	r2,-12(fp)
  } while ((cp != (Thread *)tqp) && (cp->p_prio >= tp->p_prio));
 1803d78:	e0ffff17 	ldw	r3,-4(fp)
 1803d7c:	e0bffd17 	ldw	r2,-12(fp)
 1803d80:	10c00526 	beq	r2,r3,1803d98 <prio_insert+0x48>
 1803d84:	e0bffd17 	ldw	r2,-12(fp)
 1803d88:	10c00217 	ldw	r3,8(r2)
 1803d8c:	e0bffe17 	ldw	r2,-8(fp)
 1803d90:	10800217 	ldw	r2,8(r2)
 1803d94:	18bff52e 	bgeu	r3,r2,1803d6c <prio_insert+0x1c>
  tp->p_next = cp;
 1803d98:	e0fffe17 	ldw	r3,-8(fp)
 1803d9c:	e0bffd17 	ldw	r2,-12(fp)
 1803da0:	18800015 	stw	r2,0(r3)
  tp->p_prev = cp->p_prev;
 1803da4:	e0bffd17 	ldw	r2,-12(fp)
 1803da8:	10c00117 	ldw	r3,4(r2)
 1803dac:	e0bffe17 	ldw	r2,-8(fp)
 1803db0:	10c00115 	stw	r3,4(r2)
  tp->p_prev->p_next = cp->p_prev = tp;
 1803db4:	e0bffe17 	ldw	r2,-8(fp)
 1803db8:	11000117 	ldw	r4,4(r2)
 1803dbc:	e0fffd17 	ldw	r3,-12(fp)
 1803dc0:	e0bffe17 	ldw	r2,-8(fp)
 1803dc4:	18800115 	stw	r2,4(r3)
 1803dc8:	e0bffd17 	ldw	r2,-12(fp)
 1803dcc:	10800117 	ldw	r2,4(r2)
 1803dd0:	20800015 	stw	r2,0(r4)
}
 1803dd4:	e037883a 	mov	sp,fp
 1803dd8:	df000017 	ldw	fp,0(sp)
 1803ddc:	dec00104 	addi	sp,sp,4
 1803de0:	f800283a 	ret

01803de4 <chMtxTryLock>:
 * @retval TRUE         if the mutex has been successfully acquired
 * @retval FALSE        if the lock attempt failed.
 *
 * @api
 */
bool_t chMtxTryLock(Mutex *mp) {
 1803de4:	defffa04 	addi	sp,sp,-24
 1803de8:	dfc00515 	stw	ra,20(sp)
 1803dec:	df000415 	stw	fp,16(sp)
 1803df0:	df000404 	addi	fp,sp,16
 1803df4:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 1803df8:	0005303a 	rdctl	r2,status
 1803dfc:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 1803e00:	e0fffd17 	ldw	r3,-12(fp)
 1803e04:	00bfff84 	movi	r2,-2
 1803e08:	1884703a 	and	r2,r3,r2
 1803e0c:	1001703a 	wrctl	status,r2
  bool_t b;

  chSysLock();

  b = chMtxTryLockS(mp);
 1803e10:	e13fff17 	ldw	r4,-4(fp)
 1803e14:	1803e440 	call	1803e44 <chMtxTryLockS>
 1803e18:	e0bffe15 	stw	r2,-8(fp)
 1803e1c:	00800044 	movi	r2,1
 1803e20:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 1803e24:	e0bffc17 	ldw	r2,-16(fp)
 1803e28:	1001703a 	wrctl	status,r2

  chSysUnlock();
  return b;
 1803e2c:	e0bffe17 	ldw	r2,-8(fp)
}
 1803e30:	e037883a 	mov	sp,fp
 1803e34:	dfc00117 	ldw	ra,4(sp)
 1803e38:	df000017 	ldw	fp,0(sp)
 1803e3c:	dec00204 	addi	sp,sp,8
 1803e40:	f800283a 	ret

01803e44 <chMtxTryLockS>:
 * @retval TRUE         if the mutex has been successfully acquired
 * @retval FALSE        if the lock attempt failed.
 *
 * @sclass
 */
bool_t chMtxTryLockS(Mutex *mp) {
 1803e44:	defffd04 	addi	sp,sp,-12
 1803e48:	df000215 	stw	fp,8(sp)
 1803e4c:	df000204 	addi	fp,sp,8
 1803e50:	e13ffe15 	stw	r4,-8(fp)

  chDbgCheckClassS();
  chDbgCheck(mp != NULL, "chMtxTryLockS");

  if (mp->m_owner != NULL)
 1803e54:	e0bffe17 	ldw	r2,-8(fp)
 1803e58:	10800217 	ldw	r2,8(r2)
 1803e5c:	1005003a 	cmpeq	r2,r2,zero
 1803e60:	1000021e 	bne	r2,zero,1803e6c <chMtxTryLockS+0x28>
    return FALSE;
 1803e64:	e03fff15 	stw	zero,-4(fp)
 1803e68:	00001206 	br	1803eb4 <chMtxTryLockS+0x70>
  mp->m_owner = currp;
 1803e6c:	00806074 	movhi	r2,385
 1803e70:	10b2d104 	addi	r2,r2,-13500
 1803e74:	10c00717 	ldw	r3,28(r2)
 1803e78:	e0bffe17 	ldw	r2,-8(fp)
 1803e7c:	10c00215 	stw	r3,8(r2)
  mp->m_next = currp->p_mtxlist;
 1803e80:	00806074 	movhi	r2,385
 1803e84:	10b2d104 	addi	r2,r2,-13500
 1803e88:	10800717 	ldw	r2,28(r2)
 1803e8c:	10c00f17 	ldw	r3,60(r2)
 1803e90:	e0bffe17 	ldw	r2,-8(fp)
 1803e94:	10c00315 	stw	r3,12(r2)
  currp->p_mtxlist = mp;
 1803e98:	00806074 	movhi	r2,385
 1803e9c:	10b2d104 	addi	r2,r2,-13500
 1803ea0:	10c00717 	ldw	r3,28(r2)
 1803ea4:	e0bffe17 	ldw	r2,-8(fp)
 1803ea8:	18800f15 	stw	r2,60(r3)
  return TRUE;
 1803eac:	00800044 	movi	r2,1
 1803eb0:	e0bfff15 	stw	r2,-4(fp)
 1803eb4:	e0bfff17 	ldw	r2,-4(fp)
}
 1803eb8:	e037883a 	mov	sp,fp
 1803ebc:	df000017 	ldw	fp,0(sp)
 1803ec0:	dec00104 	addi	sp,sp,4
 1803ec4:	f800283a 	ret

01803ec8 <chMtxUnlock>:
 *
 * @return              A pointer to the unlocked mutex.
 *
 * @api
 */
Mutex *chMtxUnlock(void) {
 1803ec8:	defff704 	addi	sp,sp,-36
 1803ecc:	dfc00815 	stw	ra,32(sp)
 1803ed0:	df000715 	stw	fp,28(sp)
 1803ed4:	df000704 	addi	fp,sp,28
  Thread *ctp = currp;
 1803ed8:	00806074 	movhi	r2,385
 1803edc:	10b2d104 	addi	r2,r2,-13500
 1803ee0:	10800717 	ldw	r2,28(r2)
 1803ee4:	e0bfff15 	stw	r2,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 1803ee8:	0005303a 	rdctl	r2,status
 1803eec:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 1803ef0:	e0fffa17 	ldw	r3,-24(fp)
 1803ef4:	00bfff84 	movi	r2,-2
 1803ef8:	1884703a 	and	r2,r3,r2
 1803efc:	1001703a 	wrctl	status,r2
  chDbgAssert(ctp->p_mtxlist->m_owner == ctp,
              "chMtxUnlock(), #2",
              "ownership failure");
  /* Removes the top Mutex from the Threads's owned mutexes list and matk it
     as not owned.*/
  ump = ctp->p_mtxlist;
 1803f00:	e0bfff17 	ldw	r2,-4(fp)
 1803f04:	10800f17 	ldw	r2,60(r2)
 1803f08:	e0bffe15 	stw	r2,-8(fp)
  ctp->p_mtxlist = ump->m_next;
 1803f0c:	e0bffe17 	ldw	r2,-8(fp)
 1803f10:	10c00317 	ldw	r3,12(r2)
 1803f14:	e0bfff17 	ldw	r2,-4(fp)
 1803f18:	10c00f15 	stw	r3,60(r2)
  /* If a thread is waiting on the mutex then the fun part begins.*/
  if (chMtxQueueNotEmptyS(ump)) {
 1803f1c:	e0bffe17 	ldw	r2,-8(fp)
 1803f20:	10c00017 	ldw	r3,0(r2)
 1803f24:	e0bffe17 	ldw	r2,-8(fp)
 1803f28:	18802e26 	beq	r3,r2,1803fe4 <chMtxUnlock+0x11c>
    Thread *tp;

    /* Recalculates the optimal thread priority by scanning the owned
       mutexes list.*/
    tprio_t newprio = ctp->p_realprio;
 1803f2c:	e0bfff17 	ldw	r2,-4(fp)
 1803f30:	10801017 	ldw	r2,64(r2)
 1803f34:	e0bffb15 	stw	r2,-20(fp)
    mp = ctp->p_mtxlist;
 1803f38:	e0bfff17 	ldw	r2,-4(fp)
 1803f3c:	10800f17 	ldw	r2,60(r2)
 1803f40:	e0bffd15 	stw	r2,-12(fp)
    while (mp != NULL) {
 1803f44:	00001006 	br	1803f88 <chMtxUnlock+0xc0>
      /* If the highest priority thread waiting in the mutexes list has a
         greater priority than the current thread base priority then the final
         priority will have at least that priority.*/
      if (chMtxQueueNotEmptyS(mp) && (mp->m_queue.p_next->p_prio > newprio))
 1803f48:	e0bffd17 	ldw	r2,-12(fp)
 1803f4c:	10c00017 	ldw	r3,0(r2)
 1803f50:	e0bffd17 	ldw	r2,-12(fp)
 1803f54:	18800926 	beq	r3,r2,1803f7c <chMtxUnlock+0xb4>
 1803f58:	e0bffd17 	ldw	r2,-12(fp)
 1803f5c:	10800017 	ldw	r2,0(r2)
 1803f60:	10c00217 	ldw	r3,8(r2)
 1803f64:	e0bffb17 	ldw	r2,-20(fp)
 1803f68:	10c0042e 	bgeu	r2,r3,1803f7c <chMtxUnlock+0xb4>
        newprio = mp->m_queue.p_next->p_prio;
 1803f6c:	e0bffd17 	ldw	r2,-12(fp)
 1803f70:	10800017 	ldw	r2,0(r2)
 1803f74:	10800217 	ldw	r2,8(r2)
 1803f78:	e0bffb15 	stw	r2,-20(fp)
      mp = mp->m_next;
 1803f7c:	e0bffd17 	ldw	r2,-12(fp)
 1803f80:	10800317 	ldw	r2,12(r2)
 1803f84:	e0bffd15 	stw	r2,-12(fp)

    /* Recalculates the optimal thread priority by scanning the owned
       mutexes list.*/
    tprio_t newprio = ctp->p_realprio;
    mp = ctp->p_mtxlist;
    while (mp != NULL) {
 1803f88:	e0bffd17 	ldw	r2,-12(fp)
 1803f8c:	1004c03a 	cmpne	r2,r2,zero
 1803f90:	103fed1e 	bne	r2,zero,1803f48 <chMtxUnlock+0x80>
        newprio = mp->m_queue.p_next->p_prio;
      mp = mp->m_next;
    }
    /* Assigns to the current thread the highest priority among all the
       waiting threads.*/
    ctp->p_prio = newprio;
 1803f94:	e0ffff17 	ldw	r3,-4(fp)
 1803f98:	e0bffb17 	ldw	r2,-20(fp)
 1803f9c:	18800215 	stw	r2,8(r3)
    /* Awakens the highest priority thread waiting for the unlocked mutex and
       assigns the mutex to it.*/
    tp = fifo_remove(&ump->m_queue);
 1803fa0:	e13ffe17 	ldw	r4,-8(fp)
 1803fa4:	18040140 	call	1804014 <fifo_remove>
 1803fa8:	e0bffc15 	stw	r2,-16(fp)
    ump->m_owner = tp;
 1803fac:	e0fffe17 	ldw	r3,-8(fp)
 1803fb0:	e0bffc17 	ldw	r2,-16(fp)
 1803fb4:	18800215 	stw	r2,8(r3)
    ump->m_next = tp->p_mtxlist;
 1803fb8:	e0bffc17 	ldw	r2,-16(fp)
 1803fbc:	10c00f17 	ldw	r3,60(r2)
 1803fc0:	e0bffe17 	ldw	r2,-8(fp)
 1803fc4:	10c00315 	stw	r3,12(r2)
    tp->p_mtxlist = ump;
 1803fc8:	e0fffc17 	ldw	r3,-16(fp)
 1803fcc:	e0bffe17 	ldw	r2,-8(fp)
 1803fd0:	18800f15 	stw	r2,60(r3)
    chSchWakeupS(tp, RDY_OK);
 1803fd4:	e13ffc17 	ldw	r4,-16(fp)
 1803fd8:	000b883a 	mov	r5,zero
 1803fdc:	180463c0 	call	180463c <chSchWakeupS>
 1803fe0:	00000206 	br	1803fec <chMtxUnlock+0x124>
  }
  else
    ump->m_owner = NULL;
 1803fe4:	e0bffe17 	ldw	r2,-8(fp)
 1803fe8:	10000215 	stw	zero,8(r2)
 1803fec:	00800044 	movi	r2,1
 1803ff0:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 1803ff4:	e0bff917 	ldw	r2,-28(fp)
 1803ff8:	1001703a 	wrctl	status,r2
  chSysUnlock();
  return ump;
 1803ffc:	e0bffe17 	ldw	r2,-8(fp)
}
 1804000:	e037883a 	mov	sp,fp
 1804004:	dfc00117 	ldw	ra,4(sp)
 1804008:	df000017 	ldw	fp,0(sp)
 180400c:	dec00204 	addi	sp,sp,8
 1804010:	f800283a 	ret

01804014 <fifo_remove>:
  tp->p_next = (Thread *)tqp;
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tqp->p_prev = tp;
}

static INLINE Thread *fifo_remove(ThreadsQueue *tqp) {
 1804014:	defffd04 	addi	sp,sp,-12
 1804018:	df000215 	stw	fp,8(sp)
 180401c:	df000204 	addi	fp,sp,8
 1804020:	e13fff15 	stw	r4,-4(fp)
  Thread *tp = tqp->p_next;
 1804024:	e0bfff17 	ldw	r2,-4(fp)
 1804028:	10800017 	ldw	r2,0(r2)
 180402c:	e0bffe15 	stw	r2,-8(fp)

  (tqp->p_next = tp->p_next)->p_prev = (Thread *)tqp;
 1804030:	e0bffe17 	ldw	r2,-8(fp)
 1804034:	10c00017 	ldw	r3,0(r2)
 1804038:	e0bfff17 	ldw	r2,-4(fp)
 180403c:	10c00015 	stw	r3,0(r2)
 1804040:	e0bfff17 	ldw	r2,-4(fp)
 1804044:	10c00017 	ldw	r3,0(r2)
 1804048:	e0bfff17 	ldw	r2,-4(fp)
 180404c:	18800115 	stw	r2,4(r3)
  return tp;
 1804050:	e0bffe17 	ldw	r2,-8(fp)
}
 1804054:	e037883a 	mov	sp,fp
 1804058:	df000017 	ldw	fp,0(sp)
 180405c:	dec00104 	addi	sp,sp,4
 1804060:	f800283a 	ret

01804064 <chMtxUnlockS>:
 *
 * @return              A pointer to the unlocked mutex.
 *
 * @sclass
 */
Mutex *chMtxUnlockS(void) {
 1804064:	defff904 	addi	sp,sp,-28
 1804068:	dfc00615 	stw	ra,24(sp)
 180406c:	df000515 	stw	fp,20(sp)
 1804070:	df000504 	addi	fp,sp,20
  Thread *ctp = currp;
 1804074:	00806074 	movhi	r2,385
 1804078:	10b2d104 	addi	r2,r2,-13500
 180407c:	10800717 	ldw	r2,28(r2)
 1804080:	e0bfff15 	stw	r2,-4(fp)
              "chMtxUnlockS(), #2",
              "ownership failure");

  /* Removes the top Mutex from the owned mutexes list and marks it as not
     owned.*/
  ump = ctp->p_mtxlist;
 1804084:	e0bfff17 	ldw	r2,-4(fp)
 1804088:	10800f17 	ldw	r2,60(r2)
 180408c:	e0bffe15 	stw	r2,-8(fp)
  ctp->p_mtxlist = ump->m_next;
 1804090:	e0bffe17 	ldw	r2,-8(fp)
 1804094:	10c00317 	ldw	r3,12(r2)
 1804098:	e0bfff17 	ldw	r2,-4(fp)
 180409c:	10c00f15 	stw	r3,60(r2)
  /* If a thread is waiting on the mutex then the fun part begins.*/
  if (chMtxQueueNotEmptyS(ump)) {
 18040a0:	e0bffe17 	ldw	r2,-8(fp)
 18040a4:	10c00017 	ldw	r3,0(r2)
 18040a8:	e0bffe17 	ldw	r2,-8(fp)
 18040ac:	18802d26 	beq	r3,r2,1804164 <chMtxUnlockS+0x100>
    Thread *tp;

    /* Recalculates the optimal thread priority by scanning the owned
       mutexes list.*/
    tprio_t newprio = ctp->p_realprio;
 18040b0:	e0bfff17 	ldw	r2,-4(fp)
 18040b4:	10801017 	ldw	r2,64(r2)
 18040b8:	e0bffb15 	stw	r2,-20(fp)
    mp = ctp->p_mtxlist;
 18040bc:	e0bfff17 	ldw	r2,-4(fp)
 18040c0:	10800f17 	ldw	r2,60(r2)
 18040c4:	e0bffd15 	stw	r2,-12(fp)
    while (mp != NULL) {
 18040c8:	00001006 	br	180410c <chMtxUnlockS+0xa8>
      /* If the highest priority thread waiting in the mutexes list has a
         greater priority than the current thread base priority then the final
         priority will have at least that priority.*/
      if (chMtxQueueNotEmptyS(mp) && (mp->m_queue.p_next->p_prio > newprio))
 18040cc:	e0bffd17 	ldw	r2,-12(fp)
 18040d0:	10c00017 	ldw	r3,0(r2)
 18040d4:	e0bffd17 	ldw	r2,-12(fp)
 18040d8:	18800926 	beq	r3,r2,1804100 <chMtxUnlockS+0x9c>
 18040dc:	e0bffd17 	ldw	r2,-12(fp)
 18040e0:	10800017 	ldw	r2,0(r2)
 18040e4:	10c00217 	ldw	r3,8(r2)
 18040e8:	e0bffb17 	ldw	r2,-20(fp)
 18040ec:	10c0042e 	bgeu	r2,r3,1804100 <chMtxUnlockS+0x9c>
        newprio = mp->m_queue.p_next->p_prio;
 18040f0:	e0bffd17 	ldw	r2,-12(fp)
 18040f4:	10800017 	ldw	r2,0(r2)
 18040f8:	10800217 	ldw	r2,8(r2)
 18040fc:	e0bffb15 	stw	r2,-20(fp)
      mp = mp->m_next;
 1804100:	e0bffd17 	ldw	r2,-12(fp)
 1804104:	10800317 	ldw	r2,12(r2)
 1804108:	e0bffd15 	stw	r2,-12(fp)

    /* Recalculates the optimal thread priority by scanning the owned
       mutexes list.*/
    tprio_t newprio = ctp->p_realprio;
    mp = ctp->p_mtxlist;
    while (mp != NULL) {
 180410c:	e0bffd17 	ldw	r2,-12(fp)
 1804110:	1004c03a 	cmpne	r2,r2,zero
 1804114:	103fed1e 	bne	r2,zero,18040cc <chMtxUnlockS+0x68>
         priority will have at least that priority.*/
      if (chMtxQueueNotEmptyS(mp) && (mp->m_queue.p_next->p_prio > newprio))
        newprio = mp->m_queue.p_next->p_prio;
      mp = mp->m_next;
    }
    ctp->p_prio = newprio;
 1804118:	e0ffff17 	ldw	r3,-4(fp)
 180411c:	e0bffb17 	ldw	r2,-20(fp)
 1804120:	18800215 	stw	r2,8(r3)
    /* Awakens the highest priority thread waiting for the unlocked mutex and
       assigns the mutex to it.*/
    tp = fifo_remove(&ump->m_queue);
 1804124:	e13ffe17 	ldw	r4,-8(fp)
 1804128:	18040140 	call	1804014 <fifo_remove>
 180412c:	e0bffc15 	stw	r2,-16(fp)
    ump->m_owner = tp;
 1804130:	e0fffe17 	ldw	r3,-8(fp)
 1804134:	e0bffc17 	ldw	r2,-16(fp)
 1804138:	18800215 	stw	r2,8(r3)
    ump->m_next = tp->p_mtxlist;
 180413c:	e0bffc17 	ldw	r2,-16(fp)
 1804140:	10c00f17 	ldw	r3,60(r2)
 1804144:	e0bffe17 	ldw	r2,-8(fp)
 1804148:	10c00315 	stw	r3,12(r2)
    tp->p_mtxlist = ump;
 180414c:	e0fffc17 	ldw	r3,-16(fp)
 1804150:	e0bffe17 	ldw	r2,-8(fp)
 1804154:	18800f15 	stw	r2,60(r3)
    chSchReadyI(tp);
 1804158:	e13ffc17 	ldw	r4,-16(fp)
 180415c:	18043180 	call	1804318 <chSchReadyI>
 1804160:	00000206 	br	180416c <chMtxUnlockS+0x108>
  }
  else
    ump->m_owner = NULL;
 1804164:	e0bffe17 	ldw	r2,-8(fp)
 1804168:	10000215 	stw	zero,8(r2)
  return ump;
 180416c:	e0bffe17 	ldw	r2,-8(fp)
}
 1804170:	e037883a 	mov	sp,fp
 1804174:	dfc00117 	ldw	ra,4(sp)
 1804178:	df000017 	ldw	fp,0(sp)
 180417c:	dec00204 	addi	sp,sp,8
 1804180:	f800283a 	ret

01804184 <chMtxUnlockAll>:
 *          this function does not have any overhead related to the priority
 *          inheritance mechanism.
 *
 * @api
 */
void chMtxUnlockAll(void) {
 1804184:	defff904 	addi	sp,sp,-28
 1804188:	dfc00615 	stw	ra,24(sp)
 180418c:	df000515 	stw	fp,20(sp)
 1804190:	df000504 	addi	fp,sp,20
  Thread *ctp = currp;
 1804194:	00806074 	movhi	r2,385
 1804198:	10b2d104 	addi	r2,r2,-13500
 180419c:	10800717 	ldw	r2,28(r2)
 18041a0:	e0bfff15 	stw	r2,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 18041a4:	0005303a 	rdctl	r2,status
 18041a8:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 18041ac:	e0fffc17 	ldw	r3,-16(fp)
 18041b0:	00bfff84 	movi	r2,-2
 18041b4:	1884703a 	and	r2,r3,r2
 18041b8:	1001703a 	wrctl	status,r2

  chSysLock();
  if (ctp->p_mtxlist != NULL) {
 18041bc:	e0bfff17 	ldw	r2,-4(fp)
 18041c0:	10800f17 	ldw	r2,60(r2)
 18041c4:	1005003a 	cmpeq	r2,r2,zero
 18041c8:	1000261e 	bne	r2,zero,1804264 <chMtxUnlockAll+0xe0>
    do {
      Mutex *ump = ctp->p_mtxlist;
 18041cc:	e0bfff17 	ldw	r2,-4(fp)
 18041d0:	10800f17 	ldw	r2,60(r2)
 18041d4:	e0bffe15 	stw	r2,-8(fp)
      ctp->p_mtxlist = ump->m_next;
 18041d8:	e0bffe17 	ldw	r2,-8(fp)
 18041dc:	10c00317 	ldw	r3,12(r2)
 18041e0:	e0bfff17 	ldw	r2,-4(fp)
 18041e4:	10c00f15 	stw	r3,60(r2)
      if (chMtxQueueNotEmptyS(ump)) {
 18041e8:	e0bffe17 	ldw	r2,-8(fp)
 18041ec:	10c00017 	ldw	r3,0(r2)
 18041f0:	e0bffe17 	ldw	r2,-8(fp)
 18041f4:	18801026 	beq	r3,r2,1804238 <chMtxUnlockAll+0xb4>
        Thread *tp = fifo_remove(&ump->m_queue);
 18041f8:	e13ffe17 	ldw	r4,-8(fp)
 18041fc:	18040140 	call	1804014 <fifo_remove>
 1804200:	e0bffd15 	stw	r2,-12(fp)
        ump->m_owner = tp;
 1804204:	e0fffe17 	ldw	r3,-8(fp)
 1804208:	e0bffd17 	ldw	r2,-12(fp)
 180420c:	18800215 	stw	r2,8(r3)
        ump->m_next = tp->p_mtxlist;
 1804210:	e0bffd17 	ldw	r2,-12(fp)
 1804214:	10c00f17 	ldw	r3,60(r2)
 1804218:	e0bffe17 	ldw	r2,-8(fp)
 180421c:	10c00315 	stw	r3,12(r2)
        tp->p_mtxlist = ump;
 1804220:	e0fffd17 	ldw	r3,-12(fp)
 1804224:	e0bffe17 	ldw	r2,-8(fp)
 1804228:	18800f15 	stw	r2,60(r3)
        chSchReadyI(tp);
 180422c:	e13ffd17 	ldw	r4,-12(fp)
 1804230:	18043180 	call	1804318 <chSchReadyI>
 1804234:	00000206 	br	1804240 <chMtxUnlockAll+0xbc>
      }
      else
        ump->m_owner = NULL;
 1804238:	e0bffe17 	ldw	r2,-8(fp)
 180423c:	10000215 	stw	zero,8(r2)
    } while (ctp->p_mtxlist != NULL);
 1804240:	e0bfff17 	ldw	r2,-4(fp)
 1804244:	10800f17 	ldw	r2,60(r2)
 1804248:	1004c03a 	cmpne	r2,r2,zero
 180424c:	103fdf1e 	bne	r2,zero,18041cc <chMtxUnlockAll+0x48>
    ctp->p_prio = ctp->p_realprio;
 1804250:	e0bfff17 	ldw	r2,-4(fp)
 1804254:	10c01017 	ldw	r3,64(r2)
 1804258:	e0bfff17 	ldw	r2,-4(fp)
 180425c:	10c00215 	stw	r3,8(r2)
    chSchRescheduleS();
 1804260:	18046e80 	call	18046e8 <chSchRescheduleS>
 1804264:	00800044 	movi	r2,1
 1804268:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 180426c:	e0bffb17 	ldw	r2,-20(fp)
 1804270:	1001703a 	wrctl	status,r2
  }
  chSysUnlock();
}
 1804274:	e037883a 	mov	sp,fp
 1804278:	dfc00117 	ldw	ra,4(sp)
 180427c:	df000017 	ldw	fp,0(sp)
 1804280:	dec00204 	addi	sp,sp,8
 1804284:	f800283a 	ret

01804288 <_scheduler_init>:
/**
 * @brief   Scheduler initialization.
 *
 * @notapi
 */
void _scheduler_init(void) {
 1804288:	deffff04 	addi	sp,sp,-4
 180428c:	df000015 	stw	fp,0(sp)
 1804290:	d839883a 	mov	fp,sp

  queue_init(&rlist.r_queue);
 1804294:	00c06074 	movhi	r3,385
 1804298:	18f2d104 	addi	r3,r3,-13500
 180429c:	00806074 	movhi	r2,385
 18042a0:	10b2d104 	addi	r2,r2,-13500
 18042a4:	10c00115 	stw	r3,4(r2)
 18042a8:	00806074 	movhi	r2,385
 18042ac:	10b2d104 	addi	r2,r2,-13500
 18042b0:	10c00117 	ldw	r3,4(r2)
 18042b4:	00806074 	movhi	r2,385
 18042b8:	10b2d104 	addi	r2,r2,-13500
 18042bc:	10c00015 	stw	r3,0(r2)
  rlist.r_prio = NOPRIO;
 18042c0:	00806074 	movhi	r2,385
 18042c4:	10b2d104 	addi	r2,r2,-13500
 18042c8:	10000215 	stw	zero,8(r2)
#if CH_TIME_QUANTUM > 0
  rlist.r_preempt = CH_TIME_QUANTUM;
 18042cc:	00c06074 	movhi	r3,385
 18042d0:	18f2d104 	addi	r3,r3,-13500
 18042d4:	00800504 	movi	r2,20
 18042d8:	18800615 	stw	r2,24(r3)
#endif
#if CH_USE_REGISTRY
  rlist.r_newer = rlist.r_older = (Thread *)&rlist;
 18042dc:	00c06074 	movhi	r3,385
 18042e0:	18f2d104 	addi	r3,r3,-13500
 18042e4:	00806074 	movhi	r2,385
 18042e8:	10b2d104 	addi	r2,r2,-13500
 18042ec:	10c00515 	stw	r3,20(r2)
 18042f0:	00806074 	movhi	r2,385
 18042f4:	10b2d104 	addi	r2,r2,-13500
 18042f8:	10c00517 	ldw	r3,20(r2)
 18042fc:	00806074 	movhi	r2,385
 1804300:	10b2d104 	addi	r2,r2,-13500
 1804304:	10c00415 	stw	r3,16(r2)
#endif
}
 1804308:	e037883a 	mov	sp,fp
 180430c:	df000017 	ldw	fp,0(sp)
 1804310:	dec00104 	addi	sp,sp,4
 1804314:	f800283a 	ret

01804318 <chSchReadyI>:
 * @return              The thread pointer.
 *
 * @iclass
 */
#if !defined(PORT_OPTIMIZED_READYI) || defined(__DOXYGEN__)
Thread *chSchReadyI(Thread *tp) {
 1804318:	defffd04 	addi	sp,sp,-12
 180431c:	df000215 	stw	fp,8(sp)
 1804320:	df000204 	addi	fp,sp,8
 1804324:	e13fff15 	stw	r4,-4(fp)
  Thread *cp;

  /* Integrity checks.*/
  chDbgAssert((tp->p_state != THD_STATE_READY) &&
 1804328:	e0bfff17 	ldw	r2,-4(fp)
 180432c:	10800703 	ldbu	r2,28(r2)
 1804330:	10803fcc 	andi	r2,r2,255
 1804334:	1005003a 	cmpeq	r2,r2,zero
 1804338:	1000001e 	bne	r2,zero,180433c <chSchReadyI+0x24>
              (tp->p_state != THD_STATE_FINAL),
              "chSchReadyI(), #1",
              "invalid state");

  tp->p_state = THD_STATE_READY;
 180433c:	e0bfff17 	ldw	r2,-4(fp)
 1804340:	10000705 	stb	zero,28(r2)
  cp = (Thread *)&rlist.r_queue;
 1804344:	00806074 	movhi	r2,385
 1804348:	10b2d104 	addi	r2,r2,-13500
 180434c:	e0bffe15 	stw	r2,-8(fp)
  do {
    cp = cp->p_next;
 1804350:	e0bffe17 	ldw	r2,-8(fp)
 1804354:	10800017 	ldw	r2,0(r2)
 1804358:	e0bffe15 	stw	r2,-8(fp)
  } while (cp->p_prio >= tp->p_prio);
 180435c:	e0bffe17 	ldw	r2,-8(fp)
 1804360:	10c00217 	ldw	r3,8(r2)
 1804364:	e0bfff17 	ldw	r2,-4(fp)
 1804368:	10800217 	ldw	r2,8(r2)
 180436c:	18bff82e 	bgeu	r3,r2,1804350 <chSchReadyI+0x38>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 1804370:	e0ffff17 	ldw	r3,-4(fp)
 1804374:	e0bffe17 	ldw	r2,-8(fp)
 1804378:	18800015 	stw	r2,0(r3)
  tp->p_prev = cp->p_prev;
 180437c:	e0bffe17 	ldw	r2,-8(fp)
 1804380:	10c00117 	ldw	r3,4(r2)
 1804384:	e0bfff17 	ldw	r2,-4(fp)
 1804388:	10c00115 	stw	r3,4(r2)
  tp->p_prev->p_next = cp->p_prev = tp;
 180438c:	e0bfff17 	ldw	r2,-4(fp)
 1804390:	11000117 	ldw	r4,4(r2)
 1804394:	e0fffe17 	ldw	r3,-8(fp)
 1804398:	e0bfff17 	ldw	r2,-4(fp)
 180439c:	18800115 	stw	r2,4(r3)
 18043a0:	e0bffe17 	ldw	r2,-8(fp)
 18043a4:	10800117 	ldw	r2,4(r2)
 18043a8:	20800015 	stw	r2,0(r4)
  return tp;
 18043ac:	e0bfff17 	ldw	r2,-4(fp)
}
 18043b0:	e037883a 	mov	sp,fp
 18043b4:	df000017 	ldw	fp,0(sp)
 18043b8:	dec00104 	addi	sp,sp,4
 18043bc:	f800283a 	ret

018043c0 <chSchGoSleepS>:
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
#if !defined(PORT_OPTIMIZED_GOSLEEPS) || defined(__DOXYGEN__)
void chSchGoSleepS(tstate_t newstate) {
 18043c0:	defffc04 	addi	sp,sp,-16
 18043c4:	dfc00315 	stw	ra,12(sp)
 18043c8:	df000215 	stw	fp,8(sp)
 18043cc:	df000204 	addi	fp,sp,8
 18043d0:	e13fff05 	stb	r4,-4(fp)
  Thread *otp;

  chDbgCheckClassS();

  (otp = currp)->p_state = newstate;
 18043d4:	00806074 	movhi	r2,385
 18043d8:	10b2d104 	addi	r2,r2,-13500
 18043dc:	10800717 	ldw	r2,28(r2)
 18043e0:	e0bffe15 	stw	r2,-8(fp)
 18043e4:	e0fffe17 	ldw	r3,-8(fp)
 18043e8:	e0bfff03 	ldbu	r2,-4(fp)
 18043ec:	18800705 	stb	r2,28(r3)
#if CH_TIME_QUANTUM > 0
  rlist.r_preempt = CH_TIME_QUANTUM;
 18043f0:	00c06074 	movhi	r3,385
 18043f4:	18f2d104 	addi	r3,r3,-13500
 18043f8:	00800504 	movi	r2,20
 18043fc:	18800615 	stw	r2,24(r3)
#endif
  setcurrp(fifo_remove(&rlist.r_queue));
 1804400:	01006074 	movhi	r4,385
 1804404:	2132d104 	addi	r4,r4,-13500
 1804408:	18044580 	call	1804458 <fifo_remove>
 180440c:	1007883a 	mov	r3,r2
 1804410:	00806074 	movhi	r2,385
 1804414:	10b2d104 	addi	r2,r2,-13500
 1804418:	10c00715 	stw	r3,28(r2)
  currp->p_state = THD_STATE_CURRENT;
 180441c:	00806074 	movhi	r2,385
 1804420:	10b2d104 	addi	r2,r2,-13500
 1804424:	10c00717 	ldw	r3,28(r2)
 1804428:	00800044 	movi	r2,1
 180442c:	18800705 	stb	r2,28(r3)
  chSysSwitch(currp, otp);
 1804430:	00806074 	movhi	r2,385
 1804434:	10b2d104 	addi	r2,r2,-13500
 1804438:	11000717 	ldw	r4,28(r2)
 180443c:	e17ffe17 	ldw	r5,-8(fp)
 1804440:	18014880 	call	1801488 <port_switch>
}
 1804444:	e037883a 	mov	sp,fp
 1804448:	dfc00117 	ldw	ra,4(sp)
 180444c:	df000017 	ldw	fp,0(sp)
 1804450:	dec00204 	addi	sp,sp,8
 1804454:	f800283a 	ret

01804458 <fifo_remove>:
  tp->p_next = (Thread *)tqp;
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tqp->p_prev = tp;
}

static INLINE Thread *fifo_remove(ThreadsQueue *tqp) {
 1804458:	defffd04 	addi	sp,sp,-12
 180445c:	df000215 	stw	fp,8(sp)
 1804460:	df000204 	addi	fp,sp,8
 1804464:	e13fff15 	stw	r4,-4(fp)
  Thread *tp = tqp->p_next;
 1804468:	e0bfff17 	ldw	r2,-4(fp)
 180446c:	10800017 	ldw	r2,0(r2)
 1804470:	e0bffe15 	stw	r2,-8(fp)

  (tqp->p_next = tp->p_next)->p_prev = (Thread *)tqp;
 1804474:	e0bffe17 	ldw	r2,-8(fp)
 1804478:	10c00017 	ldw	r3,0(r2)
 180447c:	e0bfff17 	ldw	r2,-4(fp)
 1804480:	10c00015 	stw	r3,0(r2)
 1804484:	e0bfff17 	ldw	r2,-4(fp)
 1804488:	10c00017 	ldw	r3,0(r2)
 180448c:	e0bfff17 	ldw	r2,-4(fp)
 1804490:	18800115 	stw	r2,4(r3)
  return tp;
 1804494:	e0bffe17 	ldw	r2,-8(fp)
}
 1804498:	e037883a 	mov	sp,fp
 180449c:	df000017 	ldw	fp,0(sp)
 18044a0:	dec00104 	addi	sp,sp,4
 18044a4:	f800283a 	ret

018044a8 <wakeup>:

#if !defined(PORT_OPTIMIZED_GOSLEEPTIMEOUTS) || defined(__DOXYGEN__)
/*
 * Timeout wakeup callback.
 */
static void wakeup(void *p) {
 18044a8:	defffb04 	addi	sp,sp,-20
 18044ac:	dfc00415 	stw	ra,16(sp)
 18044b0:	df000315 	stw	fp,12(sp)
 18044b4:	df000304 	addi	fp,sp,12
 18044b8:	e13ffe15 	stw	r4,-8(fp)
  Thread *tp = (Thread *)p;
 18044bc:	e0bffe17 	ldw	r2,-8(fp)
 18044c0:	e0bffd15 	stw	r2,-12(fp)

  switch (tp->p_state) {
 18044c4:	e0bffd17 	ldw	r2,-12(fp)
 18044c8:	10800703 	ldbu	r2,28(r2)
 18044cc:	10803fcc 	andi	r2,r2,255
 18044d0:	e0bfff15 	stw	r2,-4(fp)
 18044d4:	e0ffff17 	ldw	r3,-4(fp)
 18044d8:	188000e0 	cmpeqi	r2,r3,3
 18044dc:	10000e1e 	bne	r2,zero,1804518 <wakeup+0x70>
 18044e0:	e0ffff17 	ldw	r3,-4(fp)
 18044e4:	18800108 	cmpgei	r2,r3,4
 18044e8:	1000041e 	bne	r2,zero,18044fc <wakeup+0x54>
 18044ec:	e0ffff17 	ldw	r3,-4(fp)
 18044f0:	1805003a 	cmpeq	r2,r3,zero
 18044f4:	1000151e 	bne	r2,zero,180454c <wakeup+0xa4>
 18044f8:	00000f06 	br	1804538 <wakeup+0x90>
 18044fc:	e0ffff17 	ldw	r3,-4(fp)
 1804500:	18800160 	cmpeqi	r2,r3,5
 1804504:	10000a1e 	bne	r2,zero,1804530 <wakeup+0x88>
 1804508:	e0ffff17 	ldw	r3,-4(fp)
 180450c:	18800360 	cmpeqi	r2,r3,13
 1804510:	1000071e 	bne	r2,zero,1804530 <wakeup+0x88>
 1804514:	00000806 	br	1804538 <wakeup+0x90>
    return;
#if CH_USE_SEMAPHORES || CH_USE_QUEUES ||                                   \
    (CH_USE_CONDVARS && CH_USE_CONDVARS_TIMEOUT)
#if CH_USE_SEMAPHORES
  case THD_STATE_WTSEM:
    chSemFastSignalI((Semaphore *)tp->p_u.wtobjp);
 1804518:	e0bffd17 	ldw	r2,-12(fp)
 180451c:	10800917 	ldw	r2,36(r2)
 1804520:	1007883a 	mov	r3,r2
 1804524:	18800217 	ldw	r2,8(r3)
 1804528:	10800044 	addi	r2,r2,1
 180452c:	18800215 	stw	r2,8(r3)
#endif
#if CH_USE_CONDVARS && CH_USE_CONDVARS_TIMEOUT
  case THD_STATE_WTCOND:
#endif
    /* States requiring dequeuing.*/
    dequeue(tp);
 1804530:	e13ffd17 	ldw	r4,-12(fp)
 1804534:	18045600 	call	1804560 <dequeue>
#endif
  }
  tp->p_u.rdymsg = RDY_TIMEOUT;
 1804538:	e0fffd17 	ldw	r3,-12(fp)
 180453c:	00bfffc4 	movi	r2,-1
 1804540:	18800915 	stw	r2,36(r3)
  chSchReadyI(tp);
 1804544:	e13ffd17 	ldw	r4,-12(fp)
 1804548:	18043180 	call	1804318 <chSchReadyI>
}
 180454c:	e037883a 	mov	sp,fp
 1804550:	dfc00117 	ldw	ra,4(sp)
 1804554:	df000017 	ldw	fp,0(sp)
 1804558:	dec00204 	addi	sp,sp,8
 180455c:	f800283a 	ret

01804560 <dequeue>:

  (tqp->p_prev = tp->p_prev)->p_next = (Thread *)tqp;
  return tp;
}

static INLINE Thread *dequeue(Thread *tp) {
 1804560:	defffe04 	addi	sp,sp,-8
 1804564:	df000115 	stw	fp,4(sp)
 1804568:	df000104 	addi	fp,sp,4
 180456c:	e13fff15 	stw	r4,-4(fp)

  tp->p_prev->p_next = tp->p_next;
 1804570:	e0bfff17 	ldw	r2,-4(fp)
 1804574:	10c00117 	ldw	r3,4(r2)
 1804578:	e0bfff17 	ldw	r2,-4(fp)
 180457c:	10800017 	ldw	r2,0(r2)
 1804580:	18800015 	stw	r2,0(r3)
  tp->p_next->p_prev = tp->p_prev;
 1804584:	e0bfff17 	ldw	r2,-4(fp)
 1804588:	10c00017 	ldw	r3,0(r2)
 180458c:	e0bfff17 	ldw	r2,-4(fp)
 1804590:	10800117 	ldw	r2,4(r2)
 1804594:	18800115 	stw	r2,4(r3)
  return tp;
 1804598:	e0bfff17 	ldw	r2,-4(fp)
}
 180459c:	e037883a 	mov	sp,fp
 18045a0:	df000017 	ldw	fp,0(sp)
 18045a4:	dec00104 	addi	sp,sp,4
 18045a8:	f800283a 	ret

018045ac <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval RDY_TIMEOUT if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 18045ac:	defff704 	addi	sp,sp,-36
 18045b0:	dfc00815 	stw	ra,32(sp)
 18045b4:	df000715 	stw	fp,28(sp)
 18045b8:	df000704 	addi	fp,sp,28
 18045bc:	e17fff15 	stw	r5,-4(fp)
 18045c0:	e13ffe05 	stb	r4,-8(fp)

  chDbgCheckClassS();

  if (TIME_INFINITE != time) {
 18045c4:	e0bfff17 	ldw	r2,-4(fp)
 18045c8:	10bfffe0 	cmpeqi	r2,r2,-1
 18045cc:	1000101e 	bne	r2,zero,1804610 <chSchGoSleepTimeoutS+0x64>
    VirtualTimer vt;

    chVTSetI(&vt, time, wakeup, currp);
 18045d0:	00806074 	movhi	r2,385
 18045d4:	10b2d104 	addi	r2,r2,-13500
 18045d8:	11c00717 	ldw	r7,28(r2)
 18045dc:	e13ff904 	addi	r4,fp,-28
 18045e0:	e17fff17 	ldw	r5,-4(fp)
 18045e4:	01806034 	movhi	r6,384
 18045e8:	31912a04 	addi	r6,r6,17576
 18045ec:	18012300 	call	1801230 <chVTSetI>
    chSchGoSleepS(newstate);
 18045f0:	e13ffe03 	ldbu	r4,-8(fp)
 18045f4:	18043c00 	call	18043c0 <chSchGoSleepS>
    if (chVTIsArmedI(&vt))
 18045f8:	e0bffc17 	ldw	r2,-16(fp)
 18045fc:	1005003a 	cmpeq	r2,r2,zero
 1804600:	1000051e 	bne	r2,zero,1804618 <chSchGoSleepTimeoutS+0x6c>
      chVTResetI(&vt);
 1804604:	e13ff904 	addi	r4,fp,-28
 1804608:	18013440 	call	1801344 <chVTResetI>
 180460c:	00000206 	br	1804618 <chSchGoSleepTimeoutS+0x6c>
  }
  else
    chSchGoSleepS(newstate);
 1804610:	e13ffe03 	ldbu	r4,-8(fp)
 1804614:	18043c00 	call	18043c0 <chSchGoSleepS>
  return currp->p_u.rdymsg;
 1804618:	00806074 	movhi	r2,385
 180461c:	10b2d104 	addi	r2,r2,-13500
 1804620:	10800717 	ldw	r2,28(r2)
 1804624:	10800917 	ldw	r2,36(r2)
}
 1804628:	e037883a 	mov	sp,fp
 180462c:	dfc00117 	ldw	ra,4(sp)
 1804630:	df000017 	ldw	fp,0(sp)
 1804634:	dec00204 	addi	sp,sp,8
 1804638:	f800283a 	ret

0180463c <chSchWakeupS>:
 * @param[in] msg       message to the awakened thread
 *
 * @sclass
 */
#if !defined(PORT_OPTIMIZED_WAKEUPS) || defined(__DOXYGEN__)
void chSchWakeupS(Thread *ntp, msg_t msg) {
 180463c:	defffb04 	addi	sp,sp,-20
 1804640:	dfc00415 	stw	ra,16(sp)
 1804644:	df000315 	stw	fp,12(sp)
 1804648:	df000304 	addi	fp,sp,12
 180464c:	e13ffe15 	stw	r4,-8(fp)
 1804650:	e17fff15 	stw	r5,-4(fp)

  chDbgCheckClassS();

  ntp->p_u.rdymsg = msg;
 1804654:	e0fffe17 	ldw	r3,-8(fp)
 1804658:	e0bfff17 	ldw	r2,-4(fp)
 180465c:	18800915 	stw	r2,36(r3)
  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio)
 1804660:	e0bffe17 	ldw	r2,-8(fp)
 1804664:	10c00217 	ldw	r3,8(r2)
 1804668:	00806074 	movhi	r2,385
 180466c:	10b2d104 	addi	r2,r2,-13500
 1804670:	10800717 	ldw	r2,28(r2)
 1804674:	10800217 	ldw	r2,8(r2)
 1804678:	10c00336 	bltu	r2,r3,1804688 <chSchWakeupS+0x4c>
    chSchReadyI(ntp);
 180467c:	e13ffe17 	ldw	r4,-8(fp)
 1804680:	18043180 	call	1804318 <chSchReadyI>
 1804684:	00001306 	br	18046d4 <chSchWakeupS+0x98>
  else {
    Thread *otp = chSchReadyI(currp);
 1804688:	00806074 	movhi	r2,385
 180468c:	10b2d104 	addi	r2,r2,-13500
 1804690:	11000717 	ldw	r4,28(r2)
 1804694:	18043180 	call	1804318 <chSchReadyI>
 1804698:	e0bffd15 	stw	r2,-12(fp)
#if CH_TIME_QUANTUM > 0
    rlist.r_preempt = CH_TIME_QUANTUM;
 180469c:	00c06074 	movhi	r3,385
 18046a0:	18f2d104 	addi	r3,r3,-13500
 18046a4:	00800504 	movi	r2,20
 18046a8:	18800615 	stw	r2,24(r3)
#endif
    setcurrp(ntp);
 18046ac:	00c06074 	movhi	r3,385
 18046b0:	18f2d104 	addi	r3,r3,-13500
 18046b4:	e0bffe17 	ldw	r2,-8(fp)
 18046b8:	18800715 	stw	r2,28(r3)
    ntp->p_state = THD_STATE_CURRENT;
 18046bc:	e0fffe17 	ldw	r3,-8(fp)
 18046c0:	00800044 	movi	r2,1
 18046c4:	18800705 	stb	r2,28(r3)
    chSysSwitch(ntp, otp);
 18046c8:	e13ffe17 	ldw	r4,-8(fp)
 18046cc:	e17ffd17 	ldw	r5,-12(fp)
 18046d0:	18014880 	call	1801488 <port_switch>
  }
}
 18046d4:	e037883a 	mov	sp,fp
 18046d8:	dfc00117 	ldw	ra,4(sp)
 18046dc:	df000017 	ldw	fp,0(sp)
 18046e0:	dec00204 	addi	sp,sp,8
 18046e4:	f800283a 	ret

018046e8 <chSchRescheduleS>:
 *          the ready list then make the higher priority thread running.
 *
 * @iclass
 */
#if !defined(PORT_OPTIMIZED_RESCHEDULES) || defined(__DOXYGEN__)
void chSchRescheduleS(void) {
 18046e8:	defffe04 	addi	sp,sp,-8
 18046ec:	dfc00115 	stw	ra,4(sp)
 18046f0:	df000015 	stw	fp,0(sp)
 18046f4:	d839883a 	mov	fp,sp

  chDbgCheckClassS();

  if (chSchIsRescRequiredI())
 18046f8:	00806074 	movhi	r2,385
 18046fc:	10b2d104 	addi	r2,r2,-13500
 1804700:	10800017 	ldw	r2,0(r2)
 1804704:	10c00217 	ldw	r3,8(r2)
 1804708:	00806074 	movhi	r2,385
 180470c:	10b2d104 	addi	r2,r2,-13500
 1804710:	10800717 	ldw	r2,28(r2)
 1804714:	10800217 	ldw	r2,8(r2)
 1804718:	10c0012e 	bgeu	r2,r3,1804720 <chSchRescheduleS+0x38>
    chSchDoReschedule();
 180471c:	18047b40 	call	18047b4 <chSchDoReschedule>
}
 1804720:	e037883a 	mov	sp,fp
 1804724:	dfc00117 	ldw	ra,4(sp)
 1804728:	df000017 	ldw	fp,0(sp)
 180472c:	dec00204 	addi	sp,sp,8
 1804730:	f800283a 	ret

01804734 <chSchIsPreemptionRequired>:
 * @retval FALSE        if preemption is not required.
 *
 * @special
 */
#if !defined(PORT_OPTIMIZED_ISPREEMPTIONREQUIRED) || defined(__DOXYGEN__)
bool_t chSchIsPreemptionRequired(void) {
 1804734:	defffc04 	addi	sp,sp,-16
 1804738:	df000315 	stw	fp,12(sp)
 180473c:	df000304 	addi	fp,sp,12
  tprio_t p1 = firstprio(&rlist.r_queue);
 1804740:	00806074 	movhi	r2,385
 1804744:	10b2d104 	addi	r2,r2,-13500
 1804748:	10800017 	ldw	r2,0(r2)
 180474c:	10800217 	ldw	r2,8(r2)
 1804750:	e0bffe15 	stw	r2,-8(fp)
  tprio_t p2 = currp->p_prio;
 1804754:	00806074 	movhi	r2,385
 1804758:	10b2d104 	addi	r2,r2,-13500
 180475c:	10800717 	ldw	r2,28(r2)
 1804760:	10800217 	ldw	r2,8(r2)
 1804764:	e0bffd15 	stw	r2,-12(fp)
#if CH_TIME_QUANTUM > 0
  /* If the running thread has not reached its time quantum, reschedule only
     if the first thread on the ready queue has a higher priority.
     Otherwise, if the running thread has used up its time quantum, reschedule
     if the first thread on the ready queue has equal or higher priority.*/
  return rlist.r_preempt ? p1 > p2 : p1 >= p2;
 1804768:	00806074 	movhi	r2,385
 180476c:	10b2d104 	addi	r2,r2,-13500
 1804770:	10800617 	ldw	r2,24(r2)
 1804774:	1005003a 	cmpeq	r2,r2,zero
 1804778:	1000051e 	bne	r2,zero,1804790 <chSchIsPreemptionRequired+0x5c>
 180477c:	e0fffe17 	ldw	r3,-8(fp)
 1804780:	e0bffd17 	ldw	r2,-12(fp)
 1804784:	10c5803a 	cmpltu	r2,r2,r3
 1804788:	e0bfff15 	stw	r2,-4(fp)
 180478c:	00000406 	br	18047a0 <chSchIsPreemptionRequired+0x6c>
 1804790:	e0fffe17 	ldw	r3,-8(fp)
 1804794:	e0bffd17 	ldw	r2,-12(fp)
 1804798:	1887403a 	cmpgeu	r3,r3,r2
 180479c:	e0ffff15 	stw	r3,-4(fp)
 18047a0:	e0bfff17 	ldw	r2,-4(fp)
#else
  /* If the round robin preemption feature is not enabled then performs a
     simpler comparison.*/
  return p1 > p2;
#endif
}
 18047a4:	e037883a 	mov	sp,fp
 18047a8:	df000017 	ldw	fp,0(sp)
 18047ac:	dec00104 	addi	sp,sp,4
 18047b0:	f800283a 	ret

018047b4 <chSchDoReschedule>:
 *          itself or from within the port layer.
 *
 * @special
 */
#if !defined(PORT_OPTIMIZED_DORESCHEDULE) || defined(__DOXYGEN__)
void chSchDoReschedule(void) {
 18047b4:	defffd04 	addi	sp,sp,-12
 18047b8:	dfc00215 	stw	ra,8(sp)
 18047bc:	df000115 	stw	fp,4(sp)
 18047c0:	df000104 	addi	fp,sp,4
  Thread *otp;

#if CH_TIME_QUANTUM > 0
  rlist.r_preempt = CH_TIME_QUANTUM;
 18047c4:	00c06074 	movhi	r3,385
 18047c8:	18f2d104 	addi	r3,r3,-13500
 18047cc:	00800504 	movi	r2,20
 18047d0:	18800615 	stw	r2,24(r3)
#endif
  otp = currp;
 18047d4:	00806074 	movhi	r2,385
 18047d8:	10b2d104 	addi	r2,r2,-13500
 18047dc:	10800717 	ldw	r2,28(r2)
 18047e0:	e0bfff15 	stw	r2,-4(fp)
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(fifo_remove(&rlist.r_queue));
 18047e4:	01006074 	movhi	r4,385
 18047e8:	2132d104 	addi	r4,r4,-13500
 18047ec:	18044580 	call	1804458 <fifo_remove>
 18047f0:	1007883a 	mov	r3,r2
 18047f4:	00806074 	movhi	r2,385
 18047f8:	10b2d104 	addi	r2,r2,-13500
 18047fc:	10c00715 	stw	r3,28(r2)
  currp->p_state = THD_STATE_CURRENT;
 1804800:	00806074 	movhi	r2,385
 1804804:	10b2d104 	addi	r2,r2,-13500
 1804808:	10c00717 	ldw	r3,28(r2)
 180480c:	00800044 	movi	r2,1
 1804810:	18800705 	stb	r2,28(r3)
  chSchReadyI(otp);
 1804814:	e13fff17 	ldw	r4,-4(fp)
 1804818:	18043180 	call	1804318 <chSchReadyI>
  chSysSwitch(currp, otp);
 180481c:	00806074 	movhi	r2,385
 1804820:	10b2d104 	addi	r2,r2,-13500
 1804824:	11000717 	ldw	r4,28(r2)
 1804828:	e17fff17 	ldw	r5,-4(fp)
 180482c:	18014880 	call	1801488 <port_switch>
}
 1804830:	e037883a 	mov	sp,fp
 1804834:	dfc00117 	ldw	ra,4(sp)
 1804838:	df000017 	ldw	fp,0(sp)
 180483c:	dec00204 	addi	sp,sp,8
 1804840:	f800283a 	ret

01804844 <_idle_thread>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p the thread parameter, unused in this scenario
 */
void _idle_thread(void *p) {
 1804844:	defffe04 	addi	sp,sp,-8
 1804848:	df000115 	stw	fp,4(sp)
 180484c:	df000104 	addi	fp,sp,4
 1804850:	e13fff15 	stw	r4,-4(fp)

  (void)p;
  chRegSetThreadName("idle");
 1804854:	00806074 	movhi	r2,385
 1804858:	10b2d104 	addi	r2,r2,-13500
 180485c:	10c00717 	ldw	r3,28(r2)
 1804860:	00806074 	movhi	r2,385
 1804864:	10a51004 	addi	r2,r2,-27584
 1804868:	18800615 	stw	r2,24(r3)
  while (TRUE) {
    port_wait_for_interrupt();
 180486c:	0001883a 	nop
    IDLE_LOOP_HOOK();
  }
 1804870:	003ffe06 	br	180486c <_idle_thread+0x28>

01804874 <chSysInit>:
 * @note    This function has special, architecture-dependent, requirements,
 *          see the notes into the various port reference manuals.
 *
 * @special
 */
void chSysInit(void) {
 1804874:	defffc04 	addi	sp,sp,-16
 1804878:	dfc00315 	stw	ra,12(sp)
 180487c:	df000215 	stw	fp,8(sp)
 1804880:	df000204 	addi	fp,sp,8
#if CH_DBG_ENABLE_STACK_CHECK
  extern stkalign_t __main_thread_stack_base__;
#endif

  port_init();
  _scheduler_init();
 1804884:	18042880 	call	1804288 <_scheduler_init>
  _vt_init();
 1804888:	18011cc0 	call	18011cc <_vt_init>
#if CH_USE_MEMCORE
  _core_init();
 180488c:	18037a80 	call	18037a8 <_core_init>
#endif
#if CH_USE_HEAP
  _heap_init();
 1804890:	18032bc0 	call	18032bc <_heap_init>
#if CH_DBG_ENABLE_TRACE
  _trace_init();
#endif

  /* Now this instructions flow becomes the main thread.*/
  setcurrp(_thread_init(&mainthread, NORMALPRIO));
 1804894:	01006074 	movhi	r4,385
 1804898:	2132b104 	addi	r4,r4,-13628
 180489c:	01401004 	movi	r5,64
 18048a0:	18009e80 	call	18009e8 <_thread_init>
 18048a4:	1007883a 	mov	r3,r2
 18048a8:	00806074 	movhi	r2,385
 18048ac:	10b2d104 	addi	r2,r2,-13500
 18048b0:	10c00715 	stw	r3,28(r2)
  currp->p_state = THD_STATE_CURRENT;
 18048b4:	00806074 	movhi	r2,385
 18048b8:	10b2d104 	addi	r2,r2,-13500
 18048bc:	10c00717 	ldw	r3,28(r2)
 18048c0:	00800044 	movi	r2,1
 18048c4:	18800705 	stb	r2,28(r3)
 18048c8:	00800044 	movi	r2,1
 18048cc:	e0bfff15 	stw	r2,-4(fp)
 18048d0:	e0bfff17 	ldw	r2,-4(fp)
 18048d4:	1001703a 	wrctl	status,r2
     adjacent to its stack area.*/
  currp->p_stklimit = &__main_thread_stack_base__;
#endif
  chSysEnable();

  chRegSetThreadName("main");
 18048d8:	00806074 	movhi	r2,385
 18048dc:	10b2d104 	addi	r2,r2,-13500
 18048e0:	10c00717 	ldw	r3,28(r2)
 18048e4:	00806074 	movhi	r2,385
 18048e8:	10a51204 	addi	r2,r2,-27576
 18048ec:	18800615 	stw	r2,24(r3)

#if !CH_NO_IDLE_THREAD
  /* This thread has the lowest priority in the system, its role is just to
     serve interrupts in its context while keeping the lowest energy saving
     mode compatible with the system status.*/
  chThdCreateStatic(_idle_thread_wa, sizeof(_idle_thread_wa), IDLEPRIO,
 18048f0:	01c06034 	movhi	r7,384
 18048f4:	39d21104 	addi	r7,r7,18500
 18048f8:	d8000015 	stw	zero,0(sp)
 18048fc:	01006074 	movhi	r4,385
 1804900:	2132d904 	addi	r4,r4,-13468
 1804904:	01407004 	movi	r5,448
 1804908:	01800044 	movi	r6,1
 180490c:	1800c440 	call	1800c44 <chThdCreateStatic>
                    (tfunc_t)_idle_thread, NULL);
#endif
}
 1804910:	e037883a 	mov	sp,fp
 1804914:	dfc00117 	ldw	ra,4(sp)
 1804918:	df000017 	ldw	fp,0(sp)
 180491c:	dec00204 	addi	sp,sp,8
 1804920:	f800283a 	ret

01804924 <chSysTimerHandlerI>:
 *          and, together with the @p CH_TIME_QUANTUM macro, the round robin
 *          interval.
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {
 1804924:	defffc04 	addi	sp,sp,-16
 1804928:	dfc00315 	stw	ra,12(sp)
 180492c:	df000215 	stw	fp,8(sp)
 1804930:	df000204 	addi	fp,sp,8

  chDbgCheckClassI();

#if CH_TIME_QUANTUM > 0
  /* Running thread has not used up quantum yet? */
  if (rlist.r_preempt > 0)
 1804934:	00806074 	movhi	r2,385
 1804938:	10b2d104 	addi	r2,r2,-13500
 180493c:	10800617 	ldw	r2,24(r2)
 1804940:	10800050 	cmplti	r2,r2,1
 1804944:	1000071e 	bne	r2,zero,1804964 <chSysTimerHandlerI+0x40>
    /* Decrement remaining quantum.*/
    rlist.r_preempt--;
 1804948:	00806074 	movhi	r2,385
 180494c:	10b2d104 	addi	r2,r2,-13500
 1804950:	10800617 	ldw	r2,24(r2)
 1804954:	10ffffc4 	addi	r3,r2,-1
 1804958:	00806074 	movhi	r2,385
 180495c:	10b2d104 	addi	r2,r2,-13500
 1804960:	10c00615 	stw	r3,24(r2)
#endif
#if CH_DBG_THREADS_PROFILING
  currp->p_time++;
 1804964:	00806074 	movhi	r2,385
 1804968:	10b2d104 	addi	r2,r2,-13500
 180496c:	10c00717 	ldw	r3,28(r2)
 1804970:	18800817 	ldw	r2,32(r3)
 1804974:	10800044 	addi	r2,r2,1
 1804978:	18800815 	stw	r2,32(r3)
#endif
  chVTDoTickI();
 180497c:	00806074 	movhi	r2,385
 1804980:	10b2cd04 	addi	r2,r2,-13516
 1804984:	10800317 	ldw	r2,12(r2)
 1804988:	10c00044 	addi	r3,r2,1
 180498c:	00806074 	movhi	r2,385
 1804990:	10b2cd04 	addi	r2,r2,-13516
 1804994:	10c00315 	stw	r3,12(r2)
 1804998:	00806074 	movhi	r2,385
 180499c:	10b2cd04 	addi	r2,r2,-13516
 18049a0:	10800017 	ldw	r2,0(r2)
 18049a4:	1007883a 	mov	r3,r2
 18049a8:	00806074 	movhi	r2,385
 18049ac:	10b2cd04 	addi	r2,r2,-13516
 18049b0:	18802226 	beq	r3,r2,1804a3c <chSysTimerHandlerI+0x118>
 18049b4:	00806074 	movhi	r2,385
 18049b8:	10b2cd04 	addi	r2,r2,-13516
 18049bc:	10c00017 	ldw	r3,0(r2)
 18049c0:	18800217 	ldw	r2,8(r3)
 18049c4:	10bfffc4 	addi	r2,r2,-1
 18049c8:	18800215 	stw	r2,8(r3)
 18049cc:	00001306 	br	1804a1c <chSysTimerHandlerI+0xf8>
 18049d0:	e0bfff17 	ldw	r2,-4(fp)
 18049d4:	10800317 	ldw	r2,12(r2)
 18049d8:	e0bffe15 	stw	r2,-8(fp)
 18049dc:	e0bfff17 	ldw	r2,-4(fp)
 18049e0:	10000315 	stw	zero,12(r2)
 18049e4:	e0bfff17 	ldw	r2,-4(fp)
 18049e8:	10c00017 	ldw	r3,0(r2)
 18049ec:	00806074 	movhi	r2,385
 18049f0:	10b2cd04 	addi	r2,r2,-13516
 18049f4:	18800115 	stw	r2,4(r3)
 18049f8:	e0bfff17 	ldw	r2,-4(fp)
 18049fc:	10c00017 	ldw	r3,0(r2)
 1804a00:	00806074 	movhi	r2,385
 1804a04:	10b2cd04 	addi	r2,r2,-13516
 1804a08:	10c00015 	stw	r3,0(r2)
 1804a0c:	e0bfff17 	ldw	r2,-4(fp)
 1804a10:	11000417 	ldw	r4,16(r2)
 1804a14:	e0bffe17 	ldw	r2,-8(fp)
 1804a18:	103ee83a 	callr	r2
 1804a1c:	00806074 	movhi	r2,385
 1804a20:	10b2cd04 	addi	r2,r2,-13516
 1804a24:	10800017 	ldw	r2,0(r2)
 1804a28:	e0bfff15 	stw	r2,-4(fp)
 1804a2c:	e0bfff17 	ldw	r2,-4(fp)
 1804a30:	10800217 	ldw	r2,8(r2)
 1804a34:	1005003a 	cmpeq	r2,r2,zero
 1804a38:	103fe51e 	bne	r2,zero,18049d0 <chSysTimerHandlerI+0xac>
#if defined(SYSTEM_TICK_EVENT_HOOK)
  SYSTEM_TICK_EVENT_HOOK();
#endif
}
 1804a3c:	e037883a 	mov	sp,fp
 1804a40:	dfc00117 	ldw	ra,4(sp)
 1804a44:	df000017 	ldw	fp,0(sp)
 1804a48:	dec00204 	addi	sp,sp,8
 1804a4c:	f800283a 	ret

01804a50 <alt_alarm_start>:
 */ 

int alt_alarm_start (alt_alarm* alarm, alt_u32 nticks,
                     alt_u32 (*callback) (void* context),
                     void* context)
{
 1804a50:	defff404 	addi	sp,sp,-48
 1804a54:	df000b15 	stw	fp,44(sp)
 1804a58:	df000b04 	addi	fp,sp,44
 1804a5c:	e13ffb15 	stw	r4,-20(fp)
 1804a60:	e17ffc15 	stw	r5,-16(fp)
 1804a64:	e1bffd15 	stw	r6,-12(fp)
 1804a68:	e1fffe15 	stw	r7,-8(fp)
  alt_irq_context irq_context;
  alt_u32 current_nticks = 0;
 1804a6c:	e03ff915 	stw	zero,-28(fp)
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
 1804a70:	00806074 	movhi	r2,385
 1804a74:	10b2a404 	addi	r2,r2,-13680
 1804a78:	10800017 	ldw	r2,0(r2)
  
  if (alt_ticks_per_second ())
 1804a7c:	1005003a 	cmpeq	r2,r2,zero
 1804a80:	1000411e 	bne	r2,zero,1804b88 <alt_alarm_start+0x138>
  {
    if (alarm)
 1804a84:	e0bffb17 	ldw	r2,-20(fp)
 1804a88:	1005003a 	cmpeq	r2,r2,zero
 1804a8c:	10003b1e 	bne	r2,zero,1804b7c <alt_alarm_start+0x12c>
    {
      alarm->callback = callback;
 1804a90:	e0fffb17 	ldw	r3,-20(fp)
 1804a94:	e0bffd17 	ldw	r2,-12(fp)
 1804a98:	18800315 	stw	r2,12(r3)
      alarm->context  = context;
 1804a9c:	e0fffb17 	ldw	r3,-20(fp)
 1804aa0:	e0bffe17 	ldw	r2,-8(fp)
 1804aa4:	18800515 	stw	r2,20(r3)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 1804aa8:	0005303a 	rdctl	r2,status
 1804aac:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 1804ab0:	e0fff817 	ldw	r3,-32(fp)
 1804ab4:	00bfff84 	movi	r2,-2
 1804ab8:	1884703a 	and	r2,r3,r2
 1804abc:	1001703a 	wrctl	status,r2
  
  return context;
 1804ac0:	e0bff817 	ldw	r2,-32(fp)
 
      irq_context = alt_irq_disable_all ();
 1804ac4:	e0bffa15 	stw	r2,-24(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
 1804ac8:	00806074 	movhi	r2,385
 1804acc:	10b2a504 	addi	r2,r2,-13676
 1804ad0:	10800017 	ldw	r2,0(r2)
      
      current_nticks = alt_nticks();
 1804ad4:	e0bff915 	stw	r2,-28(fp)
      
      alarm->time = nticks + current_nticks + 1; 
 1804ad8:	e0fffc17 	ldw	r3,-16(fp)
 1804adc:	e0bff917 	ldw	r2,-28(fp)
 1804ae0:	1885883a 	add	r2,r3,r2
 1804ae4:	10c00044 	addi	r3,r2,1
 1804ae8:	e0bffb17 	ldw	r2,-20(fp)
 1804aec:	10c00215 	stw	r3,8(r2)
      /* 
       * If the desired alarm time causes a roll-over, set the rollover
       * flag. This will prevent the subsequent tick event from causing
       * an alarm too early.
       */
      if(alarm->time < current_nticks)
 1804af0:	e0bffb17 	ldw	r2,-20(fp)
 1804af4:	10c00217 	ldw	r3,8(r2)
 1804af8:	e0bff917 	ldw	r2,-28(fp)
 1804afc:	1880042e 	bgeu	r3,r2,1804b10 <alt_alarm_start+0xc0>
      {
        alarm->rollover = 1;
 1804b00:	e0fffb17 	ldw	r3,-20(fp)
 1804b04:	00800044 	movi	r2,1
 1804b08:	18800405 	stb	r2,16(r3)
 1804b0c:	00000206 	br	1804b18 <alt_alarm_start+0xc8>
      }
      else
      {
        alarm->rollover = 0;
 1804b10:	e0bffb17 	ldw	r2,-20(fp)
 1804b14:	10000405 	stb	zero,16(r2)
      }
    
      alt_llist_insert (&alt_alarm_list, &alarm->llist);
 1804b18:	e0fffb17 	ldw	r3,-20(fp)
 1804b1c:	00806074 	movhi	r2,385
 1804b20:	10abd404 	addi	r2,r2,-20656
 1804b24:	e0bff615 	stw	r2,-40(fp)
 1804b28:	e0fff715 	stw	r3,-36(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
 1804b2c:	e0fff717 	ldw	r3,-36(fp)
 1804b30:	e0bff617 	ldw	r2,-40(fp)
 1804b34:	18800115 	stw	r2,4(r3)
  entry->next     = list->next;
 1804b38:	e0bff617 	ldw	r2,-40(fp)
 1804b3c:	10c00017 	ldw	r3,0(r2)
 1804b40:	e0bff717 	ldw	r2,-36(fp)
 1804b44:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
 1804b48:	e0bff617 	ldw	r2,-40(fp)
 1804b4c:	10c00017 	ldw	r3,0(r2)
 1804b50:	e0bff717 	ldw	r2,-36(fp)
 1804b54:	18800115 	stw	r2,4(r3)
  list->next           = entry;
 1804b58:	e0fff617 	ldw	r3,-40(fp)
 1804b5c:	e0bff717 	ldw	r2,-36(fp)
 1804b60:	18800015 	stw	r2,0(r3)
 1804b64:	e0bffa17 	ldw	r2,-24(fp)
 1804b68:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 1804b6c:	e0bff517 	ldw	r2,-44(fp)
 1804b70:	1001703a 	wrctl	status,r2
      alt_irq_enable_all (irq_context);

      return 0;
 1804b74:	e03fff15 	stw	zero,-4(fp)
 1804b78:	00000506 	br	1804b90 <alt_alarm_start+0x140>
    }
    else
    {
      return -EINVAL;
 1804b7c:	00bffa84 	movi	r2,-22
 1804b80:	e0bfff15 	stw	r2,-4(fp)
 1804b84:	00000206 	br	1804b90 <alt_alarm_start+0x140>
    }
  }
  else
  {
    return -ENOTSUP;
 1804b88:	00bfde84 	movi	r2,-134
 1804b8c:	e0bfff15 	stw	r2,-4(fp)
 1804b90:	e0bfff17 	ldw	r2,-4(fp)
  }
}
 1804b94:	e037883a 	mov	sp,fp
 1804b98:	df000017 	ldw	fp,0(sp)
 1804b9c:	dec00104 	addi	sp,sp,4
 1804ba0:	f800283a 	ret

01804ba4 <close>:
 *
 * ALT_CLOSE is mapped onto the close() system call in alt_syscall.h
 */
 
int ALT_CLOSE (int fildes)
{
 1804ba4:	defff804 	addi	sp,sp,-32
 1804ba8:	dfc00715 	stw	ra,28(sp)
 1804bac:	df000615 	stw	fp,24(sp)
 1804bb0:	df000604 	addi	fp,sp,24
 1804bb4:	e13ffc15 	stw	r4,-16(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (fildes < 0) ? NULL : &alt_fd_list[fildes];
 1804bb8:	e0bffc17 	ldw	r2,-16(fp)
 1804bbc:	1004803a 	cmplt	r2,r2,zero
 1804bc0:	1000091e 	bne	r2,zero,1804be8 <close+0x44>
 1804bc4:	e13ffc17 	ldw	r4,-16(fp)
 1804bc8:	01400304 	movi	r5,12
 1804bcc:	1808b580 	call	1808b58 <__mulsi3>
 1804bd0:	1007883a 	mov	r3,r2
 1804bd4:	00806074 	movhi	r2,385
 1804bd8:	10a96b04 	addi	r2,r2,-23124
 1804bdc:	1887883a 	add	r3,r3,r2
 1804be0:	e0ffff15 	stw	r3,-4(fp)
 1804be4:	00000106 	br	1804bec <close+0x48>
 1804be8:	e03fff15 	stw	zero,-4(fp)
 1804bec:	e0bfff17 	ldw	r2,-4(fp)
 1804bf0:	e0bffb15 	stw	r2,-20(fp)

  if (fd)
 1804bf4:	e0bffb17 	ldw	r2,-20(fp)
 1804bf8:	1005003a 	cmpeq	r2,r2,zero
 1804bfc:	10001d1e 	bne	r2,zero,1804c74 <close+0xd0>
    /*
     * If the associated file system/device has a close function, call it so 
     * that any necessary cleanup code can run.
     */

    rval = (fd->dev->close) ? fd->dev->close(fd) : 0;
 1804c00:	e0bffb17 	ldw	r2,-20(fp)
 1804c04:	10800017 	ldw	r2,0(r2)
 1804c08:	10800417 	ldw	r2,16(r2)
 1804c0c:	1005003a 	cmpeq	r2,r2,zero
 1804c10:	1000071e 	bne	r2,zero,1804c30 <close+0x8c>
 1804c14:	e0bffb17 	ldw	r2,-20(fp)
 1804c18:	10800017 	ldw	r2,0(r2)
 1804c1c:	10800417 	ldw	r2,16(r2)
 1804c20:	e13ffb17 	ldw	r4,-20(fp)
 1804c24:	103ee83a 	callr	r2
 1804c28:	e0bffe15 	stw	r2,-8(fp)
 1804c2c:	00000106 	br	1804c34 <close+0x90>
 1804c30:	e03ffe15 	stw	zero,-8(fp)
 1804c34:	e0bffe17 	ldw	r2,-8(fp)
 1804c38:	e0bffa15 	stw	r2,-24(fp)

    /* Free the file descriptor structure and return. */

    alt_release_fd (fildes);
 1804c3c:	e13ffc17 	ldw	r4,-16(fp)
 1804c40:	18056440 	call	1805644 <alt_release_fd>
    if (rval < 0)
 1804c44:	e0bffa17 	ldw	r2,-24(fp)
 1804c48:	1004403a 	cmpge	r2,r2,zero
 1804c4c:	1000071e 	bne	r2,zero,1804c6c <close+0xc8>
    {
      ALT_ERRNO = -rval;
 1804c50:	1804ca40 	call	1804ca4 <alt_get_errno>
 1804c54:	e0fffa17 	ldw	r3,-24(fp)
 1804c58:	00c7c83a 	sub	r3,zero,r3
 1804c5c:	10c00015 	stw	r3,0(r2)
      return -1;
 1804c60:	00bfffc4 	movi	r2,-1
 1804c64:	e0bffd15 	stw	r2,-12(fp)
 1804c68:	00000806 	br	1804c8c <close+0xe8>
    }
    return 0;
 1804c6c:	e03ffd15 	stw	zero,-12(fp)
 1804c70:	00000606 	br	1804c8c <close+0xe8>
  }
  else
  {
    ALT_ERRNO = EBADFD;
 1804c74:	1804ca40 	call	1804ca4 <alt_get_errno>
 1804c78:	1007883a 	mov	r3,r2
 1804c7c:	00801444 	movi	r2,81
 1804c80:	18800015 	stw	r2,0(r3)
    return -1;
 1804c84:	00bfffc4 	movi	r2,-1
 1804c88:	e0bffd15 	stw	r2,-12(fp)
 1804c8c:	e0bffd17 	ldw	r2,-12(fp)
  }
}
 1804c90:	e037883a 	mov	sp,fp
 1804c94:	dfc00117 	ldw	ra,4(sp)
 1804c98:	df000017 	ldw	fp,0(sp)
 1804c9c:	dec00204 	addi	sp,sp,8
 1804ca0:	f800283a 	ret

01804ca4 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 1804ca4:	defffd04 	addi	sp,sp,-12
 1804ca8:	dfc00215 	stw	ra,8(sp)
 1804cac:	df000115 	stw	fp,4(sp)
 1804cb0:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
 1804cb4:	00806074 	movhi	r2,385
 1804cb8:	10abd204 	addi	r2,r2,-20664
 1804cbc:	10800017 	ldw	r2,0(r2)
 1804cc0:	1005003a 	cmpeq	r2,r2,zero
 1804cc4:	1000061e 	bne	r2,zero,1804ce0 <alt_get_errno+0x3c>
 1804cc8:	00806074 	movhi	r2,385
 1804ccc:	10abd204 	addi	r2,r2,-20664
 1804cd0:	10800017 	ldw	r2,0(r2)
 1804cd4:	103ee83a 	callr	r2
 1804cd8:	e0bfff15 	stw	r2,-4(fp)
 1804cdc:	00000306 	br	1804cec <alt_get_errno+0x48>
 1804ce0:	00806074 	movhi	r2,385
 1804ce4:	10b2a604 	addi	r2,r2,-13672
 1804ce8:	e0bfff15 	stw	r2,-4(fp)
 1804cec:	e0bfff17 	ldw	r2,-4(fp)
}
 1804cf0:	e037883a 	mov	sp,fp
 1804cf4:	dfc00117 	ldw	ra,4(sp)
 1804cf8:	df000017 	ldw	fp,0(sp)
 1804cfc:	dec00204 	addi	sp,sp,8
 1804d00:	f800283a 	ret

01804d04 <alt_dcache_flush_all>:
/*
 * alt_dcache_flush_all() is called to flush the entire data cache.
 */

void alt_dcache_flush_all (void)
{
 1804d04:	deffff04 	addi	sp,sp,-4
 1804d08:	df000015 	stw	fp,0(sp)
 1804d0c:	d839883a 	mov	fp,sp
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  }
#endif /* NIOS2_DCACHE_SIZE > 0 */
}
 1804d10:	e037883a 	mov	sp,fp
 1804d14:	df000017 	ldw	fp,0(sp)
 1804d18:	dec00104 	addi	sp,sp,4
 1804d1c:	f800283a 	ret

01804d20 <alt_dev_null_write>:
 * by the alt_dev_null device. It simple discards all data passed to it, and
 * indicates that the data has been successfully transmitted.
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
 1804d20:	defffc04 	addi	sp,sp,-16
 1804d24:	df000315 	stw	fp,12(sp)
 1804d28:	df000304 	addi	fp,sp,12
 1804d2c:	e13ffd15 	stw	r4,-12(fp)
 1804d30:	e17ffe15 	stw	r5,-8(fp)
 1804d34:	e1bfff15 	stw	r6,-4(fp)
  return len;
 1804d38:	e0bfff17 	ldw	r2,-4(fp)
}
 1804d3c:	e037883a 	mov	sp,fp
 1804d40:	df000017 	ldw	fp,0(sp)
 1804d44:	dec00104 	addi	sp,sp,4
 1804d48:	f800283a 	ret

01804d4c <alt_dev_llist_insert>:
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
 1804d4c:	defff904 	addi	sp,sp,-28
 1804d50:	dfc00615 	stw	ra,24(sp)
 1804d54:	df000515 	stw	fp,20(sp)
 1804d58:	df000504 	addi	fp,sp,20
 1804d5c:	e13ffd15 	stw	r4,-12(fp)
 1804d60:	e17ffe15 	stw	r5,-8(fp)
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
 1804d64:	e0bffd17 	ldw	r2,-12(fp)
 1804d68:	1005003a 	cmpeq	r2,r2,zero
 1804d6c:	1000041e 	bne	r2,zero,1804d80 <alt_dev_llist_insert+0x34>
 1804d70:	e0bffd17 	ldw	r2,-12(fp)
 1804d74:	10800217 	ldw	r2,8(r2)
 1804d78:	1004c03a 	cmpne	r2,r2,zero
 1804d7c:	1000071e 	bne	r2,zero,1804d9c <alt_dev_llist_insert+0x50>
  {
    ALT_ERRNO = EINVAL;
 1804d80:	1804e000 	call	1804e00 <alt_get_errno>
 1804d84:	1007883a 	mov	r3,r2
 1804d88:	00800584 	movi	r2,22
 1804d8c:	18800015 	stw	r2,0(r3)
    return -EINVAL;
 1804d90:	00bffa84 	movi	r2,-22
 1804d94:	e0bfff15 	stw	r2,-4(fp)
 1804d98:	00001306 	br	1804de8 <alt_dev_llist_insert+0x9c>
  
  /*
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);
 1804d9c:	e0fffd17 	ldw	r3,-12(fp)
 1804da0:	e0bffe17 	ldw	r2,-8(fp)
 1804da4:	e0bffb15 	stw	r2,-20(fp)
 1804da8:	e0fffc15 	stw	r3,-16(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
 1804dac:	e0fffc17 	ldw	r3,-16(fp)
 1804db0:	e0bffb17 	ldw	r2,-20(fp)
 1804db4:	18800115 	stw	r2,4(r3)
  entry->next     = list->next;
 1804db8:	e0bffb17 	ldw	r2,-20(fp)
 1804dbc:	10c00017 	ldw	r3,0(r2)
 1804dc0:	e0bffc17 	ldw	r2,-16(fp)
 1804dc4:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
 1804dc8:	e0bffb17 	ldw	r2,-20(fp)
 1804dcc:	10c00017 	ldw	r3,0(r2)
 1804dd0:	e0bffc17 	ldw	r2,-16(fp)
 1804dd4:	18800115 	stw	r2,4(r3)
  list->next           = entry;
 1804dd8:	e0fffb17 	ldw	r3,-20(fp)
 1804ddc:	e0bffc17 	ldw	r2,-16(fp)
 1804de0:	18800015 	stw	r2,0(r3)

  return 0;  
 1804de4:	e03fff15 	stw	zero,-4(fp)
 1804de8:	e0bfff17 	ldw	r2,-4(fp)
}
 1804dec:	e037883a 	mov	sp,fp
 1804df0:	dfc00117 	ldw	ra,4(sp)
 1804df4:	df000017 	ldw	fp,0(sp)
 1804df8:	dec00204 	addi	sp,sp,8
 1804dfc:	f800283a 	ret

01804e00 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 1804e00:	defffd04 	addi	sp,sp,-12
 1804e04:	dfc00215 	stw	ra,8(sp)
 1804e08:	df000115 	stw	fp,4(sp)
 1804e0c:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
 1804e10:	00806074 	movhi	r2,385
 1804e14:	10abd204 	addi	r2,r2,-20664
 1804e18:	10800017 	ldw	r2,0(r2)
 1804e1c:	1005003a 	cmpeq	r2,r2,zero
 1804e20:	1000061e 	bne	r2,zero,1804e3c <alt_get_errno+0x3c>
 1804e24:	00806074 	movhi	r2,385
 1804e28:	10abd204 	addi	r2,r2,-20664
 1804e2c:	10800017 	ldw	r2,0(r2)
 1804e30:	103ee83a 	callr	r2
 1804e34:	e0bfff15 	stw	r2,-4(fp)
 1804e38:	00000306 	br	1804e48 <alt_get_errno+0x48>
 1804e3c:	00806074 	movhi	r2,385
 1804e40:	10b2a604 	addi	r2,r2,-13672
 1804e44:	e0bfff15 	stw	r2,-4(fp)
 1804e48:	e0bfff17 	ldw	r2,-4(fp)
}
 1804e4c:	e037883a 	mov	sp,fp
 1804e50:	dfc00117 	ldw	ra,4(sp)
 1804e54:	df000017 	ldw	fp,0(sp)
 1804e58:	dec00204 	addi	sp,sp,8
 1804e5c:	f800283a 	ret

01804e60 <_do_ctors>:
/*
 * Run the C++ static constructors.
 */

void _do_ctors(void)
{
 1804e60:	defffd04 	addi	sp,sp,-12
 1804e64:	dfc00215 	stw	ra,8(sp)
 1804e68:	df000115 	stw	fp,4(sp)
 1804e6c:	df000104 	addi	fp,sp,4
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
 1804e70:	00bfff04 	movi	r2,-4
 1804e74:	00c06074 	movhi	r3,385
 1804e78:	18e4eb04 	addi	r3,r3,-27732
 1804e7c:	1885883a 	add	r2,r3,r2
 1804e80:	e0bfff15 	stw	r2,-4(fp)
 1804e84:	00000606 	br	1804ea0 <_do_ctors+0x40>
        (*ctor) (); 
 1804e88:	e0bfff17 	ldw	r2,-4(fp)
 1804e8c:	10800017 	ldw	r2,0(r2)
 1804e90:	103ee83a 	callr	r2

void _do_ctors(void)
{
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
 1804e94:	e0bfff17 	ldw	r2,-4(fp)
 1804e98:	10bfff04 	addi	r2,r2,-4
 1804e9c:	e0bfff15 	stw	r2,-4(fp)
 1804ea0:	e0ffff17 	ldw	r3,-4(fp)
 1804ea4:	00806074 	movhi	r2,385
 1804ea8:	10a4ea04 	addi	r2,r2,-27736
 1804eac:	18bff62e 	bgeu	r3,r2,1804e88 <_do_ctors+0x28>
        (*ctor) (); 
}
 1804eb0:	e037883a 	mov	sp,fp
 1804eb4:	dfc00117 	ldw	ra,4(sp)
 1804eb8:	df000017 	ldw	fp,0(sp)
 1804ebc:	dec00204 	addi	sp,sp,8
 1804ec0:	f800283a 	ret

01804ec4 <_do_dtors>:
/*
 * Run the C++ static destructors.
 */

void _do_dtors(void)
{
 1804ec4:	defffd04 	addi	sp,sp,-12
 1804ec8:	dfc00215 	stw	ra,8(sp)
 1804ecc:	df000115 	stw	fp,4(sp)
 1804ed0:	df000104 	addi	fp,sp,4
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
 1804ed4:	00bfff04 	movi	r2,-4
 1804ed8:	00c06074 	movhi	r3,385
 1804edc:	18e4eb04 	addi	r3,r3,-27732
 1804ee0:	1885883a 	add	r2,r3,r2
 1804ee4:	e0bfff15 	stw	r2,-4(fp)
 1804ee8:	00000606 	br	1804f04 <_do_dtors+0x40>
        (*dtor) (); 
 1804eec:	e0bfff17 	ldw	r2,-4(fp)
 1804ef0:	10800017 	ldw	r2,0(r2)
 1804ef4:	103ee83a 	callr	r2

void _do_dtors(void)
{
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
 1804ef8:	e0bfff17 	ldw	r2,-4(fp)
 1804efc:	10bfff04 	addi	r2,r2,-4
 1804f00:	e0bfff15 	stw	r2,-4(fp)
 1804f04:	e0ffff17 	ldw	r3,-4(fp)
 1804f08:	00806074 	movhi	r2,385
 1804f0c:	10a4eb04 	addi	r2,r2,-27732
 1804f10:	18bff62e 	bgeu	r3,r2,1804eec <_do_dtors+0x28>
        (*dtor) (); 
}
 1804f14:	e037883a 	mov	sp,fp
 1804f18:	dfc00117 	ldw	ra,4(sp)
 1804f1c:	df000017 	ldw	fp,0(sp)
 1804f20:	dec00204 	addi	sp,sp,8
 1804f24:	f800283a 	ret

01804f28 <alt_icache_flush_all>:
/*
 * alt_icache_flush_all() is called to flush the entire instruction cache.
 */

void alt_icache_flush_all (void)
{
 1804f28:	deffff04 	addi	sp,sp,-4
 1804f2c:	df000015 	stw	fp,0(sp)
 1804f30:	d839883a 	mov	fp,sp
#if NIOS2_ICACHE_SIZE > 0
  alt_icache_flush (0, NIOS2_ICACHE_SIZE);
#endif
}
 1804f34:	e037883a 	mov	sp,fp
 1804f38:	df000017 	ldw	fp,0(sp)
 1804f3c:	dec00104 	addi	sp,sp,4
 1804f40:	f800283a 	ret

01804f44 <alt_ic_isr_register>:
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
 1804f44:	defff904 	addi	sp,sp,-28
 1804f48:	dfc00615 	stw	ra,24(sp)
 1804f4c:	df000515 	stw	fp,20(sp)
 1804f50:	df000504 	addi	fp,sp,20
 1804f54:	e13ffc15 	stw	r4,-16(fp)
 1804f58:	e17ffd15 	stw	r5,-12(fp)
 1804f5c:	e1bffe15 	stw	r6,-8(fp)
 1804f60:	e1ffff15 	stw	r7,-4(fp)
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
 1804f64:	e0800217 	ldw	r2,8(fp)
 1804f68:	d8800015 	stw	r2,0(sp)
 1804f6c:	e13ffc17 	ldw	r4,-16(fp)
 1804f70:	e17ffd17 	ldw	r5,-12(fp)
 1804f74:	e1bffe17 	ldw	r6,-8(fp)
 1804f78:	e1ffff17 	ldw	r7,-4(fp)
 1804f7c:	18051180 	call	1805118 <alt_iic_isr_register>
}  
 1804f80:	e037883a 	mov	sp,fp
 1804f84:	dfc00117 	ldw	ra,4(sp)
 1804f88:	df000017 	ldw	fp,0(sp)
 1804f8c:	dec00204 	addi	sp,sp,8
 1804f90:	f800283a 	ret

01804f94 <alt_ic_irq_enable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
 1804f94:	defff904 	addi	sp,sp,-28
 1804f98:	df000615 	stw	fp,24(sp)
 1804f9c:	df000604 	addi	fp,sp,24
 1804fa0:	e13ffe15 	stw	r4,-8(fp)
 1804fa4:	e17fff15 	stw	r5,-4(fp)
 1804fa8:	e0bfff17 	ldw	r2,-4(fp)
 1804fac:	e0bffc15 	stw	r2,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 1804fb0:	0005303a 	rdctl	r2,status
 1804fb4:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 1804fb8:	e0fffb17 	ldw	r3,-20(fp)
 1804fbc:	00bfff84 	movi	r2,-2
 1804fc0:	1884703a 	and	r2,r3,r2
 1804fc4:	1001703a 	wrctl	status,r2
  
  return context;
 1804fc8:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
 1804fcc:	e0bffd15 	stw	r2,-12(fp)

  alt_irq_active |= (1 << id);
 1804fd0:	e0fffc17 	ldw	r3,-16(fp)
 1804fd4:	00800044 	movi	r2,1
 1804fd8:	10c4983a 	sll	r2,r2,r3
 1804fdc:	1007883a 	mov	r3,r2
 1804fe0:	00806074 	movhi	r2,385
 1804fe4:	10b2a304 	addi	r2,r2,-13684
 1804fe8:	10800017 	ldw	r2,0(r2)
 1804fec:	1886b03a 	or	r3,r3,r2
 1804ff0:	00806074 	movhi	r2,385
 1804ff4:	10b2a304 	addi	r2,r2,-13684
 1804ff8:	10c00015 	stw	r3,0(r2)
  NIOS2_WRITE_IENABLE (alt_irq_active);
 1804ffc:	00806074 	movhi	r2,385
 1805000:	10b2a304 	addi	r2,r2,-13684
 1805004:	10800017 	ldw	r2,0(r2)
 1805008:	100170fa 	wrctl	ienable,r2
 180500c:	e0bffd17 	ldw	r2,-12(fp)
 1805010:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 1805014:	e0bffa17 	ldw	r2,-24(fp)
 1805018:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
 180501c:	0005883a 	mov	r2,zero
    return alt_irq_enable(irq);
}
 1805020:	e037883a 	mov	sp,fp
 1805024:	df000017 	ldw	fp,0(sp)
 1805028:	dec00104 	addi	sp,sp,4
 180502c:	f800283a 	ret

01805030 <alt_ic_irq_disable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
 1805030:	defff904 	addi	sp,sp,-28
 1805034:	df000615 	stw	fp,24(sp)
 1805038:	df000604 	addi	fp,sp,24
 180503c:	e13ffe15 	stw	r4,-8(fp)
 1805040:	e17fff15 	stw	r5,-4(fp)
 1805044:	e0bfff17 	ldw	r2,-4(fp)
 1805048:	e0bffc15 	stw	r2,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 180504c:	0005303a 	rdctl	r2,status
 1805050:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 1805054:	e0fffb17 	ldw	r3,-20(fp)
 1805058:	00bfff84 	movi	r2,-2
 180505c:	1884703a 	and	r2,r3,r2
 1805060:	1001703a 	wrctl	status,r2
  
  return context;
 1805064:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
 1805068:	e0bffd15 	stw	r2,-12(fp)

  alt_irq_active &= ~(1 << id);
 180506c:	e0fffc17 	ldw	r3,-16(fp)
 1805070:	00800044 	movi	r2,1
 1805074:	10c4983a 	sll	r2,r2,r3
 1805078:	0084303a 	nor	r2,zero,r2
 180507c:	1007883a 	mov	r3,r2
 1805080:	00806074 	movhi	r2,385
 1805084:	10b2a304 	addi	r2,r2,-13684
 1805088:	10800017 	ldw	r2,0(r2)
 180508c:	1886703a 	and	r3,r3,r2
 1805090:	00806074 	movhi	r2,385
 1805094:	10b2a304 	addi	r2,r2,-13684
 1805098:	10c00015 	stw	r3,0(r2)
  NIOS2_WRITE_IENABLE (alt_irq_active);
 180509c:	00806074 	movhi	r2,385
 18050a0:	10b2a304 	addi	r2,r2,-13684
 18050a4:	10800017 	ldw	r2,0(r2)
 18050a8:	100170fa 	wrctl	ienable,r2
 18050ac:	e0bffd17 	ldw	r2,-12(fp)
 18050b0:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 18050b4:	e0bffa17 	ldw	r2,-24(fp)
 18050b8:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
 18050bc:	0005883a 	mov	r2,zero
    return alt_irq_disable(irq);
}
 18050c0:	e037883a 	mov	sp,fp
 18050c4:	df000017 	ldw	fp,0(sp)
 18050c8:	dec00104 	addi	sp,sp,4
 18050cc:	f800283a 	ret

018050d0 <alt_ic_irq_enabled>:
  * @param irq              IRQ number
  * @return                 Zero if corresponding interrupt is disabled and
  *                         non-zero otherwise.
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
 18050d0:	defffc04 	addi	sp,sp,-16
 18050d4:	df000315 	stw	fp,12(sp)
 18050d8:	df000304 	addi	fp,sp,12
 18050dc:	e13ffe15 	stw	r4,-8(fp)
 18050e0:	e17fff15 	stw	r5,-4(fp)
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
 18050e4:	000530fa 	rdctl	r2,ienable
 18050e8:	e0bffd15 	stw	r2,-12(fp)

    return (irq_enabled & (1 << irq)) ? 1: 0;
 18050ec:	e0ffff17 	ldw	r3,-4(fp)
 18050f0:	00800044 	movi	r2,1
 18050f4:	10c4983a 	sll	r2,r2,r3
 18050f8:	1007883a 	mov	r3,r2
 18050fc:	e0bffd17 	ldw	r2,-12(fp)
 1805100:	1884703a 	and	r2,r3,r2
 1805104:	1004c03a 	cmpne	r2,r2,zero
}
 1805108:	e037883a 	mov	sp,fp
 180510c:	df000017 	ldw	fp,0(sp)
 1805110:	dec00104 	addi	sp,sp,4
 1805114:	f800283a 	ret

01805118 <alt_iic_isr_register>:
  * @param flags            
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
 1805118:	defff404 	addi	sp,sp,-48
 180511c:	dfc00b15 	stw	ra,44(sp)
 1805120:	df000a15 	stw	fp,40(sp)
 1805124:	df000a04 	addi	fp,sp,40
 1805128:	e13ffb15 	stw	r4,-20(fp)
 180512c:	e17ffc15 	stw	r5,-16(fp)
 1805130:	e1bffd15 	stw	r6,-12(fp)
 1805134:	e1fffe15 	stw	r7,-8(fp)
  int rc = -EINVAL;  
 1805138:	00bffa84 	movi	r2,-22
 180513c:	e0bffa15 	stw	r2,-24(fp)
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
 1805140:	e0bffc17 	ldw	r2,-16(fp)
 1805144:	e0bff915 	stw	r2,-28(fp)
  alt_irq_context status;

  if (id < ALT_NIRQ)
 1805148:	e0bff917 	ldw	r2,-28(fp)
 180514c:	10800808 	cmpgei	r2,r2,32
 1805150:	1000291e 	bne	r2,zero,18051f8 <alt_iic_isr_register+0xe0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 1805154:	0005303a 	rdctl	r2,status
 1805158:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 180515c:	e0fff717 	ldw	r3,-36(fp)
 1805160:	00bfff84 	movi	r2,-2
 1805164:	1884703a 	and	r2,r3,r2
 1805168:	1001703a 	wrctl	status,r2
  
  return context;
 180516c:	e0bff717 	ldw	r2,-36(fp)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all();
 1805170:	e0bff815 	stw	r2,-32(fp)

    alt_irq[id].handler = isr;
 1805174:	e0bff917 	ldw	r2,-28(fp)
 1805178:	00c06074 	movhi	r3,385
 180517c:	18f34904 	addi	r3,r3,-13020
 1805180:	100490fa 	slli	r2,r2,3
 1805184:	10c7883a 	add	r3,r2,r3
 1805188:	e0bffd17 	ldw	r2,-12(fp)
 180518c:	18800015 	stw	r2,0(r3)
    alt_irq[id].context = isr_context;
 1805190:	e0bff917 	ldw	r2,-28(fp)
 1805194:	00c06074 	movhi	r3,385
 1805198:	18f34904 	addi	r3,r3,-13020
 180519c:	100490fa 	slli	r2,r2,3
 18051a0:	10c5883a 	add	r2,r2,r3
 18051a4:	10c00104 	addi	r3,r2,4
 18051a8:	e0bffe17 	ldw	r2,-8(fp)
 18051ac:	18800015 	stw	r2,0(r3)

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
 18051b0:	e0bffd17 	ldw	r2,-12(fp)
 18051b4:	1005003a 	cmpeq	r2,r2,zero
 18051b8:	1000051e 	bne	r2,zero,18051d0 <alt_iic_isr_register+0xb8>
 18051bc:	e17ff917 	ldw	r5,-28(fp)
 18051c0:	e13ffb17 	ldw	r4,-20(fp)
 18051c4:	1804f940 	call	1804f94 <alt_ic_irq_enable>
 18051c8:	e0bfff15 	stw	r2,-4(fp)
 18051cc:	00000406 	br	18051e0 <alt_iic_isr_register+0xc8>
 18051d0:	e17ff917 	ldw	r5,-28(fp)
 18051d4:	e13ffb17 	ldw	r4,-20(fp)
 18051d8:	18050300 	call	1805030 <alt_ic_irq_disable>
 18051dc:	e0bfff15 	stw	r2,-4(fp)
 18051e0:	e0bfff17 	ldw	r2,-4(fp)
 18051e4:	e0bffa15 	stw	r2,-24(fp)
 18051e8:	e0bff817 	ldw	r2,-32(fp)
 18051ec:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 18051f0:	e0bff617 	ldw	r2,-40(fp)
 18051f4:	1001703a 	wrctl	status,r2

    alt_irq_enable_all(status);
  }

  return rc; 
 18051f8:	e0bffa17 	ldw	r2,-24(fp)
}
 18051fc:	e037883a 	mov	sp,fp
 1805200:	dfc00117 	ldw	ra,4(sp)
 1805204:	df000017 	ldw	fp,0(sp)
 1805208:	dec00204 	addi	sp,sp,8
 180520c:	f800283a 	ret

01805210 <alt_open_fd>:
 * If the device can not be succesfully opened, then the input file descriptor
 * remains unchanged.
 */

static void alt_open_fd(alt_fd* fd, const char* name, int flags, int mode)
{
 1805210:	defff804 	addi	sp,sp,-32
 1805214:	dfc00715 	stw	ra,28(sp)
 1805218:	df000615 	stw	fp,24(sp)
 180521c:	dc000515 	stw	r16,20(sp)
 1805220:	df000504 	addi	fp,sp,20
 1805224:	e13ffc15 	stw	r4,-16(fp)
 1805228:	e17ffd15 	stw	r5,-12(fp)
 180522c:	e1bffe15 	stw	r6,-8(fp)
 1805230:	e1ffff15 	stw	r7,-4(fp)
  int old;

  old = open (name, flags, mode);
 1805234:	e13ffd17 	ldw	r4,-12(fp)
 1805238:	e17ffe17 	ldw	r5,-8(fp)
 180523c:	e1bfff17 	ldw	r6,-4(fp)
 1805240:	18054580 	call	1805458 <open>
 1805244:	e0bffb15 	stw	r2,-20(fp)

  if (old >= 0)
 1805248:	e0bffb17 	ldw	r2,-20(fp)
 180524c:	1004803a 	cmplt	r2,r2,zero
 1805250:	10001f1e 	bne	r2,zero,18052d0 <alt_open_fd+0xc0>
  {
    fd->dev      = alt_fd_list[old].dev;
 1805254:	e13ffb17 	ldw	r4,-20(fp)
 1805258:	04006074 	movhi	r16,385
 180525c:	84296b04 	addi	r16,r16,-23124
 1805260:	01400304 	movi	r5,12
 1805264:	1808b580 	call	1808b58 <__mulsi3>
 1805268:	1405883a 	add	r2,r2,r16
 180526c:	10c00017 	ldw	r3,0(r2)
 1805270:	e0bffc17 	ldw	r2,-16(fp)
 1805274:	10c00015 	stw	r3,0(r2)
    fd->priv     = alt_fd_list[old].priv;
 1805278:	e13ffb17 	ldw	r4,-20(fp)
 180527c:	04006074 	movhi	r16,385
 1805280:	84296b04 	addi	r16,r16,-23124
 1805284:	01400304 	movi	r5,12
 1805288:	1808b580 	call	1808b58 <__mulsi3>
 180528c:	1405883a 	add	r2,r2,r16
 1805290:	10800104 	addi	r2,r2,4
 1805294:	10c00017 	ldw	r3,0(r2)
 1805298:	e0bffc17 	ldw	r2,-16(fp)
 180529c:	10c00115 	stw	r3,4(r2)
    fd->fd_flags = alt_fd_list[old].fd_flags;
 18052a0:	e13ffb17 	ldw	r4,-20(fp)
 18052a4:	04006074 	movhi	r16,385
 18052a8:	84296b04 	addi	r16,r16,-23124
 18052ac:	01400304 	movi	r5,12
 18052b0:	1808b580 	call	1808b58 <__mulsi3>
 18052b4:	1405883a 	add	r2,r2,r16
 18052b8:	10800204 	addi	r2,r2,8
 18052bc:	10c00017 	ldw	r3,0(r2)
 18052c0:	e0bffc17 	ldw	r2,-16(fp)
 18052c4:	10c00215 	stw	r3,8(r2)

    alt_release_fd (old);
 18052c8:	e13ffb17 	ldw	r4,-20(fp)
 18052cc:	18056440 	call	1805644 <alt_release_fd>
  }
} 
 18052d0:	e037883a 	mov	sp,fp
 18052d4:	dfc00217 	ldw	ra,8(sp)
 18052d8:	df000117 	ldw	fp,4(sp)
 18052dc:	dc000017 	ldw	r16,0(sp)
 18052e0:	dec00304 	addi	sp,sp,12
 18052e4:	f800283a 	ret

018052e8 <alt_io_redirect>:
 */
 
void alt_io_redirect(const char* stdout_dev, 
                     const char* stdin_dev, 
                     const char* stderr_dev)
{
 18052e8:	defffb04 	addi	sp,sp,-20
 18052ec:	dfc00415 	stw	ra,16(sp)
 18052f0:	df000315 	stw	fp,12(sp)
 18052f4:	df000304 	addi	fp,sp,12
 18052f8:	e13ffd15 	stw	r4,-12(fp)
 18052fc:	e17ffe15 	stw	r5,-8(fp)
 1805300:	e1bfff15 	stw	r6,-4(fp)
  /* Redirect the channels */

  alt_open_fd (&alt_fd_list[STDOUT_FILENO], stdout_dev, O_WRONLY, 0777);
 1805304:	01006074 	movhi	r4,385
 1805308:	21296e04 	addi	r4,r4,-23112
 180530c:	e17ffd17 	ldw	r5,-12(fp)
 1805310:	01800044 	movi	r6,1
 1805314:	01c07fc4 	movi	r7,511
 1805318:	18052100 	call	1805210 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDIN_FILENO], stdin_dev, O_RDONLY, 0777);
 180531c:	01006074 	movhi	r4,385
 1805320:	21296b04 	addi	r4,r4,-23124
 1805324:	e17ffe17 	ldw	r5,-8(fp)
 1805328:	000d883a 	mov	r6,zero
 180532c:	01c07fc4 	movi	r7,511
 1805330:	18052100 	call	1805210 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDERR_FILENO], stderr_dev, O_WRONLY, 0777);
 1805334:	01006074 	movhi	r4,385
 1805338:	21297104 	addi	r4,r4,-23100
 180533c:	e17fff17 	ldw	r5,-4(fp)
 1805340:	01800044 	movi	r6,1
 1805344:	01c07fc4 	movi	r7,511
 1805348:	18052100 	call	1805210 <alt_open_fd>
}  
 180534c:	e037883a 	mov	sp,fp
 1805350:	dfc00117 	ldw	ra,4(sp)
 1805354:	df000017 	ldw	fp,0(sp)
 1805358:	dec00204 	addi	sp,sp,8
 180535c:	f800283a 	ret

01805360 <alt_file_locked>:
 * performed for devices. Filesystems are required to handle the ioctl() call
 * themselves, and report the error from the filesystems open() function. 
 */ 

static int alt_file_locked (alt_fd* fd)
{
 1805360:	defffa04 	addi	sp,sp,-24
 1805364:	dfc00515 	stw	ra,20(sp)
 1805368:	df000415 	stw	fp,16(sp)
 180536c:	dc000315 	stw	r16,12(sp)
 1805370:	df000304 	addi	fp,sp,12
 1805374:	e13ffe15 	stw	r4,-8(fp)

  /*
   * Mark the file descriptor as belonging to a device.
   */

  fd->fd_flags |= ALT_FD_DEV;
 1805378:	e0bffe17 	ldw	r2,-8(fp)
 180537c:	10800217 	ldw	r2,8(r2)
 1805380:	10d00034 	orhi	r3,r2,16384
 1805384:	e0bffe17 	ldw	r2,-8(fp)
 1805388:	10c00215 	stw	r3,8(r2)
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
 180538c:	e03ffd15 	stw	zero,-12(fp)
 1805390:	00002306 	br	1805420 <alt_file_locked+0xc0>
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
 1805394:	e13ffd17 	ldw	r4,-12(fp)
 1805398:	04006074 	movhi	r16,385
 180539c:	84296b04 	addi	r16,r16,-23124
 18053a0:	01400304 	movi	r5,12
 18053a4:	1808b580 	call	1808b58 <__mulsi3>
 18053a8:	1405883a 	add	r2,r2,r16
 18053ac:	10c00017 	ldw	r3,0(r2)
 18053b0:	e0bffe17 	ldw	r2,-8(fp)
 18053b4:	10800017 	ldw	r2,0(r2)
 18053b8:	1880161e 	bne	r3,r2,1805414 <alt_file_locked+0xb4>
 18053bc:	e13ffd17 	ldw	r4,-12(fp)
 18053c0:	04006074 	movhi	r16,385
 18053c4:	84296b04 	addi	r16,r16,-23124
 18053c8:	01400304 	movi	r5,12
 18053cc:	1808b580 	call	1808b58 <__mulsi3>
 18053d0:	1405883a 	add	r2,r2,r16
 18053d4:	10800204 	addi	r2,r2,8
 18053d8:	10800017 	ldw	r2,0(r2)
 18053dc:	1004403a 	cmpge	r2,r2,zero
 18053e0:	10000c1e 	bne	r2,zero,1805414 <alt_file_locked+0xb4>
 18053e4:	e13ffd17 	ldw	r4,-12(fp)
 18053e8:	01400304 	movi	r5,12
 18053ec:	1808b580 	call	1808b58 <__mulsi3>
 18053f0:	1007883a 	mov	r3,r2
 18053f4:	00806074 	movhi	r2,385
 18053f8:	10a96b04 	addi	r2,r2,-23124
 18053fc:	1887883a 	add	r3,r3,r2
 1805400:	e0bffe17 	ldw	r2,-8(fp)
 1805404:	18800326 	beq	r3,r2,1805414 <alt_file_locked+0xb4>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
        (&alt_fd_list[i] != fd))
    {
      return -EACCES;
 1805408:	00bffcc4 	movi	r2,-13
 180540c:	e0bfff15 	stw	r2,-4(fp)
 1805410:	00000a06 	br	180543c <alt_file_locked+0xdc>
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
 1805414:	e0bffd17 	ldw	r2,-12(fp)
 1805418:	10800044 	addi	r2,r2,1
 180541c:	e0bffd15 	stw	r2,-12(fp)
 1805420:	00806074 	movhi	r2,385
 1805424:	10abd104 	addi	r2,r2,-20668
 1805428:	10800017 	ldw	r2,0(r2)
 180542c:	1007883a 	mov	r3,r2
 1805430:	e0bffd17 	ldw	r2,-12(fp)
 1805434:	18bfd72e 	bgeu	r3,r2,1805394 <alt_file_locked+0x34>
    }
  }
  
  /* The device is not locked */
 
  return 0;
 1805438:	e03fff15 	stw	zero,-4(fp)
 180543c:	e0bfff17 	ldw	r2,-4(fp)
}
 1805440:	e037883a 	mov	sp,fp
 1805444:	dfc00217 	ldw	ra,8(sp)
 1805448:	df000117 	ldw	fp,4(sp)
 180544c:	dc000017 	ldw	r16,0(sp)
 1805450:	dec00304 	addi	sp,sp,12
 1805454:	f800283a 	ret

01805458 <open>:
 *
 * ALT_OPEN is mapped onto the open() system call in alt_syscall.h
 */
 
int ALT_OPEN (const char* file, int flags, int mode)
{ 
 1805458:	defff404 	addi	sp,sp,-48
 180545c:	dfc00b15 	stw	ra,44(sp)
 1805460:	df000a15 	stw	fp,40(sp)
 1805464:	df000a04 	addi	fp,sp,40
 1805468:	e13ffb15 	stw	r4,-20(fp)
 180546c:	e17ffc15 	stw	r5,-16(fp)
 1805470:	e1bffd15 	stw	r6,-12(fp)
  alt_dev* dev;
  alt_fd*  fd;
  int index  = -1;
 1805474:	00bfffc4 	movi	r2,-1
 1805478:	e0bff815 	stw	r2,-32(fp)
  int status = -ENODEV;
 180547c:	00bffb44 	movi	r2,-19
 1805480:	e0bff715 	stw	r2,-36(fp)
  int isafs = 0;
 1805484:	e03ff615 	stw	zero,-40(fp)
  /* 
   * Check the device list, to see if a device with a matching name is 
   * registered.
   */
  
  if (!(dev = alt_find_dev (file, &alt_dev_list)))
 1805488:	e13ffb17 	ldw	r4,-20(fp)
 180548c:	01406074 	movhi	r5,385
 1805490:	296bcf04 	addi	r5,r5,-20676
 1805494:	18058d40 	call	18058d4 <alt_find_dev>
 1805498:	e0bffa15 	stw	r2,-24(fp)
 180549c:	e0bffa17 	ldw	r2,-24(fp)
 18054a0:	1004c03a 	cmpne	r2,r2,zero
 18054a4:	1000051e 	bne	r2,zero,18054bc <open+0x64>
  {
    /* No matching device, so try the filesystem list */

    dev   = alt_find_file (file);
 18054a8:	e13ffb17 	ldw	r4,-20(fp)
 18054ac:	18059680 	call	1805968 <alt_find_file>
 18054b0:	e0bffa15 	stw	r2,-24(fp)
    isafs = 1;
 18054b4:	00800044 	movi	r2,1
 18054b8:	e0bff615 	stw	r2,-40(fp)

  /* 
   * If a matching device or filesystem is found, allocate a file descriptor. 
   */

  if (dev)
 18054bc:	e0bffa17 	ldw	r2,-24(fp)
 18054c0:	1005003a 	cmpeq	r2,r2,zero
 18054c4:	1000311e 	bne	r2,zero,180558c <open+0x134>
  {
    if ((index = alt_get_fd (dev)) < 0)
 18054c8:	e13ffa17 	ldw	r4,-24(fp)
 18054cc:	1805a880 	call	1805a88 <alt_get_fd>
 18054d0:	e0bff815 	stw	r2,-32(fp)
 18054d4:	e0bff817 	ldw	r2,-32(fp)
 18054d8:	1004403a 	cmpge	r2,r2,zero
 18054dc:	1000031e 	bne	r2,zero,18054ec <open+0x94>
    {
      status = index;
 18054e0:	e0bff817 	ldw	r2,-32(fp)
 18054e4:	e0bff715 	stw	r2,-36(fp)
 18054e8:	00002a06 	br	1805594 <open+0x13c>
    }
    else
    {
      fd = &alt_fd_list[index];
 18054ec:	e13ff817 	ldw	r4,-32(fp)
 18054f0:	01400304 	movi	r5,12
 18054f4:	1808b580 	call	1808b58 <__mulsi3>
 18054f8:	1007883a 	mov	r3,r2
 18054fc:	00806074 	movhi	r2,385
 1805500:	10a96b04 	addi	r2,r2,-23124
 1805504:	1885883a 	add	r2,r3,r2
 1805508:	e0bff915 	stw	r2,-28(fp)
      fd->fd_flags = (flags & ~ALT_FD_FLAGS_MASK);
 180550c:	e0fffc17 	ldw	r3,-16(fp)
 1805510:	00900034 	movhi	r2,16384
 1805514:	10bfffc4 	addi	r2,r2,-1
 1805518:	1886703a 	and	r3,r3,r2
 180551c:	e0bff917 	ldw	r2,-28(fp)
 1805520:	10c00215 	stw	r3,8(r2)
      
      /* If this is a device, ensure it isn't already locked */

      if (isafs || ((status = alt_file_locked (fd)) >= 0))
 1805524:	e0bff617 	ldw	r2,-40(fp)
 1805528:	1004c03a 	cmpne	r2,r2,zero
 180552c:	1000061e 	bne	r2,zero,1805548 <open+0xf0>
 1805530:	e13ff917 	ldw	r4,-28(fp)
 1805534:	18053600 	call	1805360 <alt_file_locked>
 1805538:	e0bff715 	stw	r2,-36(fp)
 180553c:	e0bff717 	ldw	r2,-36(fp)
 1805540:	1004803a 	cmplt	r2,r2,zero
 1805544:	1000131e 	bne	r2,zero,1805594 <open+0x13c>
        /* 
         * If the device or filesystem provides an open() callback function,
         * call it now to perform any device/filesystem specific operations.
         */
    
        status = (dev->open) ? dev->open(fd, file, flags, mode): 0;
 1805548:	e0bffa17 	ldw	r2,-24(fp)
 180554c:	10800317 	ldw	r2,12(r2)
 1805550:	1005003a 	cmpeq	r2,r2,zero
 1805554:	1000091e 	bne	r2,zero,180557c <open+0x124>
 1805558:	e0bffa17 	ldw	r2,-24(fp)
 180555c:	10800317 	ldw	r2,12(r2)
 1805560:	e13ff917 	ldw	r4,-28(fp)
 1805564:	e17ffb17 	ldw	r5,-20(fp)
 1805568:	e1bffc17 	ldw	r6,-16(fp)
 180556c:	e1fffd17 	ldw	r7,-12(fp)
 1805570:	103ee83a 	callr	r2
 1805574:	e0bfff15 	stw	r2,-4(fp)
 1805578:	00000106 	br	1805580 <open+0x128>
 180557c:	e03fff15 	stw	zero,-4(fp)
 1805580:	e0bfff17 	ldw	r2,-4(fp)
 1805584:	e0bff715 	stw	r2,-36(fp)
 1805588:	00000206 	br	1805594 <open+0x13c>
      }
    }
  }
  else
  {
    status = -ENODEV;
 180558c:	00bffb44 	movi	r2,-19
 1805590:	e0bff715 	stw	r2,-36(fp)
  }

  /* Allocation failed, so clean up and return an error */ 

  if (status < 0)
 1805594:	e0bff717 	ldw	r2,-36(fp)
 1805598:	1004403a 	cmpge	r2,r2,zero
 180559c:	1000091e 	bne	r2,zero,18055c4 <open+0x16c>
  {
    alt_release_fd (index);  
 18055a0:	e13ff817 	ldw	r4,-32(fp)
 18055a4:	18056440 	call	1805644 <alt_release_fd>
    ALT_ERRNO = -status;
 18055a8:	18055e40 	call	18055e4 <alt_get_errno>
 18055ac:	e0fff717 	ldw	r3,-36(fp)
 18055b0:	00c7c83a 	sub	r3,zero,r3
 18055b4:	10c00015 	stw	r3,0(r2)
    return -1;
 18055b8:	00bfffc4 	movi	r2,-1
 18055bc:	e0bffe15 	stw	r2,-8(fp)
 18055c0:	00000206 	br	18055cc <open+0x174>
  }
  
  /* return the reference upon success */

  return index;
 18055c4:	e0bff817 	ldw	r2,-32(fp)
 18055c8:	e0bffe15 	stw	r2,-8(fp)
 18055cc:	e0bffe17 	ldw	r2,-8(fp)
}
 18055d0:	e037883a 	mov	sp,fp
 18055d4:	dfc00117 	ldw	ra,4(sp)
 18055d8:	df000017 	ldw	fp,0(sp)
 18055dc:	dec00204 	addi	sp,sp,8
 18055e0:	f800283a 	ret

018055e4 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 18055e4:	defffd04 	addi	sp,sp,-12
 18055e8:	dfc00215 	stw	ra,8(sp)
 18055ec:	df000115 	stw	fp,4(sp)
 18055f0:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
 18055f4:	00806074 	movhi	r2,385
 18055f8:	10abd204 	addi	r2,r2,-20664
 18055fc:	10800017 	ldw	r2,0(r2)
 1805600:	1005003a 	cmpeq	r2,r2,zero
 1805604:	1000061e 	bne	r2,zero,1805620 <alt_get_errno+0x3c>
 1805608:	00806074 	movhi	r2,385
 180560c:	10abd204 	addi	r2,r2,-20664
 1805610:	10800017 	ldw	r2,0(r2)
 1805614:	103ee83a 	callr	r2
 1805618:	e0bfff15 	stw	r2,-4(fp)
 180561c:	00000306 	br	180562c <alt_get_errno+0x48>
 1805620:	00806074 	movhi	r2,385
 1805624:	10b2a604 	addi	r2,r2,-13672
 1805628:	e0bfff15 	stw	r2,-4(fp)
 180562c:	e0bfff17 	ldw	r2,-4(fp)
}
 1805630:	e037883a 	mov	sp,fp
 1805634:	dfc00117 	ldw	ra,4(sp)
 1805638:	df000017 	ldw	fp,0(sp)
 180563c:	dec00204 	addi	sp,sp,8
 1805640:	f800283a 	ret

01805644 <alt_release_fd>:
 * File descriptors correcponding to standard in, standard out and standard 
 * error cannont be released backed to the pool. They are always reserved.
 */

void alt_release_fd (int fd)
{
 1805644:	defffc04 	addi	sp,sp,-16
 1805648:	dfc00315 	stw	ra,12(sp)
 180564c:	df000215 	stw	fp,8(sp)
 1805650:	dc000115 	stw	r16,4(sp)
 1805654:	df000104 	addi	fp,sp,4
 1805658:	e13fff15 	stw	r4,-4(fp)
  if (fd > 2)
 180565c:	e0bfff17 	ldw	r2,-4(fp)
 1805660:	108000d0 	cmplti	r2,r2,3
 1805664:	10000f1e 	bne	r2,zero,18056a4 <alt_release_fd+0x60>
  {
    alt_fd_list[fd].fd_flags = 0;
 1805668:	e13fff17 	ldw	r4,-4(fp)
 180566c:	04006074 	movhi	r16,385
 1805670:	84296b04 	addi	r16,r16,-23124
 1805674:	01400304 	movi	r5,12
 1805678:	1808b580 	call	1808b58 <__mulsi3>
 180567c:	1405883a 	add	r2,r2,r16
 1805680:	10800204 	addi	r2,r2,8
 1805684:	10000015 	stw	zero,0(r2)
    alt_fd_list[fd].dev      = 0;
 1805688:	e13fff17 	ldw	r4,-4(fp)
 180568c:	04006074 	movhi	r16,385
 1805690:	84296b04 	addi	r16,r16,-23124
 1805694:	01400304 	movi	r5,12
 1805698:	1808b580 	call	1808b58 <__mulsi3>
 180569c:	1405883a 	add	r2,r2,r16
 18056a0:	10000015 	stw	zero,0(r2)
  }
}
 18056a4:	e037883a 	mov	sp,fp
 18056a8:	dfc00217 	ldw	ra,8(sp)
 18056ac:	df000117 	ldw	fp,4(sp)
 18056b0:	dc000017 	ldw	r16,0(sp)
 18056b4:	dec00304 	addi	sp,sp,12
 18056b8:	f800283a 	ret

018056bc <alt_alarm_stop>:
 * alarms. Alternatively an alarm can unregister itself by returning zero when 
 * the alarm executes.
 */

void alt_alarm_stop (alt_alarm* alarm)
{
 18056bc:	defffa04 	addi	sp,sp,-24
 18056c0:	df000515 	stw	fp,20(sp)
 18056c4:	df000504 	addi	fp,sp,20
 18056c8:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 18056cc:	0005303a 	rdctl	r2,status
 18056d0:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 18056d4:	e0fffd17 	ldw	r3,-12(fp)
 18056d8:	00bfff84 	movi	r2,-2
 18056dc:	1884703a 	and	r2,r3,r2
 18056e0:	1001703a 	wrctl	status,r2
  
  return context;
 18056e4:	e0bffd17 	ldw	r2,-12(fp)
  alt_irq_context irq_context;

  irq_context = alt_irq_disable_all();
 18056e8:	e0bffe15 	stw	r2,-8(fp)
  alt_llist_remove (&alarm->llist);
 18056ec:	e0bfff17 	ldw	r2,-4(fp)
 18056f0:	e0bffc15 	stw	r2,-16(fp)
 * input argument is the element to remove.
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
 18056f4:	e0bffc17 	ldw	r2,-16(fp)
 18056f8:	10c00017 	ldw	r3,0(r2)
 18056fc:	e0bffc17 	ldw	r2,-16(fp)
 1805700:	10800117 	ldw	r2,4(r2)
 1805704:	18800115 	stw	r2,4(r3)
  entry->previous->next = entry->next;
 1805708:	e0bffc17 	ldw	r2,-16(fp)
 180570c:	10c00117 	ldw	r3,4(r2)
 1805710:	e0bffc17 	ldw	r2,-16(fp)
 1805714:	10800017 	ldw	r2,0(r2)
 1805718:	18800015 	stw	r2,0(r3)
  /* 
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
 180571c:	e0fffc17 	ldw	r3,-16(fp)
 1805720:	e0bffc17 	ldw	r2,-16(fp)
 1805724:	18800115 	stw	r2,4(r3)
  entry->next     = entry;
 1805728:	e0fffc17 	ldw	r3,-16(fp)
 180572c:	e0bffc17 	ldw	r2,-16(fp)
 1805730:	18800015 	stw	r2,0(r3)
 1805734:	e0bffe17 	ldw	r2,-8(fp)
 1805738:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 180573c:	e0bffb17 	ldw	r2,-20(fp)
 1805740:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (irq_context);
}
 1805744:	e037883a 	mov	sp,fp
 1805748:	df000017 	ldw	fp,0(sp)
 180574c:	dec00104 	addi	sp,sp,4
 1805750:	f800283a 	ret

01805754 <alt_tick>:
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
 1805754:	defffb04 	addi	sp,sp,-20
 1805758:	dfc00415 	stw	ra,16(sp)
 180575c:	df000315 	stw	fp,12(sp)
 1805760:	df000304 	addi	fp,sp,12
  alt_alarm* next;
  alt_alarm* alarm = (alt_alarm*) alt_alarm_list.next;
 1805764:	d0a00717 	ldw	r2,-32740(gp)
 1805768:	e0bffe15 	stw	r2,-8(fp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
 180576c:	d0a6d817 	ldw	r2,-25760(gp)
 1805770:	10800044 	addi	r2,r2,1
 1805774:	d0a6d815 	stw	r2,-25760(gp)

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
 1805778:	00003106 	br	1805840 <alt_tick+0xec>
  {
    next = (alt_alarm*) alarm->llist.next;
 180577c:	e0bffe17 	ldw	r2,-8(fp)
 1805780:	10800017 	ldw	r2,0(r2)
 1805784:	e0bfff15 	stw	r2,-4(fp)
    /* 
     * Upon the tick-counter rolling over it is safe to clear the 
     * roll-over flag; once the flag is cleared this (or subsequnt)
     * tick events are enabled to generate an alarm event. 
     */
    if ((alarm->rollover) && (_alt_nticks == 0))
 1805788:	e0bffe17 	ldw	r2,-8(fp)
 180578c:	10800403 	ldbu	r2,16(r2)
 1805790:	10803fcc 	andi	r2,r2,255
 1805794:	1005003a 	cmpeq	r2,r2,zero
 1805798:	1000051e 	bne	r2,zero,18057b0 <alt_tick+0x5c>
 180579c:	d0a6d817 	ldw	r2,-25760(gp)
 18057a0:	1004c03a 	cmpne	r2,r2,zero
 18057a4:	1000021e 	bne	r2,zero,18057b0 <alt_tick+0x5c>
    {
      alarm->rollover = 0;
 18057a8:	e0bffe17 	ldw	r2,-8(fp)
 18057ac:	10000405 	stb	zero,16(r2)
    }
    
    /* if the alarm period has expired, make the callback */    
    if ((alarm->time <= _alt_nticks) && (alarm->rollover == 0))
 18057b0:	e0bffe17 	ldw	r2,-8(fp)
 18057b4:	10c00217 	ldw	r3,8(r2)
 18057b8:	d0a6d817 	ldw	r2,-25760(gp)
 18057bc:	10c01e36 	bltu	r2,r3,1805838 <alt_tick+0xe4>
 18057c0:	e0bffe17 	ldw	r2,-8(fp)
 18057c4:	10800403 	ldbu	r2,16(r2)
 18057c8:	10803fcc 	andi	r2,r2,255
 18057cc:	1004c03a 	cmpne	r2,r2,zero
 18057d0:	1000191e 	bne	r2,zero,1805838 <alt_tick+0xe4>
    {
      next_callback = alarm->callback (alarm->context);
 18057d4:	e0bffe17 	ldw	r2,-8(fp)
 18057d8:	10c00317 	ldw	r3,12(r2)
 18057dc:	e0bffe17 	ldw	r2,-8(fp)
 18057e0:	11000517 	ldw	r4,20(r2)
 18057e4:	183ee83a 	callr	r3
 18057e8:	e0bffd15 	stw	r2,-12(fp)

      /* deactivate the alarm if the return value is zero */

      if (next_callback == 0)
 18057ec:	e0bffd17 	ldw	r2,-12(fp)
 18057f0:	1004c03a 	cmpne	r2,r2,zero
 18057f4:	1000031e 	bne	r2,zero,1805804 <alt_tick+0xb0>
      {
        alt_alarm_stop (alarm);
 18057f8:	e13ffe17 	ldw	r4,-8(fp)
 18057fc:	18056bc0 	call	18056bc <alt_alarm_stop>
 1805800:	00000d06 	br	1805838 <alt_tick+0xe4>
      }
      else
      {
        alarm->time += next_callback;
 1805804:	e0bffe17 	ldw	r2,-8(fp)
 1805808:	10c00217 	ldw	r3,8(r2)
 180580c:	e0bffd17 	ldw	r2,-12(fp)
 1805810:	1887883a 	add	r3,r3,r2
 1805814:	e0bffe17 	ldw	r2,-8(fp)
 1805818:	10c00215 	stw	r3,8(r2)
        /* 
         * If the desired alarm time causes a roll-over, set the rollover
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
 180581c:	e0bffe17 	ldw	r2,-8(fp)
 1805820:	10c00217 	ldw	r3,8(r2)
 1805824:	d0a6d817 	ldw	r2,-25760(gp)
 1805828:	1880032e 	bgeu	r3,r2,1805838 <alt_tick+0xe4>
        {
          alarm->rollover = 1;
 180582c:	e0fffe17 	ldw	r3,-8(fp)
 1805830:	00800044 	movi	r2,1
 1805834:	18800405 	stb	r2,16(r3)
        }
      }
    }
    alarm = next;
 1805838:	e0bfff17 	ldw	r2,-4(fp)
 180583c:	e0bffe15 	stw	r2,-8(fp)

  _alt_nticks++;

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
 1805840:	d0e00704 	addi	r3,gp,-32740
 1805844:	e0bffe17 	ldw	r2,-8(fp)
 1805848:	10ffcc1e 	bne	r2,r3,180577c <alt_tick+0x28>

  /* 
   * Update the operating system specific timer facilities.
   */

  ALT_OS_TIME_TICK();
 180584c:	18058ac0 	call	18058ac <port_time_tick>
}
 1805850:	e037883a 	mov	sp,fp
 1805854:	dfc00117 	ldw	ra,4(sp)
 1805858:	df000017 	ldw	fp,0(sp)
 180585c:	dec00204 	addi	sp,sp,8
 1805860:	f800283a 	ret

01805864 <altera_nios2_qsys_irq_init>:
/*
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_qsys_irq_init(void) 
{
 1805864:	deffff04 	addi	sp,sp,-4
 1805868:	df000015 	stw	fp,0(sp)
 180586c:	d839883a 	mov	fp,sp
    NIOS2_WRITE_IENABLE(0);
 1805870:	000170fa 	wrctl	ienable,zero
}
 1805874:	e037883a 	mov	sp,fp
 1805878:	df000017 	ldw	fp,0(sp)
 180587c:	dec00104 	addi	sp,sp,4
 1805880:	f800283a 	ret

01805884 <port_halt>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
void port_halt (void) 
{
 1805884:	defffe04 	addi	sp,sp,-8
 1805888:	df000115 	stw	fp,4(sp)
 180588c:	df000104 	addi	fp,sp,4
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 1805890:	0005303a 	rdctl	r2,status
 1805894:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 1805898:	e0ffff17 	ldw	r3,-4(fp)
 180589c:	00bfff84 	movi	r2,-2
 18058a0:	1884703a 	and	r2,r3,r2
 18058a4:	1001703a 	wrctl	status,r2
   port_disable();
   while (TRUE) 
   {
   }  
 18058a8:	003fff06 	br	18058a8 <port_halt+0x24>

018058ac <port_time_tick>:
/*
 * ChibiOS time tick, called by the Nios
 * hal.sys_clk_timer.
 */
CH_IRQ_HANDLER (port_time_tick)
{
 18058ac:	defffe04 	addi	sp,sp,-8
 18058b0:	dfc00115 	stw	ra,4(sp)
 18058b4:	df000015 	stw	fp,0(sp)
 18058b8:	d839883a 	mov	fp,sp
   CH_IRQ_PROLOGUE();

   chSysLockFromIsr();
   chSysTimerHandlerI();
 18058bc:	18049240 	call	1804924 <chSysTimerHandlerI>
   chSysUnlockFromIsr();

   CH_IRQ_EPILOGUE();
} /* port_time_tick */
 18058c0:	e037883a 	mov	sp,fp
 18058c4:	dfc00117 	ldw	ra,4(sp)
 18058c8:	df000017 	ldw	fp,0(sp)
 18058cc:	dec00204 	addi	sp,sp,8
 18058d0:	f800283a 	ret

018058d4 <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
 18058d4:	defff904 	addi	sp,sp,-28
 18058d8:	dfc00615 	stw	ra,24(sp)
 18058dc:	df000515 	stw	fp,20(sp)
 18058e0:	df000504 	addi	fp,sp,20
 18058e4:	e13ffd15 	stw	r4,-12(fp)
 18058e8:	e17ffe15 	stw	r5,-8(fp)
  alt_dev* next = (alt_dev*) llist->next;
 18058ec:	e0bffe17 	ldw	r2,-8(fp)
 18058f0:	10800017 	ldw	r2,0(r2)
 18058f4:	e0bffc15 	stw	r2,-16(fp)
  alt_32 len;

  len  = strlen(name) + 1;
 18058f8:	e13ffd17 	ldw	r4,-12(fp)
 18058fc:	18073380 	call	1807338 <strlen>
 1805900:	10800044 	addi	r2,r2,1
 1805904:	e0bffb15 	stw	r2,-20(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
 1805908:	00000d06 	br	1805940 <alt_find_dev+0x6c>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
 180590c:	e0bffc17 	ldw	r2,-16(fp)
 1805910:	11000217 	ldw	r4,8(r2)
 1805914:	e1bffb17 	ldw	r6,-20(fp)
 1805918:	e17ffd17 	ldw	r5,-12(fp)
 180591c:	18068f40 	call	18068f4 <memcmp>
 1805920:	1004c03a 	cmpne	r2,r2,zero
 1805924:	1000031e 	bne	r2,zero,1805934 <alt_find_dev+0x60>
    {
      /* match found */

      return next;
 1805928:	e0bffc17 	ldw	r2,-16(fp)
 180592c:	e0bfff15 	stw	r2,-4(fp)
 1805930:	00000706 	br	1805950 <alt_find_dev+0x7c>
    }
    next = (alt_dev*) next->llist.next;
 1805934:	e0bffc17 	ldw	r2,-16(fp)
 1805938:	10800017 	ldw	r2,0(r2)
 180593c:	e0bffc15 	stw	r2,-16(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
 1805940:	e0fffe17 	ldw	r3,-8(fp)
 1805944:	e0bffc17 	ldw	r2,-16(fp)
 1805948:	10fff01e 	bne	r2,r3,180590c <alt_find_dev+0x38>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;
 180594c:	e03fff15 	stw	zero,-4(fp)
 1805950:	e0bfff17 	ldw	r2,-4(fp)
}
 1805954:	e037883a 	mov	sp,fp
 1805958:	dfc00117 	ldw	ra,4(sp)
 180595c:	df000017 	ldw	fp,0(sp)
 1805960:	dec00204 	addi	sp,sp,8
 1805964:	f800283a 	ret

01805968 <alt_find_file>:
 * either '/' or '\0' is the prefix of the filename. For example the filename:
 * "/myfilesystem/junk.txt" would match: "/myfilesystem", but not: "/myfile". 
 */
 
alt_dev* alt_find_file (const char* name)
{
 1805968:	defffa04 	addi	sp,sp,-24
 180596c:	dfc00515 	stw	ra,20(sp)
 1805970:	df000415 	stw	fp,16(sp)
 1805974:	df000404 	addi	fp,sp,16
 1805978:	e13ffe15 	stw	r4,-8(fp)
  alt_dev* next = (alt_dev*) alt_fs_list.next;   
 180597c:	00806074 	movhi	r2,385
 1805980:	10abcd04 	addi	r2,r2,-20684
 1805984:	10800017 	ldw	r2,0(r2)
 1805988:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
 180598c:	00003306 	br	1805a5c <alt_find_file+0xf4>
  {
    len = strlen(next->name);
 1805990:	e0bffd17 	ldw	r2,-12(fp)
 1805994:	11000217 	ldw	r4,8(r2)
 1805998:	18073380 	call	1807338 <strlen>
 180599c:	e0bffc15 	stw	r2,-16(fp)
    
    if (next->name[len-1] == '/')
 18059a0:	e0bffd17 	ldw	r2,-12(fp)
 18059a4:	10c00217 	ldw	r3,8(r2)
 18059a8:	e0bffc17 	ldw	r2,-16(fp)
 18059ac:	1885883a 	add	r2,r3,r2
 18059b0:	10bfffc4 	addi	r2,r2,-1
 18059b4:	10800003 	ldbu	r2,0(r2)
 18059b8:	10803fcc 	andi	r2,r2,255
 18059bc:	1080201c 	xori	r2,r2,128
 18059c0:	10bfe004 	addi	r2,r2,-128
 18059c4:	10800bd8 	cmpnei	r2,r2,47
 18059c8:	1000031e 	bne	r2,zero,18059d8 <alt_find_file+0x70>
    {
      len -= 1;
 18059cc:	e0bffc17 	ldw	r2,-16(fp)
 18059d0:	10bfffc4 	addi	r2,r2,-1
 18059d4:	e0bffc15 	stw	r2,-16(fp)
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
 18059d8:	e0bffc17 	ldw	r2,-16(fp)
 18059dc:	1007883a 	mov	r3,r2
 18059e0:	e0bffe17 	ldw	r2,-8(fp)
 18059e4:	1885883a 	add	r2,r3,r2
 18059e8:	10800003 	ldbu	r2,0(r2)
 18059ec:	10803fcc 	andi	r2,r2,255
 18059f0:	1080201c 	xori	r2,r2,128
 18059f4:	10bfe004 	addi	r2,r2,-128
 18059f8:	10800be0 	cmpeqi	r2,r2,47
 18059fc:	10000a1e 	bne	r2,zero,1805a28 <alt_find_file+0xc0>
 1805a00:	e0bffc17 	ldw	r2,-16(fp)
 1805a04:	1007883a 	mov	r3,r2
 1805a08:	e0bffe17 	ldw	r2,-8(fp)
 1805a0c:	1885883a 	add	r2,r3,r2
 1805a10:	10800003 	ldbu	r2,0(r2)
 1805a14:	10803fcc 	andi	r2,r2,255
 1805a18:	1080201c 	xori	r2,r2,128
 1805a1c:	10bfe004 	addi	r2,r2,-128
 1805a20:	1004c03a 	cmpne	r2,r2,zero
 1805a24:	10000a1e 	bne	r2,zero,1805a50 <alt_find_file+0xe8>
 1805a28:	e0bffd17 	ldw	r2,-12(fp)
 1805a2c:	11000217 	ldw	r4,8(r2)
 1805a30:	e1bffc17 	ldw	r6,-16(fp)
 1805a34:	e17ffe17 	ldw	r5,-8(fp)
 1805a38:	18068f40 	call	18068f4 <memcmp>
 1805a3c:	1004c03a 	cmpne	r2,r2,zero
 1805a40:	1000031e 	bne	r2,zero,1805a50 <alt_find_file+0xe8>
        !memcmp (next->name, name, len))
    {
      /* match found */

      return next;
 1805a44:	e0bffd17 	ldw	r2,-12(fp)
 1805a48:	e0bfff15 	stw	r2,-4(fp)
 1805a4c:	00000806 	br	1805a70 <alt_find_file+0x108>
    }
    next = (alt_dev*) next->llist.next;
 1805a50:	e0bffd17 	ldw	r2,-12(fp)
 1805a54:	10800017 	ldw	r2,0(r2)
 1805a58:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
 1805a5c:	00c06074 	movhi	r3,385
 1805a60:	18ebcd04 	addi	r3,r3,-20684
 1805a64:	e0bffd17 	ldw	r2,-12(fp)
 1805a68:	10ffc91e 	bne	r2,r3,1805990 <alt_find_file+0x28>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;     
 1805a6c:	e03fff15 	stw	zero,-4(fp)
 1805a70:	e0bfff17 	ldw	r2,-4(fp)
}
 1805a74:	e037883a 	mov	sp,fp
 1805a78:	dfc00117 	ldw	ra,4(sp)
 1805a7c:	df000017 	ldw	fp,0(sp)
 1805a80:	dec00204 	addi	sp,sp,8
 1805a84:	f800283a 	ret

01805a88 <alt_get_fd>:
 * the offset of the file descriptor within the file descriptor array). A
 * negative value indicates failure.
 */

int alt_get_fd (alt_dev* dev)
{
 1805a88:	defffa04 	addi	sp,sp,-24
 1805a8c:	dfc00515 	stw	ra,20(sp)
 1805a90:	df000415 	stw	fp,16(sp)
 1805a94:	dc000315 	stw	r16,12(sp)
 1805a98:	df000304 	addi	fp,sp,12
 1805a9c:	e13fff15 	stw	r4,-4(fp)
  alt_32 i;
  int rc = -EMFILE;
 1805aa0:	00bffa04 	movi	r2,-24
 1805aa4:	e0bffd15 	stw	r2,-12(fp)
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
 1805aa8:	e03ffe15 	stw	zero,-8(fp)
 1805aac:	00002006 	br	1805b30 <alt_get_fd+0xa8>
  {
    if (!alt_fd_list[i].dev)
 1805ab0:	e13ffe17 	ldw	r4,-8(fp)
 1805ab4:	04006074 	movhi	r16,385
 1805ab8:	84296b04 	addi	r16,r16,-23124
 1805abc:	01400304 	movi	r5,12
 1805ac0:	1808b580 	call	1808b58 <__mulsi3>
 1805ac4:	1405883a 	add	r2,r2,r16
 1805ac8:	10800017 	ldw	r2,0(r2)
 1805acc:	1004c03a 	cmpne	r2,r2,zero
 1805ad0:	1000141e 	bne	r2,zero,1805b24 <alt_get_fd+0x9c>
    {
      alt_fd_list[i].dev = dev;
 1805ad4:	e13ffe17 	ldw	r4,-8(fp)
 1805ad8:	04006074 	movhi	r16,385
 1805adc:	84296b04 	addi	r16,r16,-23124
 1805ae0:	01400304 	movi	r5,12
 1805ae4:	1808b580 	call	1808b58 <__mulsi3>
 1805ae8:	1407883a 	add	r3,r2,r16
 1805aec:	e0bfff17 	ldw	r2,-4(fp)
 1805af0:	18800015 	stw	r2,0(r3)
      if (i > alt_max_fd)
 1805af4:	00806074 	movhi	r2,385
 1805af8:	10abd104 	addi	r2,r2,-20668
 1805afc:	10c00017 	ldw	r3,0(r2)
 1805b00:	e0bffe17 	ldw	r2,-8(fp)
 1805b04:	1880040e 	bge	r3,r2,1805b18 <alt_get_fd+0x90>
      {
        alt_max_fd = i;
 1805b08:	00c06074 	movhi	r3,385
 1805b0c:	18ebd104 	addi	r3,r3,-20668
 1805b10:	e0bffe17 	ldw	r2,-8(fp)
 1805b14:	18800015 	stw	r2,0(r3)
      }
      rc = i;
 1805b18:	e0bffe17 	ldw	r2,-8(fp)
 1805b1c:	e0bffd15 	stw	r2,-12(fp)
      goto alt_get_fd_exit;
 1805b20:	00000606 	br	1805b3c <alt_get_fd+0xb4>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
 1805b24:	e0bffe17 	ldw	r2,-8(fp)
 1805b28:	10800044 	addi	r2,r2,1
 1805b2c:	e0bffe15 	stw	r2,-8(fp)
 1805b30:	e0bffe17 	ldw	r2,-8(fp)
 1805b34:	10800810 	cmplti	r2,r2,32
 1805b38:	103fdd1e 	bne	r2,zero,1805ab0 <alt_get_fd+0x28>
   * file descriptor pool.
   */

  ALT_SEM_POST(alt_fd_list_lock);

  return rc;
 1805b3c:	e0bffd17 	ldw	r2,-12(fp)
}
 1805b40:	e037883a 	mov	sp,fp
 1805b44:	dfc00217 	ldw	ra,8(sp)
 1805b48:	df000117 	ldw	fp,4(sp)
 1805b4c:	dc000017 	ldw	r16,0(sp)
 1805b50:	dec00304 	addi	sp,sp,12
 1805b54:	f800283a 	ret

01805b58 <atexit>:
 1805b58:	200b883a 	mov	r5,r4
 1805b5c:	000d883a 	mov	r6,zero
 1805b60:	0009883a 	mov	r4,zero
 1805b64:	000f883a 	mov	r7,zero
 1805b68:	18076341 	jmpi	1807634 <__register_exitproc>

01805b6c <exit>:
 1805b6c:	defffe04 	addi	sp,sp,-8
 1805b70:	000b883a 	mov	r5,zero
 1805b74:	dc000015 	stw	r16,0(sp)
 1805b78:	dfc00115 	stw	ra,4(sp)
 1805b7c:	2021883a 	mov	r16,r4
 1805b80:	180776c0 	call	180776c <__call_exitprocs>
 1805b84:	00806074 	movhi	r2,385
 1805b88:	10abd704 	addi	r2,r2,-20644
 1805b8c:	11000017 	ldw	r4,0(r2)
 1805b90:	20800f17 	ldw	r2,60(r4)
 1805b94:	10000126 	beq	r2,zero,1805b9c <exit+0x30>
 1805b98:	103ee83a 	callr	r2
 1805b9c:	8009883a 	mov	r4,r16
 1805ba0:	1808bd00 	call	1808bd0 <_exit>

01805ba4 <_fputs_r>:
 1805ba4:	defff804 	addi	sp,sp,-32
 1805ba8:	dc000515 	stw	r16,20(sp)
 1805bac:	2021883a 	mov	r16,r4
 1805bb0:	2809883a 	mov	r4,r5
 1805bb4:	dc400615 	stw	r17,24(sp)
 1805bb8:	dfc00715 	stw	ra,28(sp)
 1805bbc:	3023883a 	mov	r17,r6
 1805bc0:	d9400015 	stw	r5,0(sp)
 1805bc4:	18073380 	call	1807338 <strlen>
 1805bc8:	00c00044 	movi	r3,1
 1805bcc:	d8800115 	stw	r2,4(sp)
 1805bd0:	d8c00315 	stw	r3,12(sp)
 1805bd4:	d8800415 	stw	r2,16(sp)
 1805bd8:	dec00215 	stw	sp,8(sp)
 1805bdc:	80000326 	beq	r16,zero,1805bec <_fputs_r+0x48>
 1805be0:	80800e17 	ldw	r2,56(r16)
 1805be4:	8009883a 	mov	r4,r16
 1805be8:	10000926 	beq	r2,zero,1805c10 <_fputs_r+0x6c>
 1805bec:	8009883a 	mov	r4,r16
 1805bf0:	880b883a 	mov	r5,r17
 1805bf4:	d9800204 	addi	r6,sp,8
 1805bf8:	1805c340 	call	1805c34 <__sfvwrite_r>
 1805bfc:	dfc00717 	ldw	ra,28(sp)
 1805c00:	dc400617 	ldw	r17,24(sp)
 1805c04:	dc000517 	ldw	r16,20(sp)
 1805c08:	dec00804 	addi	sp,sp,32
 1805c0c:	f800283a 	ret
 1805c10:	1807bb40 	call	1807bb4 <__sinit>
 1805c14:	003ff506 	br	1805bec <_fputs_r+0x48>

01805c18 <fputs>:
 1805c18:	01806074 	movhi	r6,385
 1805c1c:	31abd604 	addi	r6,r6,-20648
 1805c20:	2007883a 	mov	r3,r4
 1805c24:	31000017 	ldw	r4,0(r6)
 1805c28:	280d883a 	mov	r6,r5
 1805c2c:	180b883a 	mov	r5,r3
 1805c30:	1805ba41 	jmpi	1805ba4 <_fputs_r>

01805c34 <__sfvwrite_r>:
 1805c34:	30800217 	ldw	r2,8(r6)
 1805c38:	defff504 	addi	sp,sp,-44
 1805c3c:	df000915 	stw	fp,36(sp)
 1805c40:	dd800715 	stw	r22,28(sp)
 1805c44:	dc800315 	stw	r18,12(sp)
 1805c48:	dfc00a15 	stw	ra,40(sp)
 1805c4c:	ddc00815 	stw	r23,32(sp)
 1805c50:	dd400615 	stw	r21,24(sp)
 1805c54:	dd000515 	stw	r20,20(sp)
 1805c58:	dcc00415 	stw	r19,16(sp)
 1805c5c:	dc400215 	stw	r17,8(sp)
 1805c60:	dc000115 	stw	r16,4(sp)
 1805c64:	302d883a 	mov	r22,r6
 1805c68:	2039883a 	mov	fp,r4
 1805c6c:	2825883a 	mov	r18,r5
 1805c70:	10001c26 	beq	r2,zero,1805ce4 <__sfvwrite_r+0xb0>
 1805c74:	29c0030b 	ldhu	r7,12(r5)
 1805c78:	3880020c 	andi	r2,r7,8
 1805c7c:	10002726 	beq	r2,zero,1805d1c <__sfvwrite_r+0xe8>
 1805c80:	28800417 	ldw	r2,16(r5)
 1805c84:	10002526 	beq	r2,zero,1805d1c <__sfvwrite_r+0xe8>
 1805c88:	3880008c 	andi	r2,r7,2
 1805c8c:	b5400017 	ldw	r21,0(r22)
 1805c90:	10002826 	beq	r2,zero,1805d34 <__sfvwrite_r+0x100>
 1805c94:	0021883a 	mov	r16,zero
 1805c98:	0023883a 	mov	r17,zero
 1805c9c:	880d883a 	mov	r6,r17
 1805ca0:	e009883a 	mov	r4,fp
 1805ca4:	00810004 	movi	r2,1024
 1805ca8:	80006e26 	beq	r16,zero,1805e64 <__sfvwrite_r+0x230>
 1805cac:	800f883a 	mov	r7,r16
 1805cb0:	91400717 	ldw	r5,28(r18)
 1805cb4:	1400012e 	bgeu	r2,r16,1805cbc <__sfvwrite_r+0x88>
 1805cb8:	100f883a 	mov	r7,r2
 1805cbc:	90c00917 	ldw	r3,36(r18)
 1805cc0:	183ee83a 	callr	r3
 1805cc4:	1007883a 	mov	r3,r2
 1805cc8:	80a1c83a 	sub	r16,r16,r2
 1805ccc:	88a3883a 	add	r17,r17,r2
 1805cd0:	00806d0e 	bge	zero,r2,1805e88 <__sfvwrite_r+0x254>
 1805cd4:	b0800217 	ldw	r2,8(r22)
 1805cd8:	10c5c83a 	sub	r2,r2,r3
 1805cdc:	b0800215 	stw	r2,8(r22)
 1805ce0:	103fee1e 	bne	r2,zero,1805c9c <__sfvwrite_r+0x68>
 1805ce4:	0009883a 	mov	r4,zero
 1805ce8:	2005883a 	mov	r2,r4
 1805cec:	dfc00a17 	ldw	ra,40(sp)
 1805cf0:	df000917 	ldw	fp,36(sp)
 1805cf4:	ddc00817 	ldw	r23,32(sp)
 1805cf8:	dd800717 	ldw	r22,28(sp)
 1805cfc:	dd400617 	ldw	r21,24(sp)
 1805d00:	dd000517 	ldw	r20,20(sp)
 1805d04:	dcc00417 	ldw	r19,16(sp)
 1805d08:	dc800317 	ldw	r18,12(sp)
 1805d0c:	dc400217 	ldw	r17,8(sp)
 1805d10:	dc000117 	ldw	r16,4(sp)
 1805d14:	dec00b04 	addi	sp,sp,44
 1805d18:	f800283a 	ret
 1805d1c:	18074f80 	call	18074f8 <__swsetup_r>
 1805d20:	1000e41e 	bne	r2,zero,18060b4 <__sfvwrite_r+0x480>
 1805d24:	91c0030b 	ldhu	r7,12(r18)
 1805d28:	b5400017 	ldw	r21,0(r22)
 1805d2c:	3880008c 	andi	r2,r7,2
 1805d30:	103fd81e 	bne	r2,zero,1805c94 <__sfvwrite_r+0x60>
 1805d34:	3880004c 	andi	r2,r7,1
 1805d38:	1005003a 	cmpeq	r2,r2,zero
 1805d3c:	10005726 	beq	r2,zero,1805e9c <__sfvwrite_r+0x268>
 1805d40:	0029883a 	mov	r20,zero
 1805d44:	002f883a 	mov	r23,zero
 1805d48:	a0004226 	beq	r20,zero,1805e54 <__sfvwrite_r+0x220>
 1805d4c:	3880800c 	andi	r2,r7,512
 1805d50:	94000217 	ldw	r16,8(r18)
 1805d54:	10008b26 	beq	r2,zero,1805f84 <__sfvwrite_r+0x350>
 1805d58:	800d883a 	mov	r6,r16
 1805d5c:	a400a536 	bltu	r20,r16,1805ff4 <__sfvwrite_r+0x3c0>
 1805d60:	3881200c 	andi	r2,r7,1152
 1805d64:	10002726 	beq	r2,zero,1805e04 <__sfvwrite_r+0x1d0>
 1805d68:	90800517 	ldw	r2,20(r18)
 1805d6c:	92000417 	ldw	r8,16(r18)
 1805d70:	91400017 	ldw	r5,0(r18)
 1805d74:	1087883a 	add	r3,r2,r2
 1805d78:	1887883a 	add	r3,r3,r2
 1805d7c:	1808d7fa 	srli	r4,r3,31
 1805d80:	2a21c83a 	sub	r16,r5,r8
 1805d84:	80800044 	addi	r2,r16,1
 1805d88:	20c9883a 	add	r4,r4,r3
 1805d8c:	2027d07a 	srai	r19,r4,1
 1805d90:	a085883a 	add	r2,r20,r2
 1805d94:	980d883a 	mov	r6,r19
 1805d98:	9880022e 	bgeu	r19,r2,1805da4 <__sfvwrite_r+0x170>
 1805d9c:	1027883a 	mov	r19,r2
 1805da0:	100d883a 	mov	r6,r2
 1805da4:	3881000c 	andi	r2,r7,1024
 1805da8:	1000b826 	beq	r2,zero,180608c <__sfvwrite_r+0x458>
 1805dac:	300b883a 	mov	r5,r6
 1805db0:	e009883a 	mov	r4,fp
 1805db4:	18060d00 	call	18060d0 <_malloc_r>
 1805db8:	10003126 	beq	r2,zero,1805e80 <__sfvwrite_r+0x24c>
 1805dbc:	91400417 	ldw	r5,16(r18)
 1805dc0:	1009883a 	mov	r4,r2
 1805dc4:	800d883a 	mov	r6,r16
 1805dc8:	1023883a 	mov	r17,r2
 1805dcc:	18069680 	call	1806968 <memcpy>
 1805dd0:	90c0030b 	ldhu	r3,12(r18)
 1805dd4:	00beffc4 	movi	r2,-1025
 1805dd8:	1886703a 	and	r3,r3,r2
 1805ddc:	18c02014 	ori	r3,r3,128
 1805de0:	90c0030d 	sth	r3,12(r18)
 1805de4:	9c07c83a 	sub	r3,r19,r16
 1805de8:	8c05883a 	add	r2,r17,r16
 1805dec:	a00d883a 	mov	r6,r20
 1805df0:	a021883a 	mov	r16,r20
 1805df4:	90800015 	stw	r2,0(r18)
 1805df8:	90c00215 	stw	r3,8(r18)
 1805dfc:	94400415 	stw	r17,16(r18)
 1805e00:	94c00515 	stw	r19,20(r18)
 1805e04:	91000017 	ldw	r4,0(r18)
 1805e08:	b80b883a 	mov	r5,r23
 1805e0c:	a023883a 	mov	r17,r20
 1805e10:	1806a080 	call	1806a08 <memmove>
 1805e14:	90c00217 	ldw	r3,8(r18)
 1805e18:	90800017 	ldw	r2,0(r18)
 1805e1c:	a027883a 	mov	r19,r20
 1805e20:	1c07c83a 	sub	r3,r3,r16
 1805e24:	1405883a 	add	r2,r2,r16
 1805e28:	90c00215 	stw	r3,8(r18)
 1805e2c:	a021883a 	mov	r16,r20
 1805e30:	90800015 	stw	r2,0(r18)
 1805e34:	b0800217 	ldw	r2,8(r22)
 1805e38:	1405c83a 	sub	r2,r2,r16
 1805e3c:	b0800215 	stw	r2,8(r22)
 1805e40:	103fa826 	beq	r2,zero,1805ce4 <__sfvwrite_r+0xb0>
 1805e44:	a469c83a 	sub	r20,r20,r17
 1805e48:	91c0030b 	ldhu	r7,12(r18)
 1805e4c:	bcef883a 	add	r23,r23,r19
 1805e50:	a03fbe1e 	bne	r20,zero,1805d4c <__sfvwrite_r+0x118>
 1805e54:	adc00017 	ldw	r23,0(r21)
 1805e58:	ad000117 	ldw	r20,4(r21)
 1805e5c:	ad400204 	addi	r21,r21,8
 1805e60:	003fb906 	br	1805d48 <__sfvwrite_r+0x114>
 1805e64:	ac400017 	ldw	r17,0(r21)
 1805e68:	ac000117 	ldw	r16,4(r21)
 1805e6c:	ad400204 	addi	r21,r21,8
 1805e70:	003f8a06 	br	1805c9c <__sfvwrite_r+0x68>
 1805e74:	91400417 	ldw	r5,16(r18)
 1805e78:	e009883a 	mov	r4,fp
 1805e7c:	1807f6c0 	call	1807f6c <_free_r>
 1805e80:	00800304 	movi	r2,12
 1805e84:	e0800015 	stw	r2,0(fp)
 1805e88:	9080030b 	ldhu	r2,12(r18)
 1805e8c:	013fffc4 	movi	r4,-1
 1805e90:	10801014 	ori	r2,r2,64
 1805e94:	9080030d 	sth	r2,12(r18)
 1805e98:	003f9306 	br	1805ce8 <__sfvwrite_r+0xb4>
 1805e9c:	0027883a 	mov	r19,zero
 1805ea0:	002f883a 	mov	r23,zero
 1805ea4:	d8000015 	stw	zero,0(sp)
 1805ea8:	0029883a 	mov	r20,zero
 1805eac:	98001e26 	beq	r19,zero,1805f28 <__sfvwrite_r+0x2f4>
 1805eb0:	d8c00017 	ldw	r3,0(sp)
 1805eb4:	1804c03a 	cmpne	r2,r3,zero
 1805eb8:	10005e26 	beq	r2,zero,1806034 <__sfvwrite_r+0x400>
 1805ebc:	9821883a 	mov	r16,r19
 1805ec0:	a4c0012e 	bgeu	r20,r19,1805ec8 <__sfvwrite_r+0x294>
 1805ec4:	a021883a 	mov	r16,r20
 1805ec8:	91000017 	ldw	r4,0(r18)
 1805ecc:	90800417 	ldw	r2,16(r18)
 1805ed0:	91800217 	ldw	r6,8(r18)
 1805ed4:	91c00517 	ldw	r7,20(r18)
 1805ed8:	1100022e 	bgeu	r2,r4,1805ee4 <__sfvwrite_r+0x2b0>
 1805edc:	31e3883a 	add	r17,r6,r7
 1805ee0:	8c001616 	blt	r17,r16,1805f3c <__sfvwrite_r+0x308>
 1805ee4:	81c03816 	blt	r16,r7,1805fc8 <__sfvwrite_r+0x394>
 1805ee8:	90c00917 	ldw	r3,36(r18)
 1805eec:	91400717 	ldw	r5,28(r18)
 1805ef0:	e009883a 	mov	r4,fp
 1805ef4:	b80d883a 	mov	r6,r23
 1805ef8:	183ee83a 	callr	r3
 1805efc:	1023883a 	mov	r17,r2
 1805f00:	00bfe10e 	bge	zero,r2,1805e88 <__sfvwrite_r+0x254>
 1805f04:	a469c83a 	sub	r20,r20,r17
 1805f08:	a0001826 	beq	r20,zero,1805f6c <__sfvwrite_r+0x338>
 1805f0c:	b0800217 	ldw	r2,8(r22)
 1805f10:	1445c83a 	sub	r2,r2,r17
 1805f14:	b0800215 	stw	r2,8(r22)
 1805f18:	103f7226 	beq	r2,zero,1805ce4 <__sfvwrite_r+0xb0>
 1805f1c:	9c67c83a 	sub	r19,r19,r17
 1805f20:	bc6f883a 	add	r23,r23,r17
 1805f24:	983fe21e 	bne	r19,zero,1805eb0 <__sfvwrite_r+0x27c>
 1805f28:	adc00017 	ldw	r23,0(r21)
 1805f2c:	acc00117 	ldw	r19,4(r21)
 1805f30:	ad400204 	addi	r21,r21,8
 1805f34:	d8000015 	stw	zero,0(sp)
 1805f38:	003fdc06 	br	1805eac <__sfvwrite_r+0x278>
 1805f3c:	b80b883a 	mov	r5,r23
 1805f40:	880d883a 	mov	r6,r17
 1805f44:	1806a080 	call	1806a08 <memmove>
 1805f48:	90c00017 	ldw	r3,0(r18)
 1805f4c:	e009883a 	mov	r4,fp
 1805f50:	900b883a 	mov	r5,r18
 1805f54:	1c47883a 	add	r3,r3,r17
 1805f58:	90c00015 	stw	r3,0(r18)
 1805f5c:	180791c0 	call	180791c <_fflush_r>
 1805f60:	103fc91e 	bne	r2,zero,1805e88 <__sfvwrite_r+0x254>
 1805f64:	a469c83a 	sub	r20,r20,r17
 1805f68:	a03fe81e 	bne	r20,zero,1805f0c <__sfvwrite_r+0x2d8>
 1805f6c:	e009883a 	mov	r4,fp
 1805f70:	900b883a 	mov	r5,r18
 1805f74:	180791c0 	call	180791c <_fflush_r>
 1805f78:	103fc31e 	bne	r2,zero,1805e88 <__sfvwrite_r+0x254>
 1805f7c:	d8000015 	stw	zero,0(sp)
 1805f80:	003fe206 	br	1805f0c <__sfvwrite_r+0x2d8>
 1805f84:	91000017 	ldw	r4,0(r18)
 1805f88:	90800417 	ldw	r2,16(r18)
 1805f8c:	1100022e 	bgeu	r2,r4,1805f98 <__sfvwrite_r+0x364>
 1805f90:	8023883a 	mov	r17,r16
 1805f94:	85003136 	bltu	r16,r20,180605c <__sfvwrite_r+0x428>
 1805f98:	91c00517 	ldw	r7,20(r18)
 1805f9c:	a1c01836 	bltu	r20,r7,1806000 <__sfvwrite_r+0x3cc>
 1805fa0:	90c00917 	ldw	r3,36(r18)
 1805fa4:	91400717 	ldw	r5,28(r18)
 1805fa8:	e009883a 	mov	r4,fp
 1805fac:	b80d883a 	mov	r6,r23
 1805fb0:	183ee83a 	callr	r3
 1805fb4:	1021883a 	mov	r16,r2
 1805fb8:	00bfb30e 	bge	zero,r2,1805e88 <__sfvwrite_r+0x254>
 1805fbc:	1023883a 	mov	r17,r2
 1805fc0:	1027883a 	mov	r19,r2
 1805fc4:	003f9b06 	br	1805e34 <__sfvwrite_r+0x200>
 1805fc8:	b80b883a 	mov	r5,r23
 1805fcc:	800d883a 	mov	r6,r16
 1805fd0:	1806a080 	call	1806a08 <memmove>
 1805fd4:	90c00217 	ldw	r3,8(r18)
 1805fd8:	90800017 	ldw	r2,0(r18)
 1805fdc:	8023883a 	mov	r17,r16
 1805fe0:	1c07c83a 	sub	r3,r3,r16
 1805fe4:	1405883a 	add	r2,r2,r16
 1805fe8:	90c00215 	stw	r3,8(r18)
 1805fec:	90800015 	stw	r2,0(r18)
 1805ff0:	003fc406 	br	1805f04 <__sfvwrite_r+0x2d0>
 1805ff4:	a00d883a 	mov	r6,r20
 1805ff8:	a021883a 	mov	r16,r20
 1805ffc:	003f8106 	br	1805e04 <__sfvwrite_r+0x1d0>
 1806000:	b80b883a 	mov	r5,r23
 1806004:	a00d883a 	mov	r6,r20
 1806008:	1806a080 	call	1806a08 <memmove>
 180600c:	90c00217 	ldw	r3,8(r18)
 1806010:	90800017 	ldw	r2,0(r18)
 1806014:	a021883a 	mov	r16,r20
 1806018:	1d07c83a 	sub	r3,r3,r20
 180601c:	1505883a 	add	r2,r2,r20
 1806020:	a023883a 	mov	r17,r20
 1806024:	a027883a 	mov	r19,r20
 1806028:	90c00215 	stw	r3,8(r18)
 180602c:	90800015 	stw	r2,0(r18)
 1806030:	003f8006 	br	1805e34 <__sfvwrite_r+0x200>
 1806034:	b809883a 	mov	r4,r23
 1806038:	01400284 	movi	r5,10
 180603c:	980d883a 	mov	r6,r19
 1806040:	18068100 	call	1806810 <memchr>
 1806044:	10001726 	beq	r2,zero,18060a4 <__sfvwrite_r+0x470>
 1806048:	15c5c83a 	sub	r2,r2,r23
 180604c:	15000044 	addi	r20,r2,1
 1806050:	00800044 	movi	r2,1
 1806054:	d8800015 	stw	r2,0(sp)
 1806058:	003f9806 	br	1805ebc <__sfvwrite_r+0x288>
 180605c:	b80b883a 	mov	r5,r23
 1806060:	800d883a 	mov	r6,r16
 1806064:	1806a080 	call	1806a08 <memmove>
 1806068:	90c00017 	ldw	r3,0(r18)
 180606c:	e009883a 	mov	r4,fp
 1806070:	900b883a 	mov	r5,r18
 1806074:	1c07883a 	add	r3,r3,r16
 1806078:	90c00015 	stw	r3,0(r18)
 180607c:	8027883a 	mov	r19,r16
 1806080:	180791c0 	call	180791c <_fflush_r>
 1806084:	103f6b26 	beq	r2,zero,1805e34 <__sfvwrite_r+0x200>
 1806088:	003f7f06 	br	1805e88 <__sfvwrite_r+0x254>
 180608c:	400b883a 	mov	r5,r8
 1806090:	e009883a 	mov	r4,fp
 1806094:	1806cd40 	call	1806cd4 <_realloc_r>
 1806098:	103f7626 	beq	r2,zero,1805e74 <__sfvwrite_r+0x240>
 180609c:	1023883a 	mov	r17,r2
 18060a0:	003f5006 	br	1805de4 <__sfvwrite_r+0x1b0>
 18060a4:	00c00044 	movi	r3,1
 18060a8:	9d000044 	addi	r20,r19,1
 18060ac:	d8c00015 	stw	r3,0(sp)
 18060b0:	003f8206 	br	1805ebc <__sfvwrite_r+0x288>
 18060b4:	9080030b 	ldhu	r2,12(r18)
 18060b8:	00c00244 	movi	r3,9
 18060bc:	013fffc4 	movi	r4,-1
 18060c0:	10801014 	ori	r2,r2,64
 18060c4:	9080030d 	sth	r2,12(r18)
 18060c8:	e0c00015 	stw	r3,0(fp)
 18060cc:	003f0606 	br	1805ce8 <__sfvwrite_r+0xb4>

018060d0 <_malloc_r>:
 18060d0:	defff604 	addi	sp,sp,-40
 18060d4:	28c002c4 	addi	r3,r5,11
 18060d8:	00800584 	movi	r2,22
 18060dc:	dc800215 	stw	r18,8(sp)
 18060e0:	dfc00915 	stw	ra,36(sp)
 18060e4:	df000815 	stw	fp,32(sp)
 18060e8:	ddc00715 	stw	r23,28(sp)
 18060ec:	dd800615 	stw	r22,24(sp)
 18060f0:	dd400515 	stw	r21,20(sp)
 18060f4:	dd000415 	stw	r20,16(sp)
 18060f8:	dcc00315 	stw	r19,12(sp)
 18060fc:	dc400115 	stw	r17,4(sp)
 1806100:	dc000015 	stw	r16,0(sp)
 1806104:	2025883a 	mov	r18,r4
 1806108:	10c01236 	bltu	r2,r3,1806154 <_malloc_r+0x84>
 180610c:	04400404 	movi	r17,16
 1806110:	8940142e 	bgeu	r17,r5,1806164 <_malloc_r+0x94>
 1806114:	00800304 	movi	r2,12
 1806118:	0007883a 	mov	r3,zero
 180611c:	90800015 	stw	r2,0(r18)
 1806120:	1805883a 	mov	r2,r3
 1806124:	dfc00917 	ldw	ra,36(sp)
 1806128:	df000817 	ldw	fp,32(sp)
 180612c:	ddc00717 	ldw	r23,28(sp)
 1806130:	dd800617 	ldw	r22,24(sp)
 1806134:	dd400517 	ldw	r21,20(sp)
 1806138:	dd000417 	ldw	r20,16(sp)
 180613c:	dcc00317 	ldw	r19,12(sp)
 1806140:	dc800217 	ldw	r18,8(sp)
 1806144:	dc400117 	ldw	r17,4(sp)
 1806148:	dc000017 	ldw	r16,0(sp)
 180614c:	dec00a04 	addi	sp,sp,40
 1806150:	f800283a 	ret
 1806154:	00bffe04 	movi	r2,-8
 1806158:	18a2703a 	and	r17,r3,r2
 180615c:	883fed16 	blt	r17,zero,1806114 <_malloc_r+0x44>
 1806160:	897fec36 	bltu	r17,r5,1806114 <_malloc_r+0x44>
 1806164:	9009883a 	mov	r4,r18
 1806168:	1808fa40 	call	1808fa4 <__malloc_lock>
 180616c:	00807dc4 	movi	r2,503
 1806170:	14402b2e 	bgeu	r2,r17,1806220 <_malloc_r+0x150>
 1806174:	8806d27a 	srli	r3,r17,9
 1806178:	18003f1e 	bne	r3,zero,1806278 <_malloc_r+0x1a8>
 180617c:	880cd0fa 	srli	r6,r17,3
 1806180:	300490fa 	slli	r2,r6,3
 1806184:	02c06074 	movhi	r11,385
 1806188:	5aeacb04 	addi	r11,r11,-21716
 180618c:	12cb883a 	add	r5,r2,r11
 1806190:	2c000317 	ldw	r16,12(r5)
 1806194:	580f883a 	mov	r7,r11
 1806198:	2c00041e 	bne	r5,r16,18061ac <_malloc_r+0xdc>
 180619c:	00000a06 	br	18061c8 <_malloc_r+0xf8>
 18061a0:	1800860e 	bge	r3,zero,18063bc <_malloc_r+0x2ec>
 18061a4:	84000317 	ldw	r16,12(r16)
 18061a8:	2c000726 	beq	r5,r16,18061c8 <_malloc_r+0xf8>
 18061ac:	80800117 	ldw	r2,4(r16)
 18061b0:	00ffff04 	movi	r3,-4
 18061b4:	10c8703a 	and	r4,r2,r3
 18061b8:	2447c83a 	sub	r3,r4,r17
 18061bc:	008003c4 	movi	r2,15
 18061c0:	10fff70e 	bge	r2,r3,18061a0 <_malloc_r+0xd0>
 18061c4:	31bfffc4 	addi	r6,r6,-1
 18061c8:	32400044 	addi	r9,r6,1
 18061cc:	02806074 	movhi	r10,385
 18061d0:	52aacd04 	addi	r10,r10,-21708
 18061d4:	54000217 	ldw	r16,8(r10)
 18061d8:	8280a026 	beq	r16,r10,180645c <_malloc_r+0x38c>
 18061dc:	80800117 	ldw	r2,4(r16)
 18061e0:	00ffff04 	movi	r3,-4
 18061e4:	10ca703a 	and	r5,r2,r3
 18061e8:	2c4dc83a 	sub	r6,r5,r17
 18061ec:	008003c4 	movi	r2,15
 18061f0:	11808316 	blt	r2,r6,1806400 <_malloc_r+0x330>
 18061f4:	52800315 	stw	r10,12(r10)
 18061f8:	52800215 	stw	r10,8(r10)
 18061fc:	30002916 	blt	r6,zero,18062a4 <_malloc_r+0x1d4>
 1806200:	8147883a 	add	r3,r16,r5
 1806204:	18800117 	ldw	r2,4(r3)
 1806208:	9009883a 	mov	r4,r18
 180620c:	10800054 	ori	r2,r2,1
 1806210:	18800115 	stw	r2,4(r3)
 1806214:	1808fc40 	call	1808fc4 <__malloc_unlock>
 1806218:	80c00204 	addi	r3,r16,8
 180621c:	003fc006 	br	1806120 <_malloc_r+0x50>
 1806220:	02c06074 	movhi	r11,385
 1806224:	5aeacb04 	addi	r11,r11,-21716
 1806228:	8ac5883a 	add	r2,r17,r11
 180622c:	14000317 	ldw	r16,12(r2)
 1806230:	580f883a 	mov	r7,r11
 1806234:	8806d0fa 	srli	r3,r17,3
 1806238:	14006c26 	beq	r2,r16,18063ec <_malloc_r+0x31c>
 180623c:	80c00117 	ldw	r3,4(r16)
 1806240:	00bfff04 	movi	r2,-4
 1806244:	81800317 	ldw	r6,12(r16)
 1806248:	1886703a 	and	r3,r3,r2
 180624c:	80c7883a 	add	r3,r16,r3
 1806250:	18800117 	ldw	r2,4(r3)
 1806254:	81400217 	ldw	r5,8(r16)
 1806258:	9009883a 	mov	r4,r18
 180625c:	10800054 	ori	r2,r2,1
 1806260:	18800115 	stw	r2,4(r3)
 1806264:	31400215 	stw	r5,8(r6)
 1806268:	29800315 	stw	r6,12(r5)
 180626c:	1808fc40 	call	1808fc4 <__malloc_unlock>
 1806270:	80c00204 	addi	r3,r16,8
 1806274:	003faa06 	br	1806120 <_malloc_r+0x50>
 1806278:	00800104 	movi	r2,4
 180627c:	10c0052e 	bgeu	r2,r3,1806294 <_malloc_r+0x1c4>
 1806280:	00800504 	movi	r2,20
 1806284:	10c07836 	bltu	r2,r3,1806468 <_malloc_r+0x398>
 1806288:	198016c4 	addi	r6,r3,91
 180628c:	300490fa 	slli	r2,r6,3
 1806290:	003fbc06 	br	1806184 <_malloc_r+0xb4>
 1806294:	8804d1ba 	srli	r2,r17,6
 1806298:	11800e04 	addi	r6,r2,56
 180629c:	300490fa 	slli	r2,r6,3
 18062a0:	003fb806 	br	1806184 <_malloc_r+0xb4>
 18062a4:	00807fc4 	movi	r2,511
 18062a8:	1140bb36 	bltu	r2,r5,1806598 <_malloc_r+0x4c8>
 18062ac:	2806d0fa 	srli	r3,r5,3
 18062b0:	573ffe04 	addi	fp,r10,-8
 18062b4:	00800044 	movi	r2,1
 18062b8:	180890fa 	slli	r4,r3,3
 18062bc:	1807d0ba 	srai	r3,r3,2
 18062c0:	e1c00117 	ldw	r7,4(fp)
 18062c4:	5909883a 	add	r4,r11,r4
 18062c8:	21400217 	ldw	r5,8(r4)
 18062cc:	10c4983a 	sll	r2,r2,r3
 18062d0:	81000315 	stw	r4,12(r16)
 18062d4:	81400215 	stw	r5,8(r16)
 18062d8:	388eb03a 	or	r7,r7,r2
 18062dc:	2c000315 	stw	r16,12(r5)
 18062e0:	24000215 	stw	r16,8(r4)
 18062e4:	e1c00115 	stw	r7,4(fp)
 18062e8:	4807883a 	mov	r3,r9
 18062ec:	4800cd16 	blt	r9,zero,1806624 <_malloc_r+0x554>
 18062f0:	1807d0ba 	srai	r3,r3,2
 18062f4:	00800044 	movi	r2,1
 18062f8:	10c8983a 	sll	r4,r2,r3
 18062fc:	39004436 	bltu	r7,r4,1806410 <_malloc_r+0x340>
 1806300:	21c4703a 	and	r2,r4,r7
 1806304:	10000a1e 	bne	r2,zero,1806330 <_malloc_r+0x260>
 1806308:	2109883a 	add	r4,r4,r4
 180630c:	00bfff04 	movi	r2,-4
 1806310:	4884703a 	and	r2,r9,r2
 1806314:	3906703a 	and	r3,r7,r4
 1806318:	12400104 	addi	r9,r2,4
 180631c:	1800041e 	bne	r3,zero,1806330 <_malloc_r+0x260>
 1806320:	2109883a 	add	r4,r4,r4
 1806324:	3904703a 	and	r2,r7,r4
 1806328:	4a400104 	addi	r9,r9,4
 180632c:	103ffc26 	beq	r2,zero,1806320 <_malloc_r+0x250>
 1806330:	480490fa 	slli	r2,r9,3
 1806334:	4819883a 	mov	r12,r9
 1806338:	023fff04 	movi	r8,-4
 180633c:	589b883a 	add	r13,r11,r2
 1806340:	6807883a 	mov	r3,r13
 1806344:	014003c4 	movi	r5,15
 1806348:	1c000317 	ldw	r16,12(r3)
 180634c:	1c00041e 	bne	r3,r16,1806360 <_malloc_r+0x290>
 1806350:	0000a706 	br	18065f0 <_malloc_r+0x520>
 1806354:	3000ab0e 	bge	r6,zero,1806604 <_malloc_r+0x534>
 1806358:	84000317 	ldw	r16,12(r16)
 180635c:	1c00a426 	beq	r3,r16,18065f0 <_malloc_r+0x520>
 1806360:	80800117 	ldw	r2,4(r16)
 1806364:	1204703a 	and	r2,r2,r8
 1806368:	144dc83a 	sub	r6,r2,r17
 180636c:	29bff90e 	bge	r5,r6,1806354 <_malloc_r+0x284>
 1806370:	81000317 	ldw	r4,12(r16)
 1806374:	80c00217 	ldw	r3,8(r16)
 1806378:	89400054 	ori	r5,r17,1
 180637c:	8445883a 	add	r2,r16,r17
 1806380:	20c00215 	stw	r3,8(r4)
 1806384:	19000315 	stw	r4,12(r3)
 1806388:	81400115 	stw	r5,4(r16)
 180638c:	1187883a 	add	r3,r2,r6
 1806390:	31000054 	ori	r4,r6,1
 1806394:	50800315 	stw	r2,12(r10)
 1806398:	50800215 	stw	r2,8(r10)
 180639c:	19800015 	stw	r6,0(r3)
 18063a0:	11000115 	stw	r4,4(r2)
 18063a4:	12800215 	stw	r10,8(r2)
 18063a8:	12800315 	stw	r10,12(r2)
 18063ac:	9009883a 	mov	r4,r18
 18063b0:	1808fc40 	call	1808fc4 <__malloc_unlock>
 18063b4:	80c00204 	addi	r3,r16,8
 18063b8:	003f5906 	br	1806120 <_malloc_r+0x50>
 18063bc:	8109883a 	add	r4,r16,r4
 18063c0:	20800117 	ldw	r2,4(r4)
 18063c4:	80c00217 	ldw	r3,8(r16)
 18063c8:	81400317 	ldw	r5,12(r16)
 18063cc:	10800054 	ori	r2,r2,1
 18063d0:	20800115 	stw	r2,4(r4)
 18063d4:	28c00215 	stw	r3,8(r5)
 18063d8:	19400315 	stw	r5,12(r3)
 18063dc:	9009883a 	mov	r4,r18
 18063e0:	1808fc40 	call	1808fc4 <__malloc_unlock>
 18063e4:	80c00204 	addi	r3,r16,8
 18063e8:	003f4d06 	br	1806120 <_malloc_r+0x50>
 18063ec:	80800204 	addi	r2,r16,8
 18063f0:	14000317 	ldw	r16,12(r2)
 18063f4:	143f911e 	bne	r2,r16,180623c <_malloc_r+0x16c>
 18063f8:	1a400084 	addi	r9,r3,2
 18063fc:	003f7306 	br	18061cc <_malloc_r+0xfc>
 1806400:	88c00054 	ori	r3,r17,1
 1806404:	8445883a 	add	r2,r16,r17
 1806408:	80c00115 	stw	r3,4(r16)
 180640c:	003fdf06 	br	180638c <_malloc_r+0x2bc>
 1806410:	e4000217 	ldw	r16,8(fp)
 1806414:	00bfff04 	movi	r2,-4
 1806418:	80c00117 	ldw	r3,4(r16)
 180641c:	802d883a 	mov	r22,r16
 1806420:	18aa703a 	and	r21,r3,r2
 1806424:	ac401636 	bltu	r21,r17,1806480 <_malloc_r+0x3b0>
 1806428:	ac49c83a 	sub	r4,r21,r17
 180642c:	008003c4 	movi	r2,15
 1806430:	1100130e 	bge	r2,r4,1806480 <_malloc_r+0x3b0>
 1806434:	88800054 	ori	r2,r17,1
 1806438:	8447883a 	add	r3,r16,r17
 180643c:	80800115 	stw	r2,4(r16)
 1806440:	20800054 	ori	r2,r4,1
 1806444:	18800115 	stw	r2,4(r3)
 1806448:	e0c00215 	stw	r3,8(fp)
 180644c:	9009883a 	mov	r4,r18
 1806450:	1808fc40 	call	1808fc4 <__malloc_unlock>
 1806454:	80c00204 	addi	r3,r16,8
 1806458:	003f3106 	br	1806120 <_malloc_r+0x50>
 180645c:	39c00117 	ldw	r7,4(r7)
 1806460:	573ffe04 	addi	fp,r10,-8
 1806464:	003fa006 	br	18062e8 <_malloc_r+0x218>
 1806468:	00801504 	movi	r2,84
 180646c:	10c06736 	bltu	r2,r3,180660c <_malloc_r+0x53c>
 1806470:	8804d33a 	srli	r2,r17,12
 1806474:	11801b84 	addi	r6,r2,110
 1806478:	300490fa 	slli	r2,r6,3
 180647c:	003f4106 	br	1806184 <_malloc_r+0xb4>
 1806480:	d0a6da17 	ldw	r2,-25752(gp)
 1806484:	d0e00c17 	ldw	r3,-32720(gp)
 1806488:	053fffc4 	movi	r20,-1
 180648c:	10800404 	addi	r2,r2,16
 1806490:	88a7883a 	add	r19,r17,r2
 1806494:	1d000326 	beq	r3,r20,18064a4 <_malloc_r+0x3d4>
 1806498:	98c3ffc4 	addi	r3,r19,4095
 180649c:	00bc0004 	movi	r2,-4096
 18064a0:	18a6703a 	and	r19,r3,r2
 18064a4:	9009883a 	mov	r4,r18
 18064a8:	980b883a 	mov	r5,r19
 18064ac:	18072c80 	call	18072c8 <_sbrk_r>
 18064b0:	1009883a 	mov	r4,r2
 18064b4:	15000426 	beq	r2,r20,18064c8 <_malloc_r+0x3f8>
 18064b8:	854b883a 	add	r5,r16,r21
 18064bc:	1029883a 	mov	r20,r2
 18064c0:	11405a2e 	bgeu	r2,r5,180662c <_malloc_r+0x55c>
 18064c4:	87000c26 	beq	r16,fp,18064f8 <_malloc_r+0x428>
 18064c8:	e4000217 	ldw	r16,8(fp)
 18064cc:	80c00117 	ldw	r3,4(r16)
 18064d0:	00bfff04 	movi	r2,-4
 18064d4:	1884703a 	and	r2,r3,r2
 18064d8:	14400336 	bltu	r2,r17,18064e8 <_malloc_r+0x418>
 18064dc:	1449c83a 	sub	r4,r2,r17
 18064e0:	008003c4 	movi	r2,15
 18064e4:	113fd316 	blt	r2,r4,1806434 <_malloc_r+0x364>
 18064e8:	9009883a 	mov	r4,r18
 18064ec:	1808fc40 	call	1808fc4 <__malloc_unlock>
 18064f0:	0007883a 	mov	r3,zero
 18064f4:	003f0a06 	br	1806120 <_malloc_r+0x50>
 18064f8:	05c06074 	movhi	r23,385
 18064fc:	bdf2c304 	addi	r23,r23,-13556
 1806500:	b8800017 	ldw	r2,0(r23)
 1806504:	988d883a 	add	r6,r19,r2
 1806508:	b9800015 	stw	r6,0(r23)
 180650c:	d0e00c17 	ldw	r3,-32720(gp)
 1806510:	00bfffc4 	movi	r2,-1
 1806514:	18808e26 	beq	r3,r2,1806750 <_malloc_r+0x680>
 1806518:	2145c83a 	sub	r2,r4,r5
 180651c:	3085883a 	add	r2,r6,r2
 1806520:	b8800015 	stw	r2,0(r23)
 1806524:	20c001cc 	andi	r3,r4,7
 1806528:	18005f1e 	bne	r3,zero,18066a8 <_malloc_r+0x5d8>
 180652c:	000b883a 	mov	r5,zero
 1806530:	a4c5883a 	add	r2,r20,r19
 1806534:	1083ffcc 	andi	r2,r2,4095
 1806538:	00c40004 	movi	r3,4096
 180653c:	1887c83a 	sub	r3,r3,r2
 1806540:	28e7883a 	add	r19,r5,r3
 1806544:	9009883a 	mov	r4,r18
 1806548:	980b883a 	mov	r5,r19
 180654c:	18072c80 	call	18072c8 <_sbrk_r>
 1806550:	1007883a 	mov	r3,r2
 1806554:	00bfffc4 	movi	r2,-1
 1806558:	18807a26 	beq	r3,r2,1806744 <_malloc_r+0x674>
 180655c:	1d05c83a 	sub	r2,r3,r20
 1806560:	9885883a 	add	r2,r19,r2
 1806564:	10c00054 	ori	r3,r2,1
 1806568:	b8800017 	ldw	r2,0(r23)
 180656c:	a021883a 	mov	r16,r20
 1806570:	a0c00115 	stw	r3,4(r20)
 1806574:	9885883a 	add	r2,r19,r2
 1806578:	b8800015 	stw	r2,0(r23)
 180657c:	e5000215 	stw	r20,8(fp)
 1806580:	b7003626 	beq	r22,fp,180665c <_malloc_r+0x58c>
 1806584:	018003c4 	movi	r6,15
 1806588:	35404b36 	bltu	r6,r21,18066b8 <_malloc_r+0x5e8>
 180658c:	00800044 	movi	r2,1
 1806590:	a0800115 	stw	r2,4(r20)
 1806594:	003fcd06 	br	18064cc <_malloc_r+0x3fc>
 1806598:	2808d27a 	srli	r4,r5,9
 180659c:	2000371e 	bne	r4,zero,180667c <_malloc_r+0x5ac>
 18065a0:	2808d0fa 	srli	r4,r5,3
 18065a4:	200690fa 	slli	r3,r4,3
 18065a8:	1ad1883a 	add	r8,r3,r11
 18065ac:	41800217 	ldw	r6,8(r8)
 18065b0:	41805b26 	beq	r8,r6,1806720 <_malloc_r+0x650>
 18065b4:	30800117 	ldw	r2,4(r6)
 18065b8:	00ffff04 	movi	r3,-4
 18065bc:	10c4703a 	and	r2,r2,r3
 18065c0:	2880022e 	bgeu	r5,r2,18065cc <_malloc_r+0x4fc>
 18065c4:	31800217 	ldw	r6,8(r6)
 18065c8:	41bffa1e 	bne	r8,r6,18065b4 <_malloc_r+0x4e4>
 18065cc:	32000317 	ldw	r8,12(r6)
 18065d0:	39c00117 	ldw	r7,4(r7)
 18065d4:	82000315 	stw	r8,12(r16)
 18065d8:	81800215 	stw	r6,8(r16)
 18065dc:	07006074 	movhi	fp,385
 18065e0:	e72acb04 	addi	fp,fp,-21716
 18065e4:	34000315 	stw	r16,12(r6)
 18065e8:	44000215 	stw	r16,8(r8)
 18065ec:	003f3e06 	br	18062e8 <_malloc_r+0x218>
 18065f0:	63000044 	addi	r12,r12,1
 18065f4:	608000cc 	andi	r2,r12,3
 18065f8:	10005d26 	beq	r2,zero,1806770 <_malloc_r+0x6a0>
 18065fc:	18c00204 	addi	r3,r3,8
 1806600:	003f5106 	br	1806348 <_malloc_r+0x278>
 1806604:	8089883a 	add	r4,r16,r2
 1806608:	003f6d06 	br	18063c0 <_malloc_r+0x2f0>
 180660c:	00805504 	movi	r2,340
 1806610:	10c02036 	bltu	r2,r3,1806694 <_malloc_r+0x5c4>
 1806614:	8804d3fa 	srli	r2,r17,15
 1806618:	11801dc4 	addi	r6,r2,119
 180661c:	300490fa 	slli	r2,r6,3
 1806620:	003ed806 	br	1806184 <_malloc_r+0xb4>
 1806624:	48c000c4 	addi	r3,r9,3
 1806628:	003f3106 	br	18062f0 <_malloc_r+0x220>
 180662c:	05c06074 	movhi	r23,385
 1806630:	bdf2c304 	addi	r23,r23,-13556
 1806634:	b8800017 	ldw	r2,0(r23)
 1806638:	988d883a 	add	r6,r19,r2
 180663c:	b9800015 	stw	r6,0(r23)
 1806640:	293fb21e 	bne	r5,r4,180650c <_malloc_r+0x43c>
 1806644:	2083ffcc 	andi	r2,r4,4095
 1806648:	103fb01e 	bne	r2,zero,180650c <_malloc_r+0x43c>
 180664c:	e4000217 	ldw	r16,8(fp)
 1806650:	9d45883a 	add	r2,r19,r21
 1806654:	10800054 	ori	r2,r2,1
 1806658:	80800115 	stw	r2,4(r16)
 180665c:	b8c00017 	ldw	r3,0(r23)
 1806660:	d0a6db17 	ldw	r2,-25748(gp)
 1806664:	10c0012e 	bgeu	r2,r3,180666c <_malloc_r+0x59c>
 1806668:	d0e6db15 	stw	r3,-25748(gp)
 180666c:	d0a6dc17 	ldw	r2,-25744(gp)
 1806670:	10ff962e 	bgeu	r2,r3,18064cc <_malloc_r+0x3fc>
 1806674:	d0e6dc15 	stw	r3,-25744(gp)
 1806678:	003f9406 	br	18064cc <_malloc_r+0x3fc>
 180667c:	00800104 	movi	r2,4
 1806680:	11001e36 	bltu	r2,r4,18066fc <_malloc_r+0x62c>
 1806684:	2804d1ba 	srli	r2,r5,6
 1806688:	11000e04 	addi	r4,r2,56
 180668c:	200690fa 	slli	r3,r4,3
 1806690:	003fc506 	br	18065a8 <_malloc_r+0x4d8>
 1806694:	00815504 	movi	r2,1364
 1806698:	10c01d2e 	bgeu	r2,r3,1806710 <_malloc_r+0x640>
 180669c:	01801f84 	movi	r6,126
 18066a0:	0080fc04 	movi	r2,1008
 18066a4:	003eb706 	br	1806184 <_malloc_r+0xb4>
 18066a8:	00800204 	movi	r2,8
 18066ac:	10cbc83a 	sub	r5,r2,r3
 18066b0:	2169883a 	add	r20,r4,r5
 18066b4:	003f9e06 	br	1806530 <_malloc_r+0x460>
 18066b8:	00bffe04 	movi	r2,-8
 18066bc:	a93ffd04 	addi	r4,r21,-12
 18066c0:	2088703a 	and	r4,r4,r2
 18066c4:	b10b883a 	add	r5,r22,r4
 18066c8:	00c00144 	movi	r3,5
 18066cc:	28c00215 	stw	r3,8(r5)
 18066d0:	28c00115 	stw	r3,4(r5)
 18066d4:	b0800117 	ldw	r2,4(r22)
 18066d8:	1080004c 	andi	r2,r2,1
 18066dc:	2084b03a 	or	r2,r4,r2
 18066e0:	b0800115 	stw	r2,4(r22)
 18066e4:	313fdd2e 	bgeu	r6,r4,180665c <_malloc_r+0x58c>
 18066e8:	b1400204 	addi	r5,r22,8
 18066ec:	9009883a 	mov	r4,r18
 18066f0:	1807f6c0 	call	1807f6c <_free_r>
 18066f4:	e4000217 	ldw	r16,8(fp)
 18066f8:	003fd806 	br	180665c <_malloc_r+0x58c>
 18066fc:	00800504 	movi	r2,20
 1806700:	11001536 	bltu	r2,r4,1806758 <_malloc_r+0x688>
 1806704:	210016c4 	addi	r4,r4,91
 1806708:	200690fa 	slli	r3,r4,3
 180670c:	003fa606 	br	18065a8 <_malloc_r+0x4d8>
 1806710:	8804d4ba 	srli	r2,r17,18
 1806714:	11801f04 	addi	r6,r2,124
 1806718:	300490fa 	slli	r2,r6,3
 180671c:	003e9906 	br	1806184 <_malloc_r+0xb4>
 1806720:	2009d0ba 	srai	r4,r4,2
 1806724:	01406074 	movhi	r5,385
 1806728:	296acb04 	addi	r5,r5,-21716
 180672c:	00c00044 	movi	r3,1
 1806730:	28800117 	ldw	r2,4(r5)
 1806734:	1906983a 	sll	r3,r3,r4
 1806738:	10c4b03a 	or	r2,r2,r3
 180673c:	28800115 	stw	r2,4(r5)
 1806740:	003fa306 	br	18065d0 <_malloc_r+0x500>
 1806744:	0027883a 	mov	r19,zero
 1806748:	00c00044 	movi	r3,1
 180674c:	003f8606 	br	1806568 <_malloc_r+0x498>
 1806750:	d1200c15 	stw	r4,-32720(gp)
 1806754:	003f7306 	br	1806524 <_malloc_r+0x454>
 1806758:	00801504 	movi	r2,84
 180675c:	11001936 	bltu	r2,r4,18067c4 <_malloc_r+0x6f4>
 1806760:	2804d33a 	srli	r2,r5,12
 1806764:	11001b84 	addi	r4,r2,110
 1806768:	200690fa 	slli	r3,r4,3
 180676c:	003f8e06 	br	18065a8 <_malloc_r+0x4d8>
 1806770:	480b883a 	mov	r5,r9
 1806774:	6807883a 	mov	r3,r13
 1806778:	288000cc 	andi	r2,r5,3
 180677c:	18fffe04 	addi	r3,r3,-8
 1806780:	297fffc4 	addi	r5,r5,-1
 1806784:	10001526 	beq	r2,zero,18067dc <_malloc_r+0x70c>
 1806788:	18800217 	ldw	r2,8(r3)
 180678c:	10fffa26 	beq	r2,r3,1806778 <_malloc_r+0x6a8>
 1806790:	2109883a 	add	r4,r4,r4
 1806794:	393f1e36 	bltu	r7,r4,1806410 <_malloc_r+0x340>
 1806798:	203f1d26 	beq	r4,zero,1806410 <_malloc_r+0x340>
 180679c:	21c4703a 	and	r2,r4,r7
 18067a0:	10000226 	beq	r2,zero,18067ac <_malloc_r+0x6dc>
 18067a4:	6013883a 	mov	r9,r12
 18067a8:	003ee106 	br	1806330 <_malloc_r+0x260>
 18067ac:	2109883a 	add	r4,r4,r4
 18067b0:	3904703a 	and	r2,r7,r4
 18067b4:	63000104 	addi	r12,r12,4
 18067b8:	103ffc26 	beq	r2,zero,18067ac <_malloc_r+0x6dc>
 18067bc:	6013883a 	mov	r9,r12
 18067c0:	003edb06 	br	1806330 <_malloc_r+0x260>
 18067c4:	00805504 	movi	r2,340
 18067c8:	11000836 	bltu	r2,r4,18067ec <_malloc_r+0x71c>
 18067cc:	2804d3fa 	srli	r2,r5,15
 18067d0:	11001dc4 	addi	r4,r2,119
 18067d4:	200690fa 	slli	r3,r4,3
 18067d8:	003f7306 	br	18065a8 <_malloc_r+0x4d8>
 18067dc:	0104303a 	nor	r2,zero,r4
 18067e0:	388e703a 	and	r7,r7,r2
 18067e4:	e1c00115 	stw	r7,4(fp)
 18067e8:	003fe906 	br	1806790 <_malloc_r+0x6c0>
 18067ec:	00815504 	movi	r2,1364
 18067f0:	1100032e 	bgeu	r2,r4,1806800 <_malloc_r+0x730>
 18067f4:	01001f84 	movi	r4,126
 18067f8:	00c0fc04 	movi	r3,1008
 18067fc:	003f6a06 	br	18065a8 <_malloc_r+0x4d8>
 1806800:	2804d4ba 	srli	r2,r5,18
 1806804:	11001f04 	addi	r4,r2,124
 1806808:	200690fa 	slli	r3,r4,3
 180680c:	003f6606 	br	18065a8 <_malloc_r+0x4d8>

01806810 <memchr>:
 1806810:	008000c4 	movi	r2,3
 1806814:	29403fcc 	andi	r5,r5,255
 1806818:	2007883a 	mov	r3,r4
 180681c:	1180022e 	bgeu	r2,r6,1806828 <memchr+0x18>
 1806820:	2084703a 	and	r2,r4,r2
 1806824:	10000b26 	beq	r2,zero,1806854 <memchr+0x44>
 1806828:	313fffc4 	addi	r4,r6,-1
 180682c:	3000051e 	bne	r6,zero,1806844 <memchr+0x34>
 1806830:	00002c06 	br	18068e4 <memchr+0xd4>
 1806834:	213fffc4 	addi	r4,r4,-1
 1806838:	00bfffc4 	movi	r2,-1
 180683c:	18c00044 	addi	r3,r3,1
 1806840:	20802826 	beq	r4,r2,18068e4 <memchr+0xd4>
 1806844:	18800003 	ldbu	r2,0(r3)
 1806848:	28bffa1e 	bne	r5,r2,1806834 <memchr+0x24>
 180684c:	1805883a 	mov	r2,r3
 1806850:	f800283a 	ret
 1806854:	0011883a 	mov	r8,zero
 1806858:	0007883a 	mov	r3,zero
 180685c:	01c00104 	movi	r7,4
 1806860:	4004923a 	slli	r2,r8,8
 1806864:	18c00044 	addi	r3,r3,1
 1806868:	1151883a 	add	r8,r2,r5
 180686c:	19fffc1e 	bne	r3,r7,1806860 <memchr+0x50>
 1806870:	02bfbff4 	movhi	r10,65279
 1806874:	52bfbfc4 	addi	r10,r10,-257
 1806878:	02602074 	movhi	r9,32897
 180687c:	4a602004 	addi	r9,r9,-32640
 1806880:	02c000c4 	movi	r11,3
 1806884:	20800017 	ldw	r2,0(r4)
 1806888:	31bfff04 	addi	r6,r6,-4
 180688c:	200f883a 	mov	r7,r4
 1806890:	1204f03a 	xor	r2,r2,r8
 1806894:	1287883a 	add	r3,r2,r10
 1806898:	1a46703a 	and	r3,r3,r9
 180689c:	0084303a 	nor	r2,zero,r2
 18068a0:	10c4703a 	and	r2,r2,r3
 18068a4:	10000b26 	beq	r2,zero,18068d4 <memchr+0xc4>
 18068a8:	20800003 	ldbu	r2,0(r4)
 18068ac:	28800f26 	beq	r5,r2,18068ec <memchr+0xdc>
 18068b0:	20800043 	ldbu	r2,1(r4)
 18068b4:	21c00044 	addi	r7,r4,1
 18068b8:	28800c26 	beq	r5,r2,18068ec <memchr+0xdc>
 18068bc:	20800083 	ldbu	r2,2(r4)
 18068c0:	21c00084 	addi	r7,r4,2
 18068c4:	28800926 	beq	r5,r2,18068ec <memchr+0xdc>
 18068c8:	208000c3 	ldbu	r2,3(r4)
 18068cc:	21c000c4 	addi	r7,r4,3
 18068d0:	28800626 	beq	r5,r2,18068ec <memchr+0xdc>
 18068d4:	21000104 	addi	r4,r4,4
 18068d8:	59bfea36 	bltu	r11,r6,1806884 <memchr+0x74>
 18068dc:	2007883a 	mov	r3,r4
 18068e0:	003fd106 	br	1806828 <memchr+0x18>
 18068e4:	0005883a 	mov	r2,zero
 18068e8:	f800283a 	ret
 18068ec:	3805883a 	mov	r2,r7
 18068f0:	f800283a 	ret

018068f4 <memcmp>:
 18068f4:	00c000c4 	movi	r3,3
 18068f8:	1980032e 	bgeu	r3,r6,1806908 <memcmp+0x14>
 18068fc:	2144b03a 	or	r2,r4,r5
 1806900:	10c4703a 	and	r2,r2,r3
 1806904:	10000f26 	beq	r2,zero,1806944 <memcmp+0x50>
 1806908:	31ffffc4 	addi	r7,r6,-1
 180690c:	3000061e 	bne	r6,zero,1806928 <memcmp+0x34>
 1806910:	00000a06 	br	180693c <memcmp+0x48>
 1806914:	39ffffc4 	addi	r7,r7,-1
 1806918:	00bfffc4 	movi	r2,-1
 180691c:	21000044 	addi	r4,r4,1
 1806920:	29400044 	addi	r5,r5,1
 1806924:	38800526 	beq	r7,r2,180693c <memcmp+0x48>
 1806928:	20c00003 	ldbu	r3,0(r4)
 180692c:	28800003 	ldbu	r2,0(r5)
 1806930:	18bff826 	beq	r3,r2,1806914 <memcmp+0x20>
 1806934:	1885c83a 	sub	r2,r3,r2
 1806938:	f800283a 	ret
 180693c:	0005883a 	mov	r2,zero
 1806940:	f800283a 	ret
 1806944:	180f883a 	mov	r7,r3
 1806948:	20c00017 	ldw	r3,0(r4)
 180694c:	28800017 	ldw	r2,0(r5)
 1806950:	18bfed1e 	bne	r3,r2,1806908 <memcmp+0x14>
 1806954:	31bfff04 	addi	r6,r6,-4
 1806958:	21000104 	addi	r4,r4,4
 180695c:	29400104 	addi	r5,r5,4
 1806960:	39bff936 	bltu	r7,r6,1806948 <memcmp+0x54>
 1806964:	003fe806 	br	1806908 <memcmp+0x14>

01806968 <memcpy>:
 1806968:	01c003c4 	movi	r7,15
 180696c:	2007883a 	mov	r3,r4
 1806970:	3980032e 	bgeu	r7,r6,1806980 <memcpy+0x18>
 1806974:	2904b03a 	or	r2,r5,r4
 1806978:	108000cc 	andi	r2,r2,3
 180697c:	10000926 	beq	r2,zero,18069a4 <memcpy+0x3c>
 1806980:	30000626 	beq	r6,zero,180699c <memcpy+0x34>
 1806984:	30cd883a 	add	r6,r6,r3
 1806988:	28800003 	ldbu	r2,0(r5)
 180698c:	29400044 	addi	r5,r5,1
 1806990:	18800005 	stb	r2,0(r3)
 1806994:	18c00044 	addi	r3,r3,1
 1806998:	30fffb1e 	bne	r6,r3,1806988 <memcpy+0x20>
 180699c:	2005883a 	mov	r2,r4
 18069a0:	f800283a 	ret
 18069a4:	3811883a 	mov	r8,r7
 18069a8:	200f883a 	mov	r7,r4
 18069ac:	28c00017 	ldw	r3,0(r5)
 18069b0:	31bffc04 	addi	r6,r6,-16
 18069b4:	38c00015 	stw	r3,0(r7)
 18069b8:	28800117 	ldw	r2,4(r5)
 18069bc:	38800115 	stw	r2,4(r7)
 18069c0:	28c00217 	ldw	r3,8(r5)
 18069c4:	38c00215 	stw	r3,8(r7)
 18069c8:	28800317 	ldw	r2,12(r5)
 18069cc:	29400404 	addi	r5,r5,16
 18069d0:	38800315 	stw	r2,12(r7)
 18069d4:	39c00404 	addi	r7,r7,16
 18069d8:	41bff436 	bltu	r8,r6,18069ac <memcpy+0x44>
 18069dc:	008000c4 	movi	r2,3
 18069e0:	1180072e 	bgeu	r2,r6,1806a00 <memcpy+0x98>
 18069e4:	1007883a 	mov	r3,r2
 18069e8:	28800017 	ldw	r2,0(r5)
 18069ec:	31bfff04 	addi	r6,r6,-4
 18069f0:	29400104 	addi	r5,r5,4
 18069f4:	38800015 	stw	r2,0(r7)
 18069f8:	39c00104 	addi	r7,r7,4
 18069fc:	19bffa36 	bltu	r3,r6,18069e8 <memcpy+0x80>
 1806a00:	3807883a 	mov	r3,r7
 1806a04:	003fde06 	br	1806980 <memcpy+0x18>

01806a08 <memmove>:
 1806a08:	2807883a 	mov	r3,r5
 1806a0c:	2011883a 	mov	r8,r4
 1806a10:	29000c2e 	bgeu	r5,r4,1806a44 <memmove+0x3c>
 1806a14:	298f883a 	add	r7,r5,r6
 1806a18:	21c00a2e 	bgeu	r4,r7,1806a44 <memmove+0x3c>
 1806a1c:	30000726 	beq	r6,zero,1806a3c <memmove+0x34>
 1806a20:	2187883a 	add	r3,r4,r6
 1806a24:	198dc83a 	sub	r6,r3,r6
 1806a28:	39ffffc4 	addi	r7,r7,-1
 1806a2c:	38800003 	ldbu	r2,0(r7)
 1806a30:	18ffffc4 	addi	r3,r3,-1
 1806a34:	18800005 	stb	r2,0(r3)
 1806a38:	19bffb1e 	bne	r3,r6,1806a28 <memmove+0x20>
 1806a3c:	2005883a 	mov	r2,r4
 1806a40:	f800283a 	ret
 1806a44:	01c003c4 	movi	r7,15
 1806a48:	39800a36 	bltu	r7,r6,1806a74 <memmove+0x6c>
 1806a4c:	303ffb26 	beq	r6,zero,1806a3c <memmove+0x34>
 1806a50:	400f883a 	mov	r7,r8
 1806a54:	320d883a 	add	r6,r6,r8
 1806a58:	28800003 	ldbu	r2,0(r5)
 1806a5c:	29400044 	addi	r5,r5,1
 1806a60:	38800005 	stb	r2,0(r7)
 1806a64:	39c00044 	addi	r7,r7,1
 1806a68:	39bffb1e 	bne	r7,r6,1806a58 <memmove+0x50>
 1806a6c:	2005883a 	mov	r2,r4
 1806a70:	f800283a 	ret
 1806a74:	1904b03a 	or	r2,r3,r4
 1806a78:	108000cc 	andi	r2,r2,3
 1806a7c:	103ff31e 	bne	r2,zero,1806a4c <memmove+0x44>
 1806a80:	3811883a 	mov	r8,r7
 1806a84:	180b883a 	mov	r5,r3
 1806a88:	200f883a 	mov	r7,r4
 1806a8c:	28c00017 	ldw	r3,0(r5)
 1806a90:	31bffc04 	addi	r6,r6,-16
 1806a94:	38c00015 	stw	r3,0(r7)
 1806a98:	28800117 	ldw	r2,4(r5)
 1806a9c:	38800115 	stw	r2,4(r7)
 1806aa0:	28c00217 	ldw	r3,8(r5)
 1806aa4:	38c00215 	stw	r3,8(r7)
 1806aa8:	28800317 	ldw	r2,12(r5)
 1806aac:	29400404 	addi	r5,r5,16
 1806ab0:	38800315 	stw	r2,12(r7)
 1806ab4:	39c00404 	addi	r7,r7,16
 1806ab8:	41bff436 	bltu	r8,r6,1806a8c <memmove+0x84>
 1806abc:	008000c4 	movi	r2,3
 1806ac0:	1180072e 	bgeu	r2,r6,1806ae0 <memmove+0xd8>
 1806ac4:	1007883a 	mov	r3,r2
 1806ac8:	28800017 	ldw	r2,0(r5)
 1806acc:	31bfff04 	addi	r6,r6,-4
 1806ad0:	29400104 	addi	r5,r5,4
 1806ad4:	38800015 	stw	r2,0(r7)
 1806ad8:	39c00104 	addi	r7,r7,4
 1806adc:	19bffa36 	bltu	r3,r6,1806ac8 <memmove+0xc0>
 1806ae0:	3811883a 	mov	r8,r7
 1806ae4:	003fd906 	br	1806a4c <memmove+0x44>

01806ae8 <putc>:
 1806ae8:	defffc04 	addi	sp,sp,-16
 1806aec:	dc800215 	stw	r18,8(sp)
 1806af0:	04806074 	movhi	r18,385
 1806af4:	94abd604 	addi	r18,r18,-20648
 1806af8:	90c00017 	ldw	r3,0(r18)
 1806afc:	dc400115 	stw	r17,4(sp)
 1806b00:	dc000015 	stw	r16,0(sp)
 1806b04:	dfc00315 	stw	ra,12(sp)
 1806b08:	2023883a 	mov	r17,r4
 1806b0c:	2821883a 	mov	r16,r5
 1806b10:	18000226 	beq	r3,zero,1806b1c <putc+0x34>
 1806b14:	18800e17 	ldw	r2,56(r3)
 1806b18:	10001126 	beq	r2,zero,1806b60 <putc+0x78>
 1806b1c:	80800217 	ldw	r2,8(r16)
 1806b20:	10ffffc4 	addi	r3,r2,-1
 1806b24:	80c00215 	stw	r3,8(r16)
 1806b28:	18001316 	blt	r3,zero,1806b78 <putc+0x90>
 1806b2c:	80800017 	ldw	r2,0(r16)
 1806b30:	14400005 	stb	r17,0(r2)
 1806b34:	80c00017 	ldw	r3,0(r16)
 1806b38:	18800044 	addi	r2,r3,1
 1806b3c:	18c00003 	ldbu	r3,0(r3)
 1806b40:	80800015 	stw	r2,0(r16)
 1806b44:	1805883a 	mov	r2,r3
 1806b48:	dfc00317 	ldw	ra,12(sp)
 1806b4c:	dc800217 	ldw	r18,8(sp)
 1806b50:	dc400117 	ldw	r17,4(sp)
 1806b54:	dc000017 	ldw	r16,0(sp)
 1806b58:	dec00404 	addi	sp,sp,16
 1806b5c:	f800283a 	ret
 1806b60:	1809883a 	mov	r4,r3
 1806b64:	1807bb40 	call	1807bb4 <__sinit>
 1806b68:	80800217 	ldw	r2,8(r16)
 1806b6c:	10ffffc4 	addi	r3,r2,-1
 1806b70:	80c00215 	stw	r3,8(r16)
 1806b74:	183fed0e 	bge	r3,zero,1806b2c <putc+0x44>
 1806b78:	80800617 	ldw	r2,24(r16)
 1806b7c:	18800f16 	blt	r3,r2,1806bbc <putc+0xd4>
 1806b80:	80800017 	ldw	r2,0(r16)
 1806b84:	14400005 	stb	r17,0(r2)
 1806b88:	81000017 	ldw	r4,0(r16)
 1806b8c:	00800284 	movi	r2,10
 1806b90:	20c00003 	ldbu	r3,0(r4)
 1806b94:	18801226 	beq	r3,r2,1806be0 <putc+0xf8>
 1806b98:	20800044 	addi	r2,r4,1
 1806b9c:	80800015 	stw	r2,0(r16)
 1806ba0:	1805883a 	mov	r2,r3
 1806ba4:	dfc00317 	ldw	ra,12(sp)
 1806ba8:	dc800217 	ldw	r18,8(sp)
 1806bac:	dc400117 	ldw	r17,4(sp)
 1806bb0:	dc000017 	ldw	r16,0(sp)
 1806bb4:	dec00404 	addi	sp,sp,16
 1806bb8:	f800283a 	ret
 1806bbc:	91000017 	ldw	r4,0(r18)
 1806bc0:	880b883a 	mov	r5,r17
 1806bc4:	800d883a 	mov	r6,r16
 1806bc8:	dfc00317 	ldw	ra,12(sp)
 1806bcc:	dc800217 	ldw	r18,8(sp)
 1806bd0:	dc400117 	ldw	r17,4(sp)
 1806bd4:	dc000017 	ldw	r16,0(sp)
 1806bd8:	dec00404 	addi	sp,sp,16
 1806bdc:	18073ac1 	jmpi	18073ac <__swbuf_r>
 1806be0:	91000017 	ldw	r4,0(r18)
 1806be4:	180b883a 	mov	r5,r3
 1806be8:	003ff606 	br	1806bc4 <putc+0xdc>

01806bec <_putc_r>:
 1806bec:	defffc04 	addi	sp,sp,-16
 1806bf0:	dc400215 	stw	r17,8(sp)
 1806bf4:	dc000115 	stw	r16,4(sp)
 1806bf8:	dfc00315 	stw	ra,12(sp)
 1806bfc:	2021883a 	mov	r16,r4
 1806c00:	2823883a 	mov	r17,r5
 1806c04:	20000226 	beq	r4,zero,1806c10 <_putc_r+0x24>
 1806c08:	20800e17 	ldw	r2,56(r4)
 1806c0c:	10001026 	beq	r2,zero,1806c50 <_putc_r+0x64>
 1806c10:	30800217 	ldw	r2,8(r6)
 1806c14:	10ffffc4 	addi	r3,r2,-1
 1806c18:	30c00215 	stw	r3,8(r6)
 1806c1c:	18001316 	blt	r3,zero,1806c6c <_putc_r+0x80>
 1806c20:	30800017 	ldw	r2,0(r6)
 1806c24:	14400005 	stb	r17,0(r2)
 1806c28:	30c00017 	ldw	r3,0(r6)
 1806c2c:	18800044 	addi	r2,r3,1
 1806c30:	18c00003 	ldbu	r3,0(r3)
 1806c34:	30800015 	stw	r2,0(r6)
 1806c38:	1805883a 	mov	r2,r3
 1806c3c:	dfc00317 	ldw	ra,12(sp)
 1806c40:	dc400217 	ldw	r17,8(sp)
 1806c44:	dc000117 	ldw	r16,4(sp)
 1806c48:	dec00404 	addi	sp,sp,16
 1806c4c:	f800283a 	ret
 1806c50:	d9800015 	stw	r6,0(sp)
 1806c54:	1807bb40 	call	1807bb4 <__sinit>
 1806c58:	d9800017 	ldw	r6,0(sp)
 1806c5c:	30800217 	ldw	r2,8(r6)
 1806c60:	10ffffc4 	addi	r3,r2,-1
 1806c64:	30c00215 	stw	r3,8(r6)
 1806c68:	183fed0e 	bge	r3,zero,1806c20 <_putc_r+0x34>
 1806c6c:	30800617 	ldw	r2,24(r6)
 1806c70:	18800e16 	blt	r3,r2,1806cac <_putc_r+0xc0>
 1806c74:	30800017 	ldw	r2,0(r6)
 1806c78:	14400005 	stb	r17,0(r2)
 1806c7c:	31000017 	ldw	r4,0(r6)
 1806c80:	00800284 	movi	r2,10
 1806c84:	20c00003 	ldbu	r3,0(r4)
 1806c88:	18800f26 	beq	r3,r2,1806cc8 <_putc_r+0xdc>
 1806c8c:	20800044 	addi	r2,r4,1
 1806c90:	30800015 	stw	r2,0(r6)
 1806c94:	1805883a 	mov	r2,r3
 1806c98:	dfc00317 	ldw	ra,12(sp)
 1806c9c:	dc400217 	ldw	r17,8(sp)
 1806ca0:	dc000117 	ldw	r16,4(sp)
 1806ca4:	dec00404 	addi	sp,sp,16
 1806ca8:	f800283a 	ret
 1806cac:	8009883a 	mov	r4,r16
 1806cb0:	880b883a 	mov	r5,r17
 1806cb4:	dfc00317 	ldw	ra,12(sp)
 1806cb8:	dc400217 	ldw	r17,8(sp)
 1806cbc:	dc000117 	ldw	r16,4(sp)
 1806cc0:	dec00404 	addi	sp,sp,16
 1806cc4:	18073ac1 	jmpi	18073ac <__swbuf_r>
 1806cc8:	8009883a 	mov	r4,r16
 1806ccc:	180b883a 	mov	r5,r3
 1806cd0:	003ff806 	br	1806cb4 <_putc_r+0xc8>

01806cd4 <_realloc_r>:
 1806cd4:	defff404 	addi	sp,sp,-48
 1806cd8:	dd800815 	stw	r22,32(sp)
 1806cdc:	dc800415 	stw	r18,16(sp)
 1806ce0:	dc400315 	stw	r17,12(sp)
 1806ce4:	dfc00b15 	stw	ra,44(sp)
 1806ce8:	df000a15 	stw	fp,40(sp)
 1806cec:	ddc00915 	stw	r23,36(sp)
 1806cf0:	dd400715 	stw	r21,28(sp)
 1806cf4:	dd000615 	stw	r20,24(sp)
 1806cf8:	dcc00515 	stw	r19,20(sp)
 1806cfc:	dc000215 	stw	r16,8(sp)
 1806d00:	2825883a 	mov	r18,r5
 1806d04:	3023883a 	mov	r17,r6
 1806d08:	202d883a 	mov	r22,r4
 1806d0c:	2800c926 	beq	r5,zero,1807034 <_realloc_r+0x360>
 1806d10:	1808fa40 	call	1808fa4 <__malloc_lock>
 1806d14:	943ffe04 	addi	r16,r18,-8
 1806d18:	88c002c4 	addi	r3,r17,11
 1806d1c:	00800584 	movi	r2,22
 1806d20:	82000117 	ldw	r8,4(r16)
 1806d24:	10c01b2e 	bgeu	r2,r3,1806d94 <_realloc_r+0xc0>
 1806d28:	00bffe04 	movi	r2,-8
 1806d2c:	188e703a 	and	r7,r3,r2
 1806d30:	3839883a 	mov	fp,r7
 1806d34:	38001a16 	blt	r7,zero,1806da0 <_realloc_r+0xcc>
 1806d38:	e4401936 	bltu	fp,r17,1806da0 <_realloc_r+0xcc>
 1806d3c:	013fff04 	movi	r4,-4
 1806d40:	4126703a 	and	r19,r8,r4
 1806d44:	99c02616 	blt	r19,r7,1806de0 <_realloc_r+0x10c>
 1806d48:	802b883a 	mov	r21,r16
 1806d4c:	9829883a 	mov	r20,r19
 1806d50:	84000204 	addi	r16,r16,8
 1806d54:	a80f883a 	mov	r7,r21
 1806d58:	a70dc83a 	sub	r6,r20,fp
 1806d5c:	008003c4 	movi	r2,15
 1806d60:	1180c136 	bltu	r2,r6,1807068 <_realloc_r+0x394>
 1806d64:	38800117 	ldw	r2,4(r7)
 1806d68:	a549883a 	add	r4,r20,r21
 1806d6c:	1080004c 	andi	r2,r2,1
 1806d70:	a084b03a 	or	r2,r20,r2
 1806d74:	38800115 	stw	r2,4(r7)
 1806d78:	20c00117 	ldw	r3,4(r4)
 1806d7c:	18c00054 	ori	r3,r3,1
 1806d80:	20c00115 	stw	r3,4(r4)
 1806d84:	b009883a 	mov	r4,r22
 1806d88:	1808fc40 	call	1808fc4 <__malloc_unlock>
 1806d8c:	8023883a 	mov	r17,r16
 1806d90:	00000606 	br	1806dac <_realloc_r+0xd8>
 1806d94:	01c00404 	movi	r7,16
 1806d98:	3839883a 	mov	fp,r7
 1806d9c:	e47fe72e 	bgeu	fp,r17,1806d3c <_realloc_r+0x68>
 1806da0:	00800304 	movi	r2,12
 1806da4:	0023883a 	mov	r17,zero
 1806da8:	b0800015 	stw	r2,0(r22)
 1806dac:	8805883a 	mov	r2,r17
 1806db0:	dfc00b17 	ldw	ra,44(sp)
 1806db4:	df000a17 	ldw	fp,40(sp)
 1806db8:	ddc00917 	ldw	r23,36(sp)
 1806dbc:	dd800817 	ldw	r22,32(sp)
 1806dc0:	dd400717 	ldw	r21,28(sp)
 1806dc4:	dd000617 	ldw	r20,24(sp)
 1806dc8:	dcc00517 	ldw	r19,20(sp)
 1806dcc:	dc800417 	ldw	r18,16(sp)
 1806dd0:	dc400317 	ldw	r17,12(sp)
 1806dd4:	dc000217 	ldw	r16,8(sp)
 1806dd8:	dec00c04 	addi	sp,sp,48
 1806ddc:	f800283a 	ret
 1806de0:	00806074 	movhi	r2,385
 1806de4:	10aacb04 	addi	r2,r2,-21716
 1806de8:	12400217 	ldw	r9,8(r2)
 1806dec:	84cd883a 	add	r6,r16,r19
 1806df0:	802b883a 	mov	r21,r16
 1806df4:	3240b926 	beq	r6,r9,18070dc <_realloc_r+0x408>
 1806df8:	31400117 	ldw	r5,4(r6)
 1806dfc:	00bfff84 	movi	r2,-2
 1806e00:	2884703a 	and	r2,r5,r2
 1806e04:	1185883a 	add	r2,r2,r6
 1806e08:	10c00117 	ldw	r3,4(r2)
 1806e0c:	18c0004c 	andi	r3,r3,1
 1806e10:	1807003a 	cmpeq	r3,r3,zero
 1806e14:	1800a326 	beq	r3,zero,18070a4 <_realloc_r+0x3d0>
 1806e18:	2908703a 	and	r4,r5,r4
 1806e1c:	9929883a 	add	r20,r19,r4
 1806e20:	a1c0a30e 	bge	r20,r7,18070b0 <_realloc_r+0x3dc>
 1806e24:	4080004c 	andi	r2,r8,1
 1806e28:	1000551e 	bne	r2,zero,1806f80 <_realloc_r+0x2ac>
 1806e2c:	80800017 	ldw	r2,0(r16)
 1806e30:	80afc83a 	sub	r23,r16,r2
 1806e34:	b8c00117 	ldw	r3,4(r23)
 1806e38:	00bfff04 	movi	r2,-4
 1806e3c:	1884703a 	and	r2,r3,r2
 1806e40:	30002e26 	beq	r6,zero,1806efc <_realloc_r+0x228>
 1806e44:	3240b926 	beq	r6,r9,180712c <_realloc_r+0x458>
 1806e48:	98a9883a 	add	r20,r19,r2
 1806e4c:	2509883a 	add	r4,r4,r20
 1806e50:	d9000015 	stw	r4,0(sp)
 1806e54:	21c02a16 	blt	r4,r7,1806f00 <_realloc_r+0x22c>
 1806e58:	30800317 	ldw	r2,12(r6)
 1806e5c:	30c00217 	ldw	r3,8(r6)
 1806e60:	01400904 	movi	r5,36
 1806e64:	99bfff04 	addi	r6,r19,-4
 1806e68:	18800315 	stw	r2,12(r3)
 1806e6c:	10c00215 	stw	r3,8(r2)
 1806e70:	b9000317 	ldw	r4,12(r23)
 1806e74:	b8800217 	ldw	r2,8(r23)
 1806e78:	b82b883a 	mov	r21,r23
 1806e7c:	bc000204 	addi	r16,r23,8
 1806e80:	20800215 	stw	r2,8(r4)
 1806e84:	11000315 	stw	r4,12(r2)
 1806e88:	2980e436 	bltu	r5,r6,180721c <_realloc_r+0x548>
 1806e8c:	008004c4 	movi	r2,19
 1806e90:	9009883a 	mov	r4,r18
 1806e94:	8011883a 	mov	r8,r16
 1806e98:	11800f2e 	bgeu	r2,r6,1806ed8 <_realloc_r+0x204>
 1806e9c:	90800017 	ldw	r2,0(r18)
 1806ea0:	ba000404 	addi	r8,r23,16
 1806ea4:	91000204 	addi	r4,r18,8
 1806ea8:	b8800215 	stw	r2,8(r23)
 1806eac:	90c00117 	ldw	r3,4(r18)
 1806eb0:	008006c4 	movi	r2,27
 1806eb4:	b8c00315 	stw	r3,12(r23)
 1806eb8:	1180072e 	bgeu	r2,r6,1806ed8 <_realloc_r+0x204>
 1806ebc:	90c00217 	ldw	r3,8(r18)
 1806ec0:	ba000604 	addi	r8,r23,24
 1806ec4:	91000404 	addi	r4,r18,16
 1806ec8:	b8c00415 	stw	r3,16(r23)
 1806ecc:	90800317 	ldw	r2,12(r18)
 1806ed0:	b8800515 	stw	r2,20(r23)
 1806ed4:	3140e726 	beq	r6,r5,1807274 <_realloc_r+0x5a0>
 1806ed8:	20800017 	ldw	r2,0(r4)
 1806edc:	dd000017 	ldw	r20,0(sp)
 1806ee0:	b80f883a 	mov	r7,r23
 1806ee4:	40800015 	stw	r2,0(r8)
 1806ee8:	20c00117 	ldw	r3,4(r4)
 1806eec:	40c00115 	stw	r3,4(r8)
 1806ef0:	20800217 	ldw	r2,8(r4)
 1806ef4:	40800215 	stw	r2,8(r8)
 1806ef8:	003f9706 	br	1806d58 <_realloc_r+0x84>
 1806efc:	98a9883a 	add	r20,r19,r2
 1806f00:	a1c01f16 	blt	r20,r7,1806f80 <_realloc_r+0x2ac>
 1806f04:	b8c00317 	ldw	r3,12(r23)
 1806f08:	b8800217 	ldw	r2,8(r23)
 1806f0c:	99bfff04 	addi	r6,r19,-4
 1806f10:	01400904 	movi	r5,36
 1806f14:	b82b883a 	mov	r21,r23
 1806f18:	18800215 	stw	r2,8(r3)
 1806f1c:	10c00315 	stw	r3,12(r2)
 1806f20:	bc000204 	addi	r16,r23,8
 1806f24:	2980c336 	bltu	r5,r6,1807234 <_realloc_r+0x560>
 1806f28:	008004c4 	movi	r2,19
 1806f2c:	9009883a 	mov	r4,r18
 1806f30:	8011883a 	mov	r8,r16
 1806f34:	11800f2e 	bgeu	r2,r6,1806f74 <_realloc_r+0x2a0>
 1806f38:	90800017 	ldw	r2,0(r18)
 1806f3c:	ba000404 	addi	r8,r23,16
 1806f40:	91000204 	addi	r4,r18,8
 1806f44:	b8800215 	stw	r2,8(r23)
 1806f48:	90c00117 	ldw	r3,4(r18)
 1806f4c:	008006c4 	movi	r2,27
 1806f50:	b8c00315 	stw	r3,12(r23)
 1806f54:	1180072e 	bgeu	r2,r6,1806f74 <_realloc_r+0x2a0>
 1806f58:	90c00217 	ldw	r3,8(r18)
 1806f5c:	ba000604 	addi	r8,r23,24
 1806f60:	91000404 	addi	r4,r18,16
 1806f64:	b8c00415 	stw	r3,16(r23)
 1806f68:	90800317 	ldw	r2,12(r18)
 1806f6c:	b8800515 	stw	r2,20(r23)
 1806f70:	3140c726 	beq	r6,r5,1807290 <_realloc_r+0x5bc>
 1806f74:	20800017 	ldw	r2,0(r4)
 1806f78:	b80f883a 	mov	r7,r23
 1806f7c:	003fd906 	br	1806ee4 <_realloc_r+0x210>
 1806f80:	880b883a 	mov	r5,r17
 1806f84:	b009883a 	mov	r4,r22
 1806f88:	18060d00 	call	18060d0 <_malloc_r>
 1806f8c:	1023883a 	mov	r17,r2
 1806f90:	10002526 	beq	r2,zero,1807028 <_realloc_r+0x354>
 1806f94:	80800117 	ldw	r2,4(r16)
 1806f98:	00ffff84 	movi	r3,-2
 1806f9c:	893ffe04 	addi	r4,r17,-8
 1806fa0:	10c4703a 	and	r2,r2,r3
 1806fa4:	8085883a 	add	r2,r16,r2
 1806fa8:	20809526 	beq	r4,r2,1807200 <_realloc_r+0x52c>
 1806fac:	99bfff04 	addi	r6,r19,-4
 1806fb0:	01c00904 	movi	r7,36
 1806fb4:	39804536 	bltu	r7,r6,18070cc <_realloc_r+0x3f8>
 1806fb8:	008004c4 	movi	r2,19
 1806fbc:	9009883a 	mov	r4,r18
 1806fc0:	880b883a 	mov	r5,r17
 1806fc4:	11800f2e 	bgeu	r2,r6,1807004 <_realloc_r+0x330>
 1806fc8:	90800017 	ldw	r2,0(r18)
 1806fcc:	89400204 	addi	r5,r17,8
 1806fd0:	91000204 	addi	r4,r18,8
 1806fd4:	88800015 	stw	r2,0(r17)
 1806fd8:	90c00117 	ldw	r3,4(r18)
 1806fdc:	008006c4 	movi	r2,27
 1806fe0:	88c00115 	stw	r3,4(r17)
 1806fe4:	1180072e 	bgeu	r2,r6,1807004 <_realloc_r+0x330>
 1806fe8:	90c00217 	ldw	r3,8(r18)
 1806fec:	89400404 	addi	r5,r17,16
 1806ff0:	91000404 	addi	r4,r18,16
 1806ff4:	88c00215 	stw	r3,8(r17)
 1806ff8:	90800317 	ldw	r2,12(r18)
 1806ffc:	88800315 	stw	r2,12(r17)
 1807000:	31c09126 	beq	r6,r7,1807248 <_realloc_r+0x574>
 1807004:	20800017 	ldw	r2,0(r4)
 1807008:	28800015 	stw	r2,0(r5)
 180700c:	20c00117 	ldw	r3,4(r4)
 1807010:	28c00115 	stw	r3,4(r5)
 1807014:	20800217 	ldw	r2,8(r4)
 1807018:	28800215 	stw	r2,8(r5)
 180701c:	900b883a 	mov	r5,r18
 1807020:	b009883a 	mov	r4,r22
 1807024:	1807f6c0 	call	1807f6c <_free_r>
 1807028:	b009883a 	mov	r4,r22
 180702c:	1808fc40 	call	1808fc4 <__malloc_unlock>
 1807030:	003f5e06 	br	1806dac <_realloc_r+0xd8>
 1807034:	300b883a 	mov	r5,r6
 1807038:	dfc00b17 	ldw	ra,44(sp)
 180703c:	df000a17 	ldw	fp,40(sp)
 1807040:	ddc00917 	ldw	r23,36(sp)
 1807044:	dd800817 	ldw	r22,32(sp)
 1807048:	dd400717 	ldw	r21,28(sp)
 180704c:	dd000617 	ldw	r20,24(sp)
 1807050:	dcc00517 	ldw	r19,20(sp)
 1807054:	dc800417 	ldw	r18,16(sp)
 1807058:	dc400317 	ldw	r17,12(sp)
 180705c:	dc000217 	ldw	r16,8(sp)
 1807060:	dec00c04 	addi	sp,sp,48
 1807064:	18060d01 	jmpi	18060d0 <_malloc_r>
 1807068:	38800117 	ldw	r2,4(r7)
 180706c:	e54b883a 	add	r5,fp,r21
 1807070:	31000054 	ori	r4,r6,1
 1807074:	1080004c 	andi	r2,r2,1
 1807078:	1704b03a 	or	r2,r2,fp
 180707c:	38800115 	stw	r2,4(r7)
 1807080:	29000115 	stw	r4,4(r5)
 1807084:	2987883a 	add	r3,r5,r6
 1807088:	18800117 	ldw	r2,4(r3)
 180708c:	29400204 	addi	r5,r5,8
 1807090:	b009883a 	mov	r4,r22
 1807094:	10800054 	ori	r2,r2,1
 1807098:	18800115 	stw	r2,4(r3)
 180709c:	1807f6c0 	call	1807f6c <_free_r>
 18070a0:	003f3806 	br	1806d84 <_realloc_r+0xb0>
 18070a4:	000d883a 	mov	r6,zero
 18070a8:	0009883a 	mov	r4,zero
 18070ac:	003f5d06 	br	1806e24 <_realloc_r+0x150>
 18070b0:	30c00217 	ldw	r3,8(r6)
 18070b4:	30800317 	ldw	r2,12(r6)
 18070b8:	800f883a 	mov	r7,r16
 18070bc:	84000204 	addi	r16,r16,8
 18070c0:	10c00215 	stw	r3,8(r2)
 18070c4:	18800315 	stw	r2,12(r3)
 18070c8:	003f2306 	br	1806d58 <_realloc_r+0x84>
 18070cc:	8809883a 	mov	r4,r17
 18070d0:	900b883a 	mov	r5,r18
 18070d4:	1806a080 	call	1806a08 <memmove>
 18070d8:	003fd006 	br	180701c <_realloc_r+0x348>
 18070dc:	30800117 	ldw	r2,4(r6)
 18070e0:	e0c00404 	addi	r3,fp,16
 18070e4:	1108703a 	and	r4,r2,r4
 18070e8:	9905883a 	add	r2,r19,r4
 18070ec:	10ff4d16 	blt	r2,r3,1806e24 <_realloc_r+0x150>
 18070f0:	1705c83a 	sub	r2,r2,fp
 18070f4:	870b883a 	add	r5,r16,fp
 18070f8:	10800054 	ori	r2,r2,1
 18070fc:	28800115 	stw	r2,4(r5)
 1807100:	80c00117 	ldw	r3,4(r16)
 1807104:	00806074 	movhi	r2,385
 1807108:	10aacb04 	addi	r2,r2,-21716
 180710c:	b009883a 	mov	r4,r22
 1807110:	18c0004c 	andi	r3,r3,1
 1807114:	e0c6b03a 	or	r3,fp,r3
 1807118:	11400215 	stw	r5,8(r2)
 180711c:	80c00115 	stw	r3,4(r16)
 1807120:	1808fc40 	call	1808fc4 <__malloc_unlock>
 1807124:	84400204 	addi	r17,r16,8
 1807128:	003f2006 	br	1806dac <_realloc_r+0xd8>
 180712c:	98a9883a 	add	r20,r19,r2
 1807130:	2509883a 	add	r4,r4,r20
 1807134:	e0800404 	addi	r2,fp,16
 1807138:	d9000115 	stw	r4,4(sp)
 180713c:	20bf7016 	blt	r4,r2,1806f00 <_realloc_r+0x22c>
 1807140:	b8c00317 	ldw	r3,12(r23)
 1807144:	b8800217 	ldw	r2,8(r23)
 1807148:	99bfff04 	addi	r6,r19,-4
 180714c:	01400904 	movi	r5,36
 1807150:	18800215 	stw	r2,8(r3)
 1807154:	10c00315 	stw	r3,12(r2)
 1807158:	bc400204 	addi	r17,r23,8
 180715c:	29804136 	bltu	r5,r6,1807264 <_realloc_r+0x590>
 1807160:	008004c4 	movi	r2,19
 1807164:	9009883a 	mov	r4,r18
 1807168:	880f883a 	mov	r7,r17
 180716c:	11800f2e 	bgeu	r2,r6,18071ac <_realloc_r+0x4d8>
 1807170:	90800017 	ldw	r2,0(r18)
 1807174:	b9c00404 	addi	r7,r23,16
 1807178:	91000204 	addi	r4,r18,8
 180717c:	b8800215 	stw	r2,8(r23)
 1807180:	90c00117 	ldw	r3,4(r18)
 1807184:	008006c4 	movi	r2,27
 1807188:	b8c00315 	stw	r3,12(r23)
 180718c:	1180072e 	bgeu	r2,r6,18071ac <_realloc_r+0x4d8>
 1807190:	90c00217 	ldw	r3,8(r18)
 1807194:	b9c00604 	addi	r7,r23,24
 1807198:	91000404 	addi	r4,r18,16
 180719c:	b8c00415 	stw	r3,16(r23)
 18071a0:	90800317 	ldw	r2,12(r18)
 18071a4:	b8800515 	stw	r2,20(r23)
 18071a8:	31404026 	beq	r6,r5,18072ac <_realloc_r+0x5d8>
 18071ac:	20800017 	ldw	r2,0(r4)
 18071b0:	38800015 	stw	r2,0(r7)
 18071b4:	20c00117 	ldw	r3,4(r4)
 18071b8:	38c00115 	stw	r3,4(r7)
 18071bc:	20800217 	ldw	r2,8(r4)
 18071c0:	38800215 	stw	r2,8(r7)
 18071c4:	d8c00117 	ldw	r3,4(sp)
 18071c8:	bf0b883a 	add	r5,r23,fp
 18071cc:	b009883a 	mov	r4,r22
 18071d0:	1f05c83a 	sub	r2,r3,fp
 18071d4:	10800054 	ori	r2,r2,1
 18071d8:	28800115 	stw	r2,4(r5)
 18071dc:	b8c00117 	ldw	r3,4(r23)
 18071e0:	00806074 	movhi	r2,385
 18071e4:	10aacb04 	addi	r2,r2,-21716
 18071e8:	11400215 	stw	r5,8(r2)
 18071ec:	18c0004c 	andi	r3,r3,1
 18071f0:	e0c6b03a 	or	r3,fp,r3
 18071f4:	b8c00115 	stw	r3,4(r23)
 18071f8:	1808fc40 	call	1808fc4 <__malloc_unlock>
 18071fc:	003eeb06 	br	1806dac <_realloc_r+0xd8>
 1807200:	20800117 	ldw	r2,4(r4)
 1807204:	00ffff04 	movi	r3,-4
 1807208:	800f883a 	mov	r7,r16
 180720c:	10c4703a 	and	r2,r2,r3
 1807210:	98a9883a 	add	r20,r19,r2
 1807214:	84000204 	addi	r16,r16,8
 1807218:	003ecf06 	br	1806d58 <_realloc_r+0x84>
 180721c:	900b883a 	mov	r5,r18
 1807220:	8009883a 	mov	r4,r16
 1807224:	1806a080 	call	1806a08 <memmove>
 1807228:	dd000017 	ldw	r20,0(sp)
 180722c:	b80f883a 	mov	r7,r23
 1807230:	003ec906 	br	1806d58 <_realloc_r+0x84>
 1807234:	900b883a 	mov	r5,r18
 1807238:	8009883a 	mov	r4,r16
 180723c:	1806a080 	call	1806a08 <memmove>
 1807240:	b80f883a 	mov	r7,r23
 1807244:	003ec406 	br	1806d58 <_realloc_r+0x84>
 1807248:	90c00417 	ldw	r3,16(r18)
 180724c:	89400604 	addi	r5,r17,24
 1807250:	91000604 	addi	r4,r18,24
 1807254:	88c00415 	stw	r3,16(r17)
 1807258:	90800517 	ldw	r2,20(r18)
 180725c:	88800515 	stw	r2,20(r17)
 1807260:	003f6806 	br	1807004 <_realloc_r+0x330>
 1807264:	900b883a 	mov	r5,r18
 1807268:	8809883a 	mov	r4,r17
 180726c:	1806a080 	call	1806a08 <memmove>
 1807270:	003fd406 	br	18071c4 <_realloc_r+0x4f0>
 1807274:	90c00417 	ldw	r3,16(r18)
 1807278:	91000604 	addi	r4,r18,24
 180727c:	ba000804 	addi	r8,r23,32
 1807280:	b8c00615 	stw	r3,24(r23)
 1807284:	90800517 	ldw	r2,20(r18)
 1807288:	b8800715 	stw	r2,28(r23)
 180728c:	003f1206 	br	1806ed8 <_realloc_r+0x204>
 1807290:	90c00417 	ldw	r3,16(r18)
 1807294:	91000604 	addi	r4,r18,24
 1807298:	ba000804 	addi	r8,r23,32
 180729c:	b8c00615 	stw	r3,24(r23)
 18072a0:	90800517 	ldw	r2,20(r18)
 18072a4:	b8800715 	stw	r2,28(r23)
 18072a8:	003f3206 	br	1806f74 <_realloc_r+0x2a0>
 18072ac:	90c00417 	ldw	r3,16(r18)
 18072b0:	91000604 	addi	r4,r18,24
 18072b4:	b9c00804 	addi	r7,r23,32
 18072b8:	b8c00615 	stw	r3,24(r23)
 18072bc:	90800517 	ldw	r2,20(r18)
 18072c0:	b8800715 	stw	r2,28(r23)
 18072c4:	003fb906 	br	18071ac <_realloc_r+0x4d8>

018072c8 <_sbrk_r>:
 18072c8:	defffd04 	addi	sp,sp,-12
 18072cc:	dc000015 	stw	r16,0(sp)
 18072d0:	04006074 	movhi	r16,385
 18072d4:	8432a604 	addi	r16,r16,-13672
 18072d8:	dc400115 	stw	r17,4(sp)
 18072dc:	80000015 	stw	zero,0(r16)
 18072e0:	2023883a 	mov	r17,r4
 18072e4:	2809883a 	mov	r4,r5
 18072e8:	dfc00215 	stw	ra,8(sp)
 18072ec:	18091680 	call	1809168 <sbrk>
 18072f0:	1007883a 	mov	r3,r2
 18072f4:	00bfffc4 	movi	r2,-1
 18072f8:	18800626 	beq	r3,r2,1807314 <_sbrk_r+0x4c>
 18072fc:	1805883a 	mov	r2,r3
 1807300:	dfc00217 	ldw	ra,8(sp)
 1807304:	dc400117 	ldw	r17,4(sp)
 1807308:	dc000017 	ldw	r16,0(sp)
 180730c:	dec00304 	addi	sp,sp,12
 1807310:	f800283a 	ret
 1807314:	80800017 	ldw	r2,0(r16)
 1807318:	103ff826 	beq	r2,zero,18072fc <_sbrk_r+0x34>
 180731c:	88800015 	stw	r2,0(r17)
 1807320:	1805883a 	mov	r2,r3
 1807324:	dfc00217 	ldw	ra,8(sp)
 1807328:	dc400117 	ldw	r17,4(sp)
 180732c:	dc000017 	ldw	r16,0(sp)
 1807330:	dec00304 	addi	sp,sp,12
 1807334:	f800283a 	ret

01807338 <strlen>:
 1807338:	208000cc 	andi	r2,r4,3
 180733c:	2011883a 	mov	r8,r4
 1807340:	1000161e 	bne	r2,zero,180739c <strlen+0x64>
 1807344:	20c00017 	ldw	r3,0(r4)
 1807348:	017fbff4 	movhi	r5,65279
 180734c:	297fbfc4 	addi	r5,r5,-257
 1807350:	01e02074 	movhi	r7,32897
 1807354:	39e02004 	addi	r7,r7,-32640
 1807358:	1945883a 	add	r2,r3,r5
 180735c:	11c4703a 	and	r2,r2,r7
 1807360:	00c6303a 	nor	r3,zero,r3
 1807364:	1886703a 	and	r3,r3,r2
 1807368:	18000c1e 	bne	r3,zero,180739c <strlen+0x64>
 180736c:	280d883a 	mov	r6,r5
 1807370:	380b883a 	mov	r5,r7
 1807374:	21000104 	addi	r4,r4,4
 1807378:	20800017 	ldw	r2,0(r4)
 180737c:	1187883a 	add	r3,r2,r6
 1807380:	1946703a 	and	r3,r3,r5
 1807384:	0084303a 	nor	r2,zero,r2
 1807388:	10c4703a 	and	r2,r2,r3
 180738c:	103ff926 	beq	r2,zero,1807374 <strlen+0x3c>
 1807390:	20800007 	ldb	r2,0(r4)
 1807394:	10000326 	beq	r2,zero,18073a4 <strlen+0x6c>
 1807398:	21000044 	addi	r4,r4,1
 180739c:	20800007 	ldb	r2,0(r4)
 18073a0:	103ffd1e 	bne	r2,zero,1807398 <strlen+0x60>
 18073a4:	2205c83a 	sub	r2,r4,r8
 18073a8:	f800283a 	ret

018073ac <__swbuf_r>:
 18073ac:	defffc04 	addi	sp,sp,-16
 18073b0:	dc400215 	stw	r17,8(sp)
 18073b4:	dc000115 	stw	r16,4(sp)
 18073b8:	dfc00315 	stw	ra,12(sp)
 18073bc:	2023883a 	mov	r17,r4
 18073c0:	2821883a 	mov	r16,r5
 18073c4:	20000226 	beq	r4,zero,18073d0 <__swbuf_r+0x24>
 18073c8:	20800e17 	ldw	r2,56(r4)
 18073cc:	10002f26 	beq	r2,zero,180748c <__swbuf_r+0xe0>
 18073d0:	3080030b 	ldhu	r2,12(r6)
 18073d4:	30c00617 	ldw	r3,24(r6)
 18073d8:	1080020c 	andi	r2,r2,8
 18073dc:	30c00215 	stw	r3,8(r6)
 18073e0:	10002226 	beq	r2,zero,180746c <__swbuf_r+0xc0>
 18073e4:	30c00417 	ldw	r3,16(r6)
 18073e8:	18002026 	beq	r3,zero,180746c <__swbuf_r+0xc0>
 18073ec:	31000017 	ldw	r4,0(r6)
 18073f0:	30800517 	ldw	r2,20(r6)
 18073f4:	20c7c83a 	sub	r3,r4,r3
 18073f8:	18802f0e 	bge	r3,r2,18074b8 <__swbuf_r+0x10c>
 18073fc:	19400044 	addi	r5,r3,1
 1807400:	30800217 	ldw	r2,8(r6)
 1807404:	84003fcc 	andi	r16,r16,255
 1807408:	20c00044 	addi	r3,r4,1
 180740c:	10bfffc4 	addi	r2,r2,-1
 1807410:	30800215 	stw	r2,8(r6)
 1807414:	24000005 	stb	r16,0(r4)
 1807418:	30800517 	ldw	r2,20(r6)
 180741c:	30c00015 	stw	r3,0(r6)
 1807420:	11400c26 	beq	r2,r5,1807454 <__swbuf_r+0xa8>
 1807424:	3080030b 	ldhu	r2,12(r6)
 1807428:	1080004c 	andi	r2,r2,1
 180742c:	1005003a 	cmpeq	r2,r2,zero
 1807430:	10000626 	beq	r2,zero,180744c <__swbuf_r+0xa0>
 1807434:	8005883a 	mov	r2,r16
 1807438:	dfc00317 	ldw	ra,12(sp)
 180743c:	dc400217 	ldw	r17,8(sp)
 1807440:	dc000117 	ldw	r16,4(sp)
 1807444:	dec00404 	addi	sp,sp,16
 1807448:	f800283a 	ret
 180744c:	00800284 	movi	r2,10
 1807450:	80bff81e 	bne	r16,r2,1807434 <__swbuf_r+0x88>
 1807454:	8809883a 	mov	r4,r17
 1807458:	300b883a 	mov	r5,r6
 180745c:	180791c0 	call	180791c <_fflush_r>
 1807460:	103ff426 	beq	r2,zero,1807434 <__swbuf_r+0x88>
 1807464:	043fffc4 	movi	r16,-1
 1807468:	003ff206 	br	1807434 <__swbuf_r+0x88>
 180746c:	300b883a 	mov	r5,r6
 1807470:	8809883a 	mov	r4,r17
 1807474:	d9800015 	stw	r6,0(sp)
 1807478:	18074f80 	call	18074f8 <__swsetup_r>
 180747c:	d9800017 	ldw	r6,0(sp)
 1807480:	1000061e 	bne	r2,zero,180749c <__swbuf_r+0xf0>
 1807484:	30c00417 	ldw	r3,16(r6)
 1807488:	003fd806 	br	18073ec <__swbuf_r+0x40>
 180748c:	d9800015 	stw	r6,0(sp)
 1807490:	1807bb40 	call	1807bb4 <__sinit>
 1807494:	d9800017 	ldw	r6,0(sp)
 1807498:	003fcd06 	br	18073d0 <__swbuf_r+0x24>
 180749c:	3080030b 	ldhu	r2,12(r6)
 18074a0:	00c00244 	movi	r3,9
 18074a4:	043fffc4 	movi	r16,-1
 18074a8:	10801014 	ori	r2,r2,64
 18074ac:	3080030d 	sth	r2,12(r6)
 18074b0:	88c00015 	stw	r3,0(r17)
 18074b4:	003fdf06 	br	1807434 <__swbuf_r+0x88>
 18074b8:	300b883a 	mov	r5,r6
 18074bc:	8809883a 	mov	r4,r17
 18074c0:	d9800015 	stw	r6,0(sp)
 18074c4:	180791c0 	call	180791c <_fflush_r>
 18074c8:	d9800017 	ldw	r6,0(sp)
 18074cc:	103fe51e 	bne	r2,zero,1807464 <__swbuf_r+0xb8>
 18074d0:	31000017 	ldw	r4,0(r6)
 18074d4:	01400044 	movi	r5,1
 18074d8:	003fc906 	br	1807400 <__swbuf_r+0x54>

018074dc <__swbuf>:
 18074dc:	01806074 	movhi	r6,385
 18074e0:	31abd604 	addi	r6,r6,-20648
 18074e4:	2007883a 	mov	r3,r4
 18074e8:	31000017 	ldw	r4,0(r6)
 18074ec:	280d883a 	mov	r6,r5
 18074f0:	180b883a 	mov	r5,r3
 18074f4:	18073ac1 	jmpi	18073ac <__swbuf_r>

018074f8 <__swsetup_r>:
 18074f8:	00806074 	movhi	r2,385
 18074fc:	10abd604 	addi	r2,r2,-20648
 1807500:	10c00017 	ldw	r3,0(r2)
 1807504:	defffd04 	addi	sp,sp,-12
 1807508:	dc400115 	stw	r17,4(sp)
 180750c:	dc000015 	stw	r16,0(sp)
 1807510:	dfc00215 	stw	ra,8(sp)
 1807514:	2023883a 	mov	r17,r4
 1807518:	2821883a 	mov	r16,r5
 180751c:	18000226 	beq	r3,zero,1807528 <__swsetup_r+0x30>
 1807520:	18800e17 	ldw	r2,56(r3)
 1807524:	10001f26 	beq	r2,zero,18075a4 <__swsetup_r+0xac>
 1807528:	8100030b 	ldhu	r4,12(r16)
 180752c:	2080020c 	andi	r2,r4,8
 1807530:	10002826 	beq	r2,zero,18075d4 <__swsetup_r+0xdc>
 1807534:	81400417 	ldw	r5,16(r16)
 1807538:	28001d26 	beq	r5,zero,18075b0 <__swsetup_r+0xb8>
 180753c:	2080004c 	andi	r2,r4,1
 1807540:	1005003a 	cmpeq	r2,r2,zero
 1807544:	10000b26 	beq	r2,zero,1807574 <__swsetup_r+0x7c>
 1807548:	2080008c 	andi	r2,r4,2
 180754c:	10001226 	beq	r2,zero,1807598 <__swsetup_r+0xa0>
 1807550:	0005883a 	mov	r2,zero
 1807554:	80800215 	stw	r2,8(r16)
 1807558:	28000b26 	beq	r5,zero,1807588 <__swsetup_r+0x90>
 180755c:	0005883a 	mov	r2,zero
 1807560:	dfc00217 	ldw	ra,8(sp)
 1807564:	dc400117 	ldw	r17,4(sp)
 1807568:	dc000017 	ldw	r16,0(sp)
 180756c:	dec00304 	addi	sp,sp,12
 1807570:	f800283a 	ret
 1807574:	80800517 	ldw	r2,20(r16)
 1807578:	80000215 	stw	zero,8(r16)
 180757c:	0085c83a 	sub	r2,zero,r2
 1807580:	80800615 	stw	r2,24(r16)
 1807584:	283ff51e 	bne	r5,zero,180755c <__swsetup_r+0x64>
 1807588:	2080200c 	andi	r2,r4,128
 180758c:	103ff326 	beq	r2,zero,180755c <__swsetup_r+0x64>
 1807590:	00bfffc4 	movi	r2,-1
 1807594:	003ff206 	br	1807560 <__swsetup_r+0x68>
 1807598:	80800517 	ldw	r2,20(r16)
 180759c:	80800215 	stw	r2,8(r16)
 18075a0:	003fed06 	br	1807558 <__swsetup_r+0x60>
 18075a4:	1809883a 	mov	r4,r3
 18075a8:	1807bb40 	call	1807bb4 <__sinit>
 18075ac:	003fde06 	br	1807528 <__swsetup_r+0x30>
 18075b0:	20c0a00c 	andi	r3,r4,640
 18075b4:	00808004 	movi	r2,512
 18075b8:	18bfe026 	beq	r3,r2,180753c <__swsetup_r+0x44>
 18075bc:	8809883a 	mov	r4,r17
 18075c0:	800b883a 	mov	r5,r16
 18075c4:	18084000 	call	1808400 <__smakebuf_r>
 18075c8:	8100030b 	ldhu	r4,12(r16)
 18075cc:	81400417 	ldw	r5,16(r16)
 18075d0:	003fda06 	br	180753c <__swsetup_r+0x44>
 18075d4:	2080040c 	andi	r2,r4,16
 18075d8:	103fed26 	beq	r2,zero,1807590 <__swsetup_r+0x98>
 18075dc:	2080010c 	andi	r2,r4,4
 18075e0:	10001226 	beq	r2,zero,180762c <__swsetup_r+0x134>
 18075e4:	81400c17 	ldw	r5,48(r16)
 18075e8:	28000526 	beq	r5,zero,1807600 <__swsetup_r+0x108>
 18075ec:	80801004 	addi	r2,r16,64
 18075f0:	28800226 	beq	r5,r2,18075fc <__swsetup_r+0x104>
 18075f4:	8809883a 	mov	r4,r17
 18075f8:	1807f6c0 	call	1807f6c <_free_r>
 18075fc:	80000c15 	stw	zero,48(r16)
 1807600:	8080030b 	ldhu	r2,12(r16)
 1807604:	81400417 	ldw	r5,16(r16)
 1807608:	80000115 	stw	zero,4(r16)
 180760c:	10bff6cc 	andi	r2,r2,65499
 1807610:	8080030d 	sth	r2,12(r16)
 1807614:	81400015 	stw	r5,0(r16)
 1807618:	8080030b 	ldhu	r2,12(r16)
 180761c:	10800214 	ori	r2,r2,8
 1807620:	113fffcc 	andi	r4,r2,65535
 1807624:	8080030d 	sth	r2,12(r16)
 1807628:	003fc306 	br	1807538 <__swsetup_r+0x40>
 180762c:	81400417 	ldw	r5,16(r16)
 1807630:	003ff906 	br	1807618 <__swsetup_r+0x120>

01807634 <__register_exitproc>:
 1807634:	defffa04 	addi	sp,sp,-24
 1807638:	00806074 	movhi	r2,385
 180763c:	10abd704 	addi	r2,r2,-20644
 1807640:	dc000015 	stw	r16,0(sp)
 1807644:	14000017 	ldw	r16,0(r2)
 1807648:	dd000415 	stw	r20,16(sp)
 180764c:	2829883a 	mov	r20,r5
 1807650:	81405217 	ldw	r5,328(r16)
 1807654:	dcc00315 	stw	r19,12(sp)
 1807658:	dc800215 	stw	r18,8(sp)
 180765c:	dc400115 	stw	r17,4(sp)
 1807660:	dfc00515 	stw	ra,20(sp)
 1807664:	2023883a 	mov	r17,r4
 1807668:	3027883a 	mov	r19,r6
 180766c:	3825883a 	mov	r18,r7
 1807670:	28002526 	beq	r5,zero,1807708 <__register_exitproc+0xd4>
 1807674:	29000117 	ldw	r4,4(r5)
 1807678:	008007c4 	movi	r2,31
 180767c:	11002716 	blt	r2,r4,180771c <__register_exitproc+0xe8>
 1807680:	8800101e 	bne	r17,zero,18076c4 <__register_exitproc+0x90>
 1807684:	2105883a 	add	r2,r4,r4
 1807688:	1085883a 	add	r2,r2,r2
 180768c:	20c00044 	addi	r3,r4,1
 1807690:	1145883a 	add	r2,r2,r5
 1807694:	0009883a 	mov	r4,zero
 1807698:	15000215 	stw	r20,8(r2)
 180769c:	28c00115 	stw	r3,4(r5)
 18076a0:	2005883a 	mov	r2,r4
 18076a4:	dfc00517 	ldw	ra,20(sp)
 18076a8:	dd000417 	ldw	r20,16(sp)
 18076ac:	dcc00317 	ldw	r19,12(sp)
 18076b0:	dc800217 	ldw	r18,8(sp)
 18076b4:	dc400117 	ldw	r17,4(sp)
 18076b8:	dc000017 	ldw	r16,0(sp)
 18076bc:	dec00604 	addi	sp,sp,24
 18076c0:	f800283a 	ret
 18076c4:	29802204 	addi	r6,r5,136
 18076c8:	00800044 	movi	r2,1
 18076cc:	110e983a 	sll	r7,r2,r4
 18076d0:	30c04017 	ldw	r3,256(r6)
 18076d4:	2105883a 	add	r2,r4,r4
 18076d8:	1085883a 	add	r2,r2,r2
 18076dc:	1185883a 	add	r2,r2,r6
 18076e0:	19c6b03a 	or	r3,r3,r7
 18076e4:	14802015 	stw	r18,128(r2)
 18076e8:	14c00015 	stw	r19,0(r2)
 18076ec:	00800084 	movi	r2,2
 18076f0:	30c04015 	stw	r3,256(r6)
 18076f4:	88bfe31e 	bne	r17,r2,1807684 <__register_exitproc+0x50>
 18076f8:	30804117 	ldw	r2,260(r6)
 18076fc:	11c4b03a 	or	r2,r2,r7
 1807700:	30804115 	stw	r2,260(r6)
 1807704:	003fdf06 	br	1807684 <__register_exitproc+0x50>
 1807708:	00806074 	movhi	r2,385
 180770c:	10b38904 	addi	r2,r2,-12764
 1807710:	100b883a 	mov	r5,r2
 1807714:	80805215 	stw	r2,328(r16)
 1807718:	003fd606 	br	1807674 <__register_exitproc+0x40>
 180771c:	00800034 	movhi	r2,0
 1807720:	10800004 	addi	r2,r2,0
 1807724:	1000021e 	bne	r2,zero,1807730 <__register_exitproc+0xfc>
 1807728:	013fffc4 	movi	r4,-1
 180772c:	003fdc06 	br	18076a0 <__register_exitproc+0x6c>
 1807730:	01006404 	movi	r4,400
 1807734:	103ee83a 	callr	r2
 1807738:	1007883a 	mov	r3,r2
 180773c:	103ffa26 	beq	r2,zero,1807728 <__register_exitproc+0xf4>
 1807740:	80805217 	ldw	r2,328(r16)
 1807744:	180b883a 	mov	r5,r3
 1807748:	18000115 	stw	zero,4(r3)
 180774c:	18800015 	stw	r2,0(r3)
 1807750:	80c05215 	stw	r3,328(r16)
 1807754:	18006215 	stw	zero,392(r3)
 1807758:	18006315 	stw	zero,396(r3)
 180775c:	0009883a 	mov	r4,zero
 1807760:	883fc826 	beq	r17,zero,1807684 <__register_exitproc+0x50>
 1807764:	003fd706 	br	18076c4 <__register_exitproc+0x90>

01807768 <register_fini>:
 1807768:	f800283a 	ret

0180776c <__call_exitprocs>:
 180776c:	00806074 	movhi	r2,385
 1807770:	10abd704 	addi	r2,r2,-20644
 1807774:	10800017 	ldw	r2,0(r2)
 1807778:	defff304 	addi	sp,sp,-52
 180777c:	df000b15 	stw	fp,44(sp)
 1807780:	d8800115 	stw	r2,4(sp)
 1807784:	00800034 	movhi	r2,0
 1807788:	10800004 	addi	r2,r2,0
 180778c:	1005003a 	cmpeq	r2,r2,zero
 1807790:	d8800215 	stw	r2,8(sp)
 1807794:	d8800117 	ldw	r2,4(sp)
 1807798:	dd400815 	stw	r21,32(sp)
 180779c:	dd000715 	stw	r20,28(sp)
 18077a0:	10805204 	addi	r2,r2,328
 18077a4:	dfc00c15 	stw	ra,48(sp)
 18077a8:	ddc00a15 	stw	r23,40(sp)
 18077ac:	dd800915 	stw	r22,36(sp)
 18077b0:	dcc00615 	stw	r19,24(sp)
 18077b4:	dc800515 	stw	r18,20(sp)
 18077b8:	dc400415 	stw	r17,16(sp)
 18077bc:	dc000315 	stw	r16,12(sp)
 18077c0:	282b883a 	mov	r21,r5
 18077c4:	2039883a 	mov	fp,r4
 18077c8:	d8800015 	stw	r2,0(sp)
 18077cc:	2829003a 	cmpeq	r20,r5,zero
 18077d0:	d8800117 	ldw	r2,4(sp)
 18077d4:	14405217 	ldw	r17,328(r2)
 18077d8:	88001026 	beq	r17,zero,180781c <__call_exitprocs+0xb0>
 18077dc:	ddc00017 	ldw	r23,0(sp)
 18077e0:	88800117 	ldw	r2,4(r17)
 18077e4:	8c802204 	addi	r18,r17,136
 18077e8:	143fffc4 	addi	r16,r2,-1
 18077ec:	80000916 	blt	r16,zero,1807814 <__call_exitprocs+0xa8>
 18077f0:	05bfffc4 	movi	r22,-1
 18077f4:	a000151e 	bne	r20,zero,180784c <__call_exitprocs+0xe0>
 18077f8:	8409883a 	add	r4,r16,r16
 18077fc:	2105883a 	add	r2,r4,r4
 1807800:	1485883a 	add	r2,r2,r18
 1807804:	10c02017 	ldw	r3,128(r2)
 1807808:	a8c01126 	beq	r21,r3,1807850 <__call_exitprocs+0xe4>
 180780c:	843fffc4 	addi	r16,r16,-1
 1807810:	85bff81e 	bne	r16,r22,18077f4 <__call_exitprocs+0x88>
 1807814:	d8800217 	ldw	r2,8(sp)
 1807818:	10003126 	beq	r2,zero,18078e0 <__call_exitprocs+0x174>
 180781c:	dfc00c17 	ldw	ra,48(sp)
 1807820:	df000b17 	ldw	fp,44(sp)
 1807824:	ddc00a17 	ldw	r23,40(sp)
 1807828:	dd800917 	ldw	r22,36(sp)
 180782c:	dd400817 	ldw	r21,32(sp)
 1807830:	dd000717 	ldw	r20,28(sp)
 1807834:	dcc00617 	ldw	r19,24(sp)
 1807838:	dc800517 	ldw	r18,20(sp)
 180783c:	dc400417 	ldw	r17,16(sp)
 1807840:	dc000317 	ldw	r16,12(sp)
 1807844:	dec00d04 	addi	sp,sp,52
 1807848:	f800283a 	ret
 180784c:	8409883a 	add	r4,r16,r16
 1807850:	88c00117 	ldw	r3,4(r17)
 1807854:	2105883a 	add	r2,r4,r4
 1807858:	1445883a 	add	r2,r2,r17
 180785c:	18ffffc4 	addi	r3,r3,-1
 1807860:	11800217 	ldw	r6,8(r2)
 1807864:	1c001526 	beq	r3,r16,18078bc <__call_exitprocs+0x150>
 1807868:	10000215 	stw	zero,8(r2)
 180786c:	303fe726 	beq	r6,zero,180780c <__call_exitprocs+0xa0>
 1807870:	00c00044 	movi	r3,1
 1807874:	1c06983a 	sll	r3,r3,r16
 1807878:	90804017 	ldw	r2,256(r18)
 180787c:	8cc00117 	ldw	r19,4(r17)
 1807880:	1884703a 	and	r2,r3,r2
 1807884:	10001426 	beq	r2,zero,18078d8 <__call_exitprocs+0x16c>
 1807888:	90804117 	ldw	r2,260(r18)
 180788c:	1884703a 	and	r2,r3,r2
 1807890:	10000c1e 	bne	r2,zero,18078c4 <__call_exitprocs+0x158>
 1807894:	2105883a 	add	r2,r4,r4
 1807898:	1485883a 	add	r2,r2,r18
 180789c:	11400017 	ldw	r5,0(r2)
 18078a0:	e009883a 	mov	r4,fp
 18078a4:	303ee83a 	callr	r6
 18078a8:	88800117 	ldw	r2,4(r17)
 18078ac:	98bfc81e 	bne	r19,r2,18077d0 <__call_exitprocs+0x64>
 18078b0:	b8800017 	ldw	r2,0(r23)
 18078b4:	147fd526 	beq	r2,r17,180780c <__call_exitprocs+0xa0>
 18078b8:	003fc506 	br	18077d0 <__call_exitprocs+0x64>
 18078bc:	8c000115 	stw	r16,4(r17)
 18078c0:	003fea06 	br	180786c <__call_exitprocs+0x100>
 18078c4:	2105883a 	add	r2,r4,r4
 18078c8:	1485883a 	add	r2,r2,r18
 18078cc:	11000017 	ldw	r4,0(r2)
 18078d0:	303ee83a 	callr	r6
 18078d4:	003ff406 	br	18078a8 <__call_exitprocs+0x13c>
 18078d8:	303ee83a 	callr	r6
 18078dc:	003ff206 	br	18078a8 <__call_exitprocs+0x13c>
 18078e0:	88800117 	ldw	r2,4(r17)
 18078e4:	1000081e 	bne	r2,zero,1807908 <__call_exitprocs+0x19c>
 18078e8:	89000017 	ldw	r4,0(r17)
 18078ec:	20000726 	beq	r4,zero,180790c <__call_exitprocs+0x1a0>
 18078f0:	b9000015 	stw	r4,0(r23)
 18078f4:	8809883a 	mov	r4,r17
 18078f8:	00000000 	call	0 <__reset-0x1800000>
 18078fc:	bc400017 	ldw	r17,0(r23)
 1807900:	883fb71e 	bne	r17,zero,18077e0 <__call_exitprocs+0x74>
 1807904:	003fc506 	br	180781c <__call_exitprocs+0xb0>
 1807908:	89000017 	ldw	r4,0(r17)
 180790c:	882f883a 	mov	r23,r17
 1807910:	2023883a 	mov	r17,r4
 1807914:	883fb21e 	bne	r17,zero,18077e0 <__call_exitprocs+0x74>
 1807918:	003fc006 	br	180781c <__call_exitprocs+0xb0>

0180791c <_fflush_r>:
 180791c:	defffb04 	addi	sp,sp,-20
 1807920:	dcc00315 	stw	r19,12(sp)
 1807924:	dc800215 	stw	r18,8(sp)
 1807928:	dfc00415 	stw	ra,16(sp)
 180792c:	dc400115 	stw	r17,4(sp)
 1807930:	dc000015 	stw	r16,0(sp)
 1807934:	2027883a 	mov	r19,r4
 1807938:	2825883a 	mov	r18,r5
 180793c:	20000226 	beq	r4,zero,1807948 <_fflush_r+0x2c>
 1807940:	20800e17 	ldw	r2,56(r4)
 1807944:	10005626 	beq	r2,zero,1807aa0 <_fflush_r+0x184>
 1807948:	9100030b 	ldhu	r4,12(r18)
 180794c:	20ffffcc 	andi	r3,r4,65535
 1807950:	18e0001c 	xori	r3,r3,32768
 1807954:	18e00004 	addi	r3,r3,-32768
 1807958:	1880020c 	andi	r2,r3,8
 180795c:	1000261e 	bne	r2,zero,18079f8 <_fflush_r+0xdc>
 1807960:	90c00117 	ldw	r3,4(r18)
 1807964:	20820014 	ori	r2,r4,2048
 1807968:	9080030d 	sth	r2,12(r18)
 180796c:	1009883a 	mov	r4,r2
 1807970:	00c0400e 	bge	zero,r3,1807a74 <_fflush_r+0x158>
 1807974:	92000a17 	ldw	r8,40(r18)
 1807978:	40004026 	beq	r8,zero,1807a7c <_fflush_r+0x160>
 180797c:	2084000c 	andi	r2,r4,4096
 1807980:	10005326 	beq	r2,zero,1807ad0 <_fflush_r+0x1b4>
 1807984:	94001417 	ldw	r16,80(r18)
 1807988:	9080030b 	ldhu	r2,12(r18)
 180798c:	1080010c 	andi	r2,r2,4
 1807990:	1000481e 	bne	r2,zero,1807ab4 <_fflush_r+0x198>
 1807994:	91400717 	ldw	r5,28(r18)
 1807998:	9809883a 	mov	r4,r19
 180799c:	800d883a 	mov	r6,r16
 18079a0:	000f883a 	mov	r7,zero
 18079a4:	403ee83a 	callr	r8
 18079a8:	8080261e 	bne	r16,r2,1807a44 <_fflush_r+0x128>
 18079ac:	9080030b 	ldhu	r2,12(r18)
 18079b0:	91000417 	ldw	r4,16(r18)
 18079b4:	90000115 	stw	zero,4(r18)
 18079b8:	10bdffcc 	andi	r2,r2,63487
 18079bc:	10ffffcc 	andi	r3,r2,65535
 18079c0:	18c4000c 	andi	r3,r3,4096
 18079c4:	9080030d 	sth	r2,12(r18)
 18079c8:	91000015 	stw	r4,0(r18)
 18079cc:	18002b26 	beq	r3,zero,1807a7c <_fflush_r+0x160>
 18079d0:	0007883a 	mov	r3,zero
 18079d4:	1805883a 	mov	r2,r3
 18079d8:	94001415 	stw	r16,80(r18)
 18079dc:	dfc00417 	ldw	ra,16(sp)
 18079e0:	dcc00317 	ldw	r19,12(sp)
 18079e4:	dc800217 	ldw	r18,8(sp)
 18079e8:	dc400117 	ldw	r17,4(sp)
 18079ec:	dc000017 	ldw	r16,0(sp)
 18079f0:	dec00504 	addi	sp,sp,20
 18079f4:	f800283a 	ret
 18079f8:	94400417 	ldw	r17,16(r18)
 18079fc:	88001f26 	beq	r17,zero,1807a7c <_fflush_r+0x160>
 1807a00:	90800017 	ldw	r2,0(r18)
 1807a04:	18c000cc 	andi	r3,r3,3
 1807a08:	94400015 	stw	r17,0(r18)
 1807a0c:	1461c83a 	sub	r16,r2,r17
 1807a10:	18002526 	beq	r3,zero,1807aa8 <_fflush_r+0x18c>
 1807a14:	0005883a 	mov	r2,zero
 1807a18:	90800215 	stw	r2,8(r18)
 1807a1c:	0400170e 	bge	zero,r16,1807a7c <_fflush_r+0x160>
 1807a20:	90c00917 	ldw	r3,36(r18)
 1807a24:	91400717 	ldw	r5,28(r18)
 1807a28:	880d883a 	mov	r6,r17
 1807a2c:	800f883a 	mov	r7,r16
 1807a30:	9809883a 	mov	r4,r19
 1807a34:	183ee83a 	callr	r3
 1807a38:	88a3883a 	add	r17,r17,r2
 1807a3c:	80a1c83a 	sub	r16,r16,r2
 1807a40:	00bff616 	blt	zero,r2,1807a1c <_fflush_r+0x100>
 1807a44:	9080030b 	ldhu	r2,12(r18)
 1807a48:	00ffffc4 	movi	r3,-1
 1807a4c:	10801014 	ori	r2,r2,64
 1807a50:	9080030d 	sth	r2,12(r18)
 1807a54:	1805883a 	mov	r2,r3
 1807a58:	dfc00417 	ldw	ra,16(sp)
 1807a5c:	dcc00317 	ldw	r19,12(sp)
 1807a60:	dc800217 	ldw	r18,8(sp)
 1807a64:	dc400117 	ldw	r17,4(sp)
 1807a68:	dc000017 	ldw	r16,0(sp)
 1807a6c:	dec00504 	addi	sp,sp,20
 1807a70:	f800283a 	ret
 1807a74:	90800f17 	ldw	r2,60(r18)
 1807a78:	00bfbe16 	blt	zero,r2,1807974 <_fflush_r+0x58>
 1807a7c:	0007883a 	mov	r3,zero
 1807a80:	1805883a 	mov	r2,r3
 1807a84:	dfc00417 	ldw	ra,16(sp)
 1807a88:	dcc00317 	ldw	r19,12(sp)
 1807a8c:	dc800217 	ldw	r18,8(sp)
 1807a90:	dc400117 	ldw	r17,4(sp)
 1807a94:	dc000017 	ldw	r16,0(sp)
 1807a98:	dec00504 	addi	sp,sp,20
 1807a9c:	f800283a 	ret
 1807aa0:	1807bb40 	call	1807bb4 <__sinit>
 1807aa4:	003fa806 	br	1807948 <_fflush_r+0x2c>
 1807aa8:	90800517 	ldw	r2,20(r18)
 1807aac:	90800215 	stw	r2,8(r18)
 1807ab0:	003fda06 	br	1807a1c <_fflush_r+0x100>
 1807ab4:	90800117 	ldw	r2,4(r18)
 1807ab8:	90c00c17 	ldw	r3,48(r18)
 1807abc:	80a1c83a 	sub	r16,r16,r2
 1807ac0:	183fb426 	beq	r3,zero,1807994 <_fflush_r+0x78>
 1807ac4:	90800f17 	ldw	r2,60(r18)
 1807ac8:	80a1c83a 	sub	r16,r16,r2
 1807acc:	003fb106 	br	1807994 <_fflush_r+0x78>
 1807ad0:	91400717 	ldw	r5,28(r18)
 1807ad4:	9809883a 	mov	r4,r19
 1807ad8:	000d883a 	mov	r6,zero
 1807adc:	01c00044 	movi	r7,1
 1807ae0:	403ee83a 	callr	r8
 1807ae4:	1021883a 	mov	r16,r2
 1807ae8:	00bfffc4 	movi	r2,-1
 1807aec:	80800226 	beq	r16,r2,1807af8 <_fflush_r+0x1dc>
 1807af0:	92000a17 	ldw	r8,40(r18)
 1807af4:	003fa406 	br	1807988 <_fflush_r+0x6c>
 1807af8:	98c00017 	ldw	r3,0(r19)
 1807afc:	00800744 	movi	r2,29
 1807b00:	18bfde26 	beq	r3,r2,1807a7c <_fflush_r+0x160>
 1807b04:	9080030b 	ldhu	r2,12(r18)
 1807b08:	8007883a 	mov	r3,r16
 1807b0c:	10801014 	ori	r2,r2,64
 1807b10:	9080030d 	sth	r2,12(r18)
 1807b14:	003fcf06 	br	1807a54 <_fflush_r+0x138>

01807b18 <fflush>:
 1807b18:	01406034 	movhi	r5,384
 1807b1c:	295e4704 	addi	r5,r5,31004
 1807b20:	2007883a 	mov	r3,r4
 1807b24:	20000526 	beq	r4,zero,1807b3c <fflush+0x24>
 1807b28:	00806074 	movhi	r2,385
 1807b2c:	10abd604 	addi	r2,r2,-20648
 1807b30:	11000017 	ldw	r4,0(r2)
 1807b34:	180b883a 	mov	r5,r3
 1807b38:	180791c1 	jmpi	180791c <_fflush_r>
 1807b3c:	00806074 	movhi	r2,385
 1807b40:	10abd704 	addi	r2,r2,-20644
 1807b44:	11000017 	ldw	r4,0(r2)
 1807b48:	18082801 	jmpi	1808280 <_fwalk_reent>

01807b4c <std>:
 1807b4c:	00806074 	movhi	r2,385
 1807b50:	10a18b04 	addi	r2,r2,-31188
 1807b54:	20800b15 	stw	r2,44(r4)
 1807b58:	00806074 	movhi	r2,385
 1807b5c:	10a1c604 	addi	r2,r2,-30952
 1807b60:	20800815 	stw	r2,32(r4)
 1807b64:	00c06074 	movhi	r3,385
 1807b68:	18e1a704 	addi	r3,r3,-31076
 1807b6c:	00806074 	movhi	r2,385
 1807b70:	10a18d04 	addi	r2,r2,-31180
 1807b74:	2140030d 	sth	r5,12(r4)
 1807b78:	2180038d 	sth	r6,14(r4)
 1807b7c:	20c00915 	stw	r3,36(r4)
 1807b80:	20800a15 	stw	r2,40(r4)
 1807b84:	20000015 	stw	zero,0(r4)
 1807b88:	20000115 	stw	zero,4(r4)
 1807b8c:	20000215 	stw	zero,8(r4)
 1807b90:	20000415 	stw	zero,16(r4)
 1807b94:	20000515 	stw	zero,20(r4)
 1807b98:	20000615 	stw	zero,24(r4)
 1807b9c:	21000715 	stw	r4,28(r4)
 1807ba0:	f800283a 	ret

01807ba4 <__sfp_lock_acquire>:
 1807ba4:	f800283a 	ret

01807ba8 <__sfp_lock_release>:
 1807ba8:	f800283a 	ret

01807bac <__sinit_lock_acquire>:
 1807bac:	f800283a 	ret

01807bb0 <__sinit_lock_release>:
 1807bb0:	f800283a 	ret

01807bb4 <__sinit>:
 1807bb4:	20800e17 	ldw	r2,56(r4)
 1807bb8:	defffd04 	addi	sp,sp,-12
 1807bbc:	dc400115 	stw	r17,4(sp)
 1807bc0:	dc000015 	stw	r16,0(sp)
 1807bc4:	dfc00215 	stw	ra,8(sp)
 1807bc8:	04400044 	movi	r17,1
 1807bcc:	01400104 	movi	r5,4
 1807bd0:	000d883a 	mov	r6,zero
 1807bd4:	2021883a 	mov	r16,r4
 1807bd8:	2200bb04 	addi	r8,r4,748
 1807bdc:	200f883a 	mov	r7,r4
 1807be0:	10000526 	beq	r2,zero,1807bf8 <__sinit+0x44>
 1807be4:	dfc00217 	ldw	ra,8(sp)
 1807be8:	dc400117 	ldw	r17,4(sp)
 1807bec:	dc000017 	ldw	r16,0(sp)
 1807bf0:	dec00304 	addi	sp,sp,12
 1807bf4:	f800283a 	ret
 1807bf8:	21000117 	ldw	r4,4(r4)
 1807bfc:	00806034 	movhi	r2,384
 1807c00:	109f2604 	addi	r2,r2,31896
 1807c04:	00c000c4 	movi	r3,3
 1807c08:	80800f15 	stw	r2,60(r16)
 1807c0c:	80c0b915 	stw	r3,740(r16)
 1807c10:	8200ba15 	stw	r8,744(r16)
 1807c14:	84400e15 	stw	r17,56(r16)
 1807c18:	8000b815 	stw	zero,736(r16)
 1807c1c:	1807b4c0 	call	1807b4c <std>
 1807c20:	81000217 	ldw	r4,8(r16)
 1807c24:	880d883a 	mov	r6,r17
 1807c28:	800f883a 	mov	r7,r16
 1807c2c:	01400284 	movi	r5,10
 1807c30:	1807b4c0 	call	1807b4c <std>
 1807c34:	81000317 	ldw	r4,12(r16)
 1807c38:	800f883a 	mov	r7,r16
 1807c3c:	01400484 	movi	r5,18
 1807c40:	01800084 	movi	r6,2
 1807c44:	dfc00217 	ldw	ra,8(sp)
 1807c48:	dc400117 	ldw	r17,4(sp)
 1807c4c:	dc000017 	ldw	r16,0(sp)
 1807c50:	dec00304 	addi	sp,sp,12
 1807c54:	1807b4c1 	jmpi	1807b4c <std>

01807c58 <__fp_lock>:
 1807c58:	0005883a 	mov	r2,zero
 1807c5c:	f800283a 	ret

01807c60 <__fp_unlock>:
 1807c60:	0005883a 	mov	r2,zero
 1807c64:	f800283a 	ret

01807c68 <__fp_unlock_all>:
 1807c68:	00806074 	movhi	r2,385
 1807c6c:	10abd604 	addi	r2,r2,-20648
 1807c70:	11000017 	ldw	r4,0(r2)
 1807c74:	01406034 	movhi	r5,384
 1807c78:	295f1804 	addi	r5,r5,31840
 1807c7c:	18083481 	jmpi	1808348 <_fwalk>

01807c80 <__fp_lock_all>:
 1807c80:	00806074 	movhi	r2,385
 1807c84:	10abd604 	addi	r2,r2,-20648
 1807c88:	11000017 	ldw	r4,0(r2)
 1807c8c:	01406034 	movhi	r5,384
 1807c90:	295f1604 	addi	r5,r5,31832
 1807c94:	18083481 	jmpi	1808348 <_fwalk>

01807c98 <_cleanup_r>:
 1807c98:	01406074 	movhi	r5,385
 1807c9c:	29625c04 	addi	r5,r5,-30352
 1807ca0:	18083481 	jmpi	1808348 <_fwalk>

01807ca4 <_cleanup>:
 1807ca4:	00806074 	movhi	r2,385
 1807ca8:	10abd704 	addi	r2,r2,-20644
 1807cac:	11000017 	ldw	r4,0(r2)
 1807cb0:	1807c981 	jmpi	1807c98 <_cleanup_r>

01807cb4 <__sfmoreglue>:
 1807cb4:	defffc04 	addi	sp,sp,-16
 1807cb8:	dc000015 	stw	r16,0(sp)
 1807cbc:	2821883a 	mov	r16,r5
 1807cc0:	dc400115 	stw	r17,4(sp)
 1807cc4:	01401704 	movi	r5,92
 1807cc8:	2023883a 	mov	r17,r4
 1807ccc:	8009883a 	mov	r4,r16
 1807cd0:	dfc00315 	stw	ra,12(sp)
 1807cd4:	dcc00215 	stw	r19,8(sp)
 1807cd8:	1808b580 	call	1808b58 <__mulsi3>
 1807cdc:	11400304 	addi	r5,r2,12
 1807ce0:	8809883a 	mov	r4,r17
 1807ce4:	1027883a 	mov	r19,r2
 1807ce8:	18060d00 	call	18060d0 <_malloc_r>
 1807cec:	10c00304 	addi	r3,r2,12
 1807cf0:	1023883a 	mov	r17,r2
 1807cf4:	1809883a 	mov	r4,r3
 1807cf8:	980d883a 	mov	r6,r19
 1807cfc:	000b883a 	mov	r5,zero
 1807d00:	10000b26 	beq	r2,zero,1807d30 <__sfmoreglue+0x7c>
 1807d04:	14000115 	stw	r16,4(r2)
 1807d08:	10c00215 	stw	r3,8(r2)
 1807d0c:	10000015 	stw	zero,0(r2)
 1807d10:	18085940 	call	1808594 <memset>
 1807d14:	8805883a 	mov	r2,r17
 1807d18:	dfc00317 	ldw	ra,12(sp)
 1807d1c:	dcc00217 	ldw	r19,8(sp)
 1807d20:	dc400117 	ldw	r17,4(sp)
 1807d24:	dc000017 	ldw	r16,0(sp)
 1807d28:	dec00404 	addi	sp,sp,16
 1807d2c:	f800283a 	ret
 1807d30:	0023883a 	mov	r17,zero
 1807d34:	8805883a 	mov	r2,r17
 1807d38:	dfc00317 	ldw	ra,12(sp)
 1807d3c:	dcc00217 	ldw	r19,8(sp)
 1807d40:	dc400117 	ldw	r17,4(sp)
 1807d44:	dc000017 	ldw	r16,0(sp)
 1807d48:	dec00404 	addi	sp,sp,16
 1807d4c:	f800283a 	ret

01807d50 <__sfp>:
 1807d50:	defffd04 	addi	sp,sp,-12
 1807d54:	00806074 	movhi	r2,385
 1807d58:	10abd704 	addi	r2,r2,-20644
 1807d5c:	dc000015 	stw	r16,0(sp)
 1807d60:	14000017 	ldw	r16,0(r2)
 1807d64:	dc400115 	stw	r17,4(sp)
 1807d68:	dfc00215 	stw	ra,8(sp)
 1807d6c:	80800e17 	ldw	r2,56(r16)
 1807d70:	2023883a 	mov	r17,r4
 1807d74:	10002626 	beq	r2,zero,1807e10 <__sfp+0xc0>
 1807d78:	8400b804 	addi	r16,r16,736
 1807d7c:	80800117 	ldw	r2,4(r16)
 1807d80:	81000217 	ldw	r4,8(r16)
 1807d84:	10ffffc4 	addi	r3,r2,-1
 1807d88:	18000916 	blt	r3,zero,1807db0 <__sfp+0x60>
 1807d8c:	2080030f 	ldh	r2,12(r4)
 1807d90:	10000b26 	beq	r2,zero,1807dc0 <__sfp+0x70>
 1807d94:	017fffc4 	movi	r5,-1
 1807d98:	00000206 	br	1807da4 <__sfp+0x54>
 1807d9c:	2080030f 	ldh	r2,12(r4)
 1807da0:	10000726 	beq	r2,zero,1807dc0 <__sfp+0x70>
 1807da4:	18ffffc4 	addi	r3,r3,-1
 1807da8:	21001704 	addi	r4,r4,92
 1807dac:	197ffb1e 	bne	r3,r5,1807d9c <__sfp+0x4c>
 1807db0:	80800017 	ldw	r2,0(r16)
 1807db4:	10001926 	beq	r2,zero,1807e1c <__sfp+0xcc>
 1807db8:	1021883a 	mov	r16,r2
 1807dbc:	003fef06 	br	1807d7c <__sfp+0x2c>
 1807dc0:	00bfffc4 	movi	r2,-1
 1807dc4:	00c00044 	movi	r3,1
 1807dc8:	2080038d 	sth	r2,14(r4)
 1807dcc:	20c0030d 	sth	r3,12(r4)
 1807dd0:	20000015 	stw	zero,0(r4)
 1807dd4:	20000215 	stw	zero,8(r4)
 1807dd8:	20000115 	stw	zero,4(r4)
 1807ddc:	20000415 	stw	zero,16(r4)
 1807de0:	20000515 	stw	zero,20(r4)
 1807de4:	20000615 	stw	zero,24(r4)
 1807de8:	20000c15 	stw	zero,48(r4)
 1807dec:	20000d15 	stw	zero,52(r4)
 1807df0:	20001115 	stw	zero,68(r4)
 1807df4:	20001215 	stw	zero,72(r4)
 1807df8:	2005883a 	mov	r2,r4
 1807dfc:	dfc00217 	ldw	ra,8(sp)
 1807e00:	dc400117 	ldw	r17,4(sp)
 1807e04:	dc000017 	ldw	r16,0(sp)
 1807e08:	dec00304 	addi	sp,sp,12
 1807e0c:	f800283a 	ret
 1807e10:	8009883a 	mov	r4,r16
 1807e14:	1807bb40 	call	1807bb4 <__sinit>
 1807e18:	003fd706 	br	1807d78 <__sfp+0x28>
 1807e1c:	8809883a 	mov	r4,r17
 1807e20:	01400104 	movi	r5,4
 1807e24:	1807cb40 	call	1807cb4 <__sfmoreglue>
 1807e28:	80800015 	stw	r2,0(r16)
 1807e2c:	103fe21e 	bne	r2,zero,1807db8 <__sfp+0x68>
 1807e30:	00800304 	movi	r2,12
 1807e34:	0009883a 	mov	r4,zero
 1807e38:	88800015 	stw	r2,0(r17)
 1807e3c:	003fee06 	br	1807df8 <__sfp+0xa8>

01807e40 <_malloc_trim_r>:
 1807e40:	defffb04 	addi	sp,sp,-20
 1807e44:	dcc00315 	stw	r19,12(sp)
 1807e48:	04c06074 	movhi	r19,385
 1807e4c:	9ceacb04 	addi	r19,r19,-21716
 1807e50:	dc800215 	stw	r18,8(sp)
 1807e54:	dc400115 	stw	r17,4(sp)
 1807e58:	dc000015 	stw	r16,0(sp)
 1807e5c:	2823883a 	mov	r17,r5
 1807e60:	2025883a 	mov	r18,r4
 1807e64:	dfc00415 	stw	ra,16(sp)
 1807e68:	1808fa40 	call	1808fa4 <__malloc_lock>
 1807e6c:	98800217 	ldw	r2,8(r19)
 1807e70:	9009883a 	mov	r4,r18
 1807e74:	000b883a 	mov	r5,zero
 1807e78:	10c00117 	ldw	r3,4(r2)
 1807e7c:	00bfff04 	movi	r2,-4
 1807e80:	18a0703a 	and	r16,r3,r2
 1807e84:	8463c83a 	sub	r17,r16,r17
 1807e88:	8c43fbc4 	addi	r17,r17,4079
 1807e8c:	8822d33a 	srli	r17,r17,12
 1807e90:	0083ffc4 	movi	r2,4095
 1807e94:	8c7fffc4 	addi	r17,r17,-1
 1807e98:	8822933a 	slli	r17,r17,12
 1807e9c:	1440060e 	bge	r2,r17,1807eb8 <_malloc_trim_r+0x78>
 1807ea0:	18072c80 	call	18072c8 <_sbrk_r>
 1807ea4:	98c00217 	ldw	r3,8(r19)
 1807ea8:	9009883a 	mov	r4,r18
 1807eac:	044bc83a 	sub	r5,zero,r17
 1807eb0:	80c7883a 	add	r3,r16,r3
 1807eb4:	10c00926 	beq	r2,r3,1807edc <_malloc_trim_r+0x9c>
 1807eb8:	1808fc40 	call	1808fc4 <__malloc_unlock>
 1807ebc:	0005883a 	mov	r2,zero
 1807ec0:	dfc00417 	ldw	ra,16(sp)
 1807ec4:	dcc00317 	ldw	r19,12(sp)
 1807ec8:	dc800217 	ldw	r18,8(sp)
 1807ecc:	dc400117 	ldw	r17,4(sp)
 1807ed0:	dc000017 	ldw	r16,0(sp)
 1807ed4:	dec00504 	addi	sp,sp,20
 1807ed8:	f800283a 	ret
 1807edc:	9009883a 	mov	r4,r18
 1807ee0:	18072c80 	call	18072c8 <_sbrk_r>
 1807ee4:	844dc83a 	sub	r6,r16,r17
 1807ee8:	00ffffc4 	movi	r3,-1
 1807eec:	9009883a 	mov	r4,r18
 1807ef0:	000b883a 	mov	r5,zero
 1807ef4:	01c06074 	movhi	r7,385
 1807ef8:	39f2c304 	addi	r7,r7,-13556
 1807efc:	31800054 	ori	r6,r6,1
 1807f00:	10c00926 	beq	r2,r3,1807f28 <_malloc_trim_r+0xe8>
 1807f04:	38800017 	ldw	r2,0(r7)
 1807f08:	98c00217 	ldw	r3,8(r19)
 1807f0c:	9009883a 	mov	r4,r18
 1807f10:	1445c83a 	sub	r2,r2,r17
 1807f14:	38800015 	stw	r2,0(r7)
 1807f18:	19800115 	stw	r6,4(r3)
 1807f1c:	1808fc40 	call	1808fc4 <__malloc_unlock>
 1807f20:	00800044 	movi	r2,1
 1807f24:	003fe606 	br	1807ec0 <_malloc_trim_r+0x80>
 1807f28:	18072c80 	call	18072c8 <_sbrk_r>
 1807f2c:	99800217 	ldw	r6,8(r19)
 1807f30:	100f883a 	mov	r7,r2
 1807f34:	9009883a 	mov	r4,r18
 1807f38:	1187c83a 	sub	r3,r2,r6
 1807f3c:	008003c4 	movi	r2,15
 1807f40:	19400054 	ori	r5,r3,1
 1807f44:	10ffdc0e 	bge	r2,r3,1807eb8 <_malloc_trim_r+0x78>
 1807f48:	00806074 	movhi	r2,385
 1807f4c:	10abd904 	addi	r2,r2,-20636
 1807f50:	10c00017 	ldw	r3,0(r2)
 1807f54:	00806074 	movhi	r2,385
 1807f58:	10b2c304 	addi	r2,r2,-13556
 1807f5c:	31400115 	stw	r5,4(r6)
 1807f60:	38c7c83a 	sub	r3,r7,r3
 1807f64:	10c00015 	stw	r3,0(r2)
 1807f68:	003fd306 	br	1807eb8 <_malloc_trim_r+0x78>

01807f6c <_free_r>:
 1807f6c:	defffd04 	addi	sp,sp,-12
 1807f70:	dc400115 	stw	r17,4(sp)
 1807f74:	dc000015 	stw	r16,0(sp)
 1807f78:	dfc00215 	stw	ra,8(sp)
 1807f7c:	2821883a 	mov	r16,r5
 1807f80:	2023883a 	mov	r17,r4
 1807f84:	28005a26 	beq	r5,zero,18080f0 <_free_r+0x184>
 1807f88:	1808fa40 	call	1808fa4 <__malloc_lock>
 1807f8c:	823ffe04 	addi	r8,r16,-8
 1807f90:	41400117 	ldw	r5,4(r8)
 1807f94:	00bfff84 	movi	r2,-2
 1807f98:	02806074 	movhi	r10,385
 1807f9c:	52aacb04 	addi	r10,r10,-21716
 1807fa0:	288e703a 	and	r7,r5,r2
 1807fa4:	41cd883a 	add	r6,r8,r7
 1807fa8:	30c00117 	ldw	r3,4(r6)
 1807fac:	51000217 	ldw	r4,8(r10)
 1807fb0:	00bfff04 	movi	r2,-4
 1807fb4:	1892703a 	and	r9,r3,r2
 1807fb8:	5017883a 	mov	r11,r10
 1807fbc:	31006726 	beq	r6,r4,180815c <_free_r+0x1f0>
 1807fc0:	2880004c 	andi	r2,r5,1
 1807fc4:	1005003a 	cmpeq	r2,r2,zero
 1807fc8:	32400115 	stw	r9,4(r6)
 1807fcc:	10001a1e 	bne	r2,zero,1808038 <_free_r+0xcc>
 1807fd0:	000b883a 	mov	r5,zero
 1807fd4:	3247883a 	add	r3,r6,r9
 1807fd8:	18800117 	ldw	r2,4(r3)
 1807fdc:	1080004c 	andi	r2,r2,1
 1807fe0:	1000231e 	bne	r2,zero,1808070 <_free_r+0x104>
 1807fe4:	280ac03a 	cmpne	r5,r5,zero
 1807fe8:	3a4f883a 	add	r7,r7,r9
 1807fec:	2800451e 	bne	r5,zero,1808104 <_free_r+0x198>
 1807ff0:	31000217 	ldw	r4,8(r6)
 1807ff4:	00806074 	movhi	r2,385
 1807ff8:	10aacd04 	addi	r2,r2,-21708
 1807ffc:	20807b26 	beq	r4,r2,18081ec <_free_r+0x280>
 1808000:	30800317 	ldw	r2,12(r6)
 1808004:	3a07883a 	add	r3,r7,r8
 1808008:	19c00015 	stw	r7,0(r3)
 180800c:	11000215 	stw	r4,8(r2)
 1808010:	20800315 	stw	r2,12(r4)
 1808014:	38800054 	ori	r2,r7,1
 1808018:	40800115 	stw	r2,4(r8)
 180801c:	28001a26 	beq	r5,zero,1808088 <_free_r+0x11c>
 1808020:	8809883a 	mov	r4,r17
 1808024:	dfc00217 	ldw	ra,8(sp)
 1808028:	dc400117 	ldw	r17,4(sp)
 180802c:	dc000017 	ldw	r16,0(sp)
 1808030:	dec00304 	addi	sp,sp,12
 1808034:	1808fc41 	jmpi	1808fc4 <__malloc_unlock>
 1808038:	80bffe17 	ldw	r2,-8(r16)
 180803c:	50c00204 	addi	r3,r10,8
 1808040:	4091c83a 	sub	r8,r8,r2
 1808044:	41000217 	ldw	r4,8(r8)
 1808048:	388f883a 	add	r7,r7,r2
 180804c:	20c06126 	beq	r4,r3,18081d4 <_free_r+0x268>
 1808050:	40800317 	ldw	r2,12(r8)
 1808054:	3247883a 	add	r3,r6,r9
 1808058:	000b883a 	mov	r5,zero
 180805c:	11000215 	stw	r4,8(r2)
 1808060:	20800315 	stw	r2,12(r4)
 1808064:	18800117 	ldw	r2,4(r3)
 1808068:	1080004c 	andi	r2,r2,1
 180806c:	103fdd26 	beq	r2,zero,1807fe4 <_free_r+0x78>
 1808070:	38800054 	ori	r2,r7,1
 1808074:	3a07883a 	add	r3,r7,r8
 1808078:	280ac03a 	cmpne	r5,r5,zero
 180807c:	40800115 	stw	r2,4(r8)
 1808080:	19c00015 	stw	r7,0(r3)
 1808084:	283fe61e 	bne	r5,zero,1808020 <_free_r+0xb4>
 1808088:	00807fc4 	movi	r2,511
 180808c:	11c01f2e 	bgeu	r2,r7,180810c <_free_r+0x1a0>
 1808090:	3806d27a 	srli	r3,r7,9
 1808094:	1800481e 	bne	r3,zero,18081b8 <_free_r+0x24c>
 1808098:	3804d0fa 	srli	r2,r7,3
 180809c:	100690fa 	slli	r3,r2,3
 18080a0:	1acd883a 	add	r6,r3,r11
 18080a4:	31400217 	ldw	r5,8(r6)
 18080a8:	31405926 	beq	r6,r5,1808210 <_free_r+0x2a4>
 18080ac:	28800117 	ldw	r2,4(r5)
 18080b0:	00ffff04 	movi	r3,-4
 18080b4:	10c4703a 	and	r2,r2,r3
 18080b8:	3880022e 	bgeu	r7,r2,18080c4 <_free_r+0x158>
 18080bc:	29400217 	ldw	r5,8(r5)
 18080c0:	317ffa1e 	bne	r6,r5,18080ac <_free_r+0x140>
 18080c4:	29800317 	ldw	r6,12(r5)
 18080c8:	41800315 	stw	r6,12(r8)
 18080cc:	41400215 	stw	r5,8(r8)
 18080d0:	8809883a 	mov	r4,r17
 18080d4:	2a000315 	stw	r8,12(r5)
 18080d8:	32000215 	stw	r8,8(r6)
 18080dc:	dfc00217 	ldw	ra,8(sp)
 18080e0:	dc400117 	ldw	r17,4(sp)
 18080e4:	dc000017 	ldw	r16,0(sp)
 18080e8:	dec00304 	addi	sp,sp,12
 18080ec:	1808fc41 	jmpi	1808fc4 <__malloc_unlock>
 18080f0:	dfc00217 	ldw	ra,8(sp)
 18080f4:	dc400117 	ldw	r17,4(sp)
 18080f8:	dc000017 	ldw	r16,0(sp)
 18080fc:	dec00304 	addi	sp,sp,12
 1808100:	f800283a 	ret
 1808104:	31000217 	ldw	r4,8(r6)
 1808108:	003fbd06 	br	1808000 <_free_r+0x94>
 180810c:	3806d0fa 	srli	r3,r7,3
 1808110:	00800044 	movi	r2,1
 1808114:	51400117 	ldw	r5,4(r10)
 1808118:	180890fa 	slli	r4,r3,3
 180811c:	1807d0ba 	srai	r3,r3,2
 1808120:	22c9883a 	add	r4,r4,r11
 1808124:	21800217 	ldw	r6,8(r4)
 1808128:	10c4983a 	sll	r2,r2,r3
 180812c:	41000315 	stw	r4,12(r8)
 1808130:	41800215 	stw	r6,8(r8)
 1808134:	288ab03a 	or	r5,r5,r2
 1808138:	22000215 	stw	r8,8(r4)
 180813c:	8809883a 	mov	r4,r17
 1808140:	51400115 	stw	r5,4(r10)
 1808144:	32000315 	stw	r8,12(r6)
 1808148:	dfc00217 	ldw	ra,8(sp)
 180814c:	dc400117 	ldw	r17,4(sp)
 1808150:	dc000017 	ldw	r16,0(sp)
 1808154:	dec00304 	addi	sp,sp,12
 1808158:	1808fc41 	jmpi	1808fc4 <__malloc_unlock>
 180815c:	2880004c 	andi	r2,r5,1
 1808160:	3a4d883a 	add	r6,r7,r9
 1808164:	1000071e 	bne	r2,zero,1808184 <_free_r+0x218>
 1808168:	80bffe17 	ldw	r2,-8(r16)
 180816c:	4091c83a 	sub	r8,r8,r2
 1808170:	41000317 	ldw	r4,12(r8)
 1808174:	40c00217 	ldw	r3,8(r8)
 1808178:	308d883a 	add	r6,r6,r2
 180817c:	20c00215 	stw	r3,8(r4)
 1808180:	19000315 	stw	r4,12(r3)
 1808184:	00806074 	movhi	r2,385
 1808188:	10abd804 	addi	r2,r2,-20640
 180818c:	11000017 	ldw	r4,0(r2)
 1808190:	30c00054 	ori	r3,r6,1
 1808194:	52000215 	stw	r8,8(r10)
 1808198:	40c00115 	stw	r3,4(r8)
 180819c:	313fa036 	bltu	r6,r4,1808020 <_free_r+0xb4>
 18081a0:	00806074 	movhi	r2,385
 18081a4:	10b2a704 	addi	r2,r2,-13668
 18081a8:	11400017 	ldw	r5,0(r2)
 18081ac:	8809883a 	mov	r4,r17
 18081b0:	1807e400 	call	1807e40 <_malloc_trim_r>
 18081b4:	003f9a06 	br	1808020 <_free_r+0xb4>
 18081b8:	00800104 	movi	r2,4
 18081bc:	10c0072e 	bgeu	r2,r3,18081dc <_free_r+0x270>
 18081c0:	00800504 	movi	r2,20
 18081c4:	10c01936 	bltu	r2,r3,180822c <_free_r+0x2c0>
 18081c8:	188016c4 	addi	r2,r3,91
 18081cc:	100690fa 	slli	r3,r2,3
 18081d0:	003fb306 	br	18080a0 <_free_r+0x134>
 18081d4:	01400044 	movi	r5,1
 18081d8:	003f7e06 	br	1807fd4 <_free_r+0x68>
 18081dc:	3804d1ba 	srli	r2,r7,6
 18081e0:	10800e04 	addi	r2,r2,56
 18081e4:	100690fa 	slli	r3,r2,3
 18081e8:	003fad06 	br	18080a0 <_free_r+0x134>
 18081ec:	22000315 	stw	r8,12(r4)
 18081f0:	22000215 	stw	r8,8(r4)
 18081f4:	3a05883a 	add	r2,r7,r8
 18081f8:	38c00054 	ori	r3,r7,1
 18081fc:	11c00015 	stw	r7,0(r2)
 1808200:	41000215 	stw	r4,8(r8)
 1808204:	40c00115 	stw	r3,4(r8)
 1808208:	41000315 	stw	r4,12(r8)
 180820c:	003f8406 	br	1808020 <_free_r+0xb4>
 1808210:	1005d0ba 	srai	r2,r2,2
 1808214:	00c00044 	movi	r3,1
 1808218:	51000117 	ldw	r4,4(r10)
 180821c:	1886983a 	sll	r3,r3,r2
 1808220:	20c8b03a 	or	r4,r4,r3
 1808224:	51000115 	stw	r4,4(r10)
 1808228:	003fa706 	br	18080c8 <_free_r+0x15c>
 180822c:	00801504 	movi	r2,84
 1808230:	10c00436 	bltu	r2,r3,1808244 <_free_r+0x2d8>
 1808234:	3804d33a 	srli	r2,r7,12
 1808238:	10801b84 	addi	r2,r2,110
 180823c:	100690fa 	slli	r3,r2,3
 1808240:	003f9706 	br	18080a0 <_free_r+0x134>
 1808244:	00805504 	movi	r2,340
 1808248:	10c00436 	bltu	r2,r3,180825c <_free_r+0x2f0>
 180824c:	3804d3fa 	srli	r2,r7,15
 1808250:	10801dc4 	addi	r2,r2,119
 1808254:	100690fa 	slli	r3,r2,3
 1808258:	003f9106 	br	18080a0 <_free_r+0x134>
 180825c:	00815504 	movi	r2,1364
 1808260:	10c0032e 	bgeu	r2,r3,1808270 <_free_r+0x304>
 1808264:	00801f84 	movi	r2,126
 1808268:	00c0fc04 	movi	r3,1008
 180826c:	003f8c06 	br	18080a0 <_free_r+0x134>
 1808270:	3804d4ba 	srli	r2,r7,18
 1808274:	10801f04 	addi	r2,r2,124
 1808278:	100690fa 	slli	r3,r2,3
 180827c:	003f8806 	br	18080a0 <_free_r+0x134>

01808280 <_fwalk_reent>:
 1808280:	defff704 	addi	sp,sp,-36
 1808284:	dcc00315 	stw	r19,12(sp)
 1808288:	24c0b804 	addi	r19,r4,736
 180828c:	dd800615 	stw	r22,24(sp)
 1808290:	dd400515 	stw	r21,20(sp)
 1808294:	dfc00815 	stw	ra,32(sp)
 1808298:	ddc00715 	stw	r23,28(sp)
 180829c:	dd000415 	stw	r20,16(sp)
 18082a0:	dc800215 	stw	r18,8(sp)
 18082a4:	dc400115 	stw	r17,4(sp)
 18082a8:	dc000015 	stw	r16,0(sp)
 18082ac:	202b883a 	mov	r21,r4
 18082b0:	282d883a 	mov	r22,r5
 18082b4:	1807ba40 	call	1807ba4 <__sfp_lock_acquire>
 18082b8:	98002126 	beq	r19,zero,1808340 <_fwalk_reent+0xc0>
 18082bc:	002f883a 	mov	r23,zero
 18082c0:	9c800117 	ldw	r18,4(r19)
 18082c4:	9c000217 	ldw	r16,8(r19)
 18082c8:	90bfffc4 	addi	r2,r18,-1
 18082cc:	10000d16 	blt	r2,zero,1808304 <_fwalk_reent+0x84>
 18082d0:	0023883a 	mov	r17,zero
 18082d4:	053fffc4 	movi	r20,-1
 18082d8:	8080030f 	ldh	r2,12(r16)
 18082dc:	8c400044 	addi	r17,r17,1
 18082e0:	10000626 	beq	r2,zero,18082fc <_fwalk_reent+0x7c>
 18082e4:	8080038f 	ldh	r2,14(r16)
 18082e8:	800b883a 	mov	r5,r16
 18082ec:	a809883a 	mov	r4,r21
 18082f0:	15000226 	beq	r2,r20,18082fc <_fwalk_reent+0x7c>
 18082f4:	b03ee83a 	callr	r22
 18082f8:	b8aeb03a 	or	r23,r23,r2
 18082fc:	84001704 	addi	r16,r16,92
 1808300:	947ff51e 	bne	r18,r17,18082d8 <_fwalk_reent+0x58>
 1808304:	9cc00017 	ldw	r19,0(r19)
 1808308:	983fed1e 	bne	r19,zero,18082c0 <_fwalk_reent+0x40>
 180830c:	1807ba80 	call	1807ba8 <__sfp_lock_release>
 1808310:	b805883a 	mov	r2,r23
 1808314:	dfc00817 	ldw	ra,32(sp)
 1808318:	ddc00717 	ldw	r23,28(sp)
 180831c:	dd800617 	ldw	r22,24(sp)
 1808320:	dd400517 	ldw	r21,20(sp)
 1808324:	dd000417 	ldw	r20,16(sp)
 1808328:	dcc00317 	ldw	r19,12(sp)
 180832c:	dc800217 	ldw	r18,8(sp)
 1808330:	dc400117 	ldw	r17,4(sp)
 1808334:	dc000017 	ldw	r16,0(sp)
 1808338:	dec00904 	addi	sp,sp,36
 180833c:	f800283a 	ret
 1808340:	002f883a 	mov	r23,zero
 1808344:	003ff106 	br	180830c <_fwalk_reent+0x8c>

01808348 <_fwalk>:
 1808348:	defff804 	addi	sp,sp,-32
 180834c:	dcc00315 	stw	r19,12(sp)
 1808350:	24c0b804 	addi	r19,r4,736
 1808354:	dd400515 	stw	r21,20(sp)
 1808358:	dfc00715 	stw	ra,28(sp)
 180835c:	dd800615 	stw	r22,24(sp)
 1808360:	dd000415 	stw	r20,16(sp)
 1808364:	dc800215 	stw	r18,8(sp)
 1808368:	dc400115 	stw	r17,4(sp)
 180836c:	dc000015 	stw	r16,0(sp)
 1808370:	282b883a 	mov	r21,r5
 1808374:	1807ba40 	call	1807ba4 <__sfp_lock_acquire>
 1808378:	98001f26 	beq	r19,zero,18083f8 <_fwalk+0xb0>
 180837c:	002d883a 	mov	r22,zero
 1808380:	9c800117 	ldw	r18,4(r19)
 1808384:	9c000217 	ldw	r16,8(r19)
 1808388:	90bfffc4 	addi	r2,r18,-1
 180838c:	10000c16 	blt	r2,zero,18083c0 <_fwalk+0x78>
 1808390:	0023883a 	mov	r17,zero
 1808394:	053fffc4 	movi	r20,-1
 1808398:	8080030f 	ldh	r2,12(r16)
 180839c:	8c400044 	addi	r17,r17,1
 18083a0:	10000526 	beq	r2,zero,18083b8 <_fwalk+0x70>
 18083a4:	8080038f 	ldh	r2,14(r16)
 18083a8:	8009883a 	mov	r4,r16
 18083ac:	15000226 	beq	r2,r20,18083b8 <_fwalk+0x70>
 18083b0:	a83ee83a 	callr	r21
 18083b4:	b0acb03a 	or	r22,r22,r2
 18083b8:	84001704 	addi	r16,r16,92
 18083bc:	947ff61e 	bne	r18,r17,1808398 <_fwalk+0x50>
 18083c0:	9cc00017 	ldw	r19,0(r19)
 18083c4:	983fee1e 	bne	r19,zero,1808380 <_fwalk+0x38>
 18083c8:	1807ba80 	call	1807ba8 <__sfp_lock_release>
 18083cc:	b005883a 	mov	r2,r22
 18083d0:	dfc00717 	ldw	ra,28(sp)
 18083d4:	dd800617 	ldw	r22,24(sp)
 18083d8:	dd400517 	ldw	r21,20(sp)
 18083dc:	dd000417 	ldw	r20,16(sp)
 18083e0:	dcc00317 	ldw	r19,12(sp)
 18083e4:	dc800217 	ldw	r18,8(sp)
 18083e8:	dc400117 	ldw	r17,4(sp)
 18083ec:	dc000017 	ldw	r16,0(sp)
 18083f0:	dec00804 	addi	sp,sp,32
 18083f4:	f800283a 	ret
 18083f8:	002d883a 	mov	r22,zero
 18083fc:	003ff206 	br	18083c8 <_fwalk+0x80>

01808400 <__smakebuf_r>:
 1808400:	2880030b 	ldhu	r2,12(r5)
 1808404:	deffed04 	addi	sp,sp,-76
 1808408:	dc401015 	stw	r17,64(sp)
 180840c:	1080008c 	andi	r2,r2,2
 1808410:	dc000f15 	stw	r16,60(sp)
 1808414:	dfc01215 	stw	ra,72(sp)
 1808418:	dc801115 	stw	r18,68(sp)
 180841c:	2821883a 	mov	r16,r5
 1808420:	2023883a 	mov	r17,r4
 1808424:	10000b26 	beq	r2,zero,1808454 <__smakebuf_r+0x54>
 1808428:	28c010c4 	addi	r3,r5,67
 180842c:	00800044 	movi	r2,1
 1808430:	28800515 	stw	r2,20(r5)
 1808434:	28c00415 	stw	r3,16(r5)
 1808438:	28c00015 	stw	r3,0(r5)
 180843c:	dfc01217 	ldw	ra,72(sp)
 1808440:	dc801117 	ldw	r18,68(sp)
 1808444:	dc401017 	ldw	r17,64(sp)
 1808448:	dc000f17 	ldw	r16,60(sp)
 180844c:	dec01304 	addi	sp,sp,76
 1808450:	f800283a 	ret
 1808454:	2940038f 	ldh	r5,14(r5)
 1808458:	28002116 	blt	r5,zero,18084e0 <__smakebuf_r+0xe0>
 180845c:	d80d883a 	mov	r6,sp
 1808460:	18089840 	call	1808984 <_fstat_r>
 1808464:	10001e16 	blt	r2,zero,18084e0 <__smakebuf_r+0xe0>
 1808468:	d8800117 	ldw	r2,4(sp)
 180846c:	00e00014 	movui	r3,32768
 1808470:	113c000c 	andi	r4,r2,61440
 1808474:	20c03126 	beq	r4,r3,180853c <__smakebuf_r+0x13c>
 1808478:	8080030b 	ldhu	r2,12(r16)
 180847c:	00c80004 	movi	r3,8192
 1808480:	10820014 	ori	r2,r2,2048
 1808484:	8080030d 	sth	r2,12(r16)
 1808488:	20c01e26 	beq	r4,r3,1808504 <__smakebuf_r+0x104>
 180848c:	04810004 	movi	r18,1024
 1808490:	8809883a 	mov	r4,r17
 1808494:	900b883a 	mov	r5,r18
 1808498:	18060d00 	call	18060d0 <_malloc_r>
 180849c:	1009883a 	mov	r4,r2
 18084a0:	10003126 	beq	r2,zero,1808568 <__smakebuf_r+0x168>
 18084a4:	80c0030b 	ldhu	r3,12(r16)
 18084a8:	00806034 	movhi	r2,384
 18084ac:	109f2604 	addi	r2,r2,31896
 18084b0:	88800f15 	stw	r2,60(r17)
 18084b4:	18c02014 	ori	r3,r3,128
 18084b8:	84800515 	stw	r18,20(r16)
 18084bc:	80c0030d 	sth	r3,12(r16)
 18084c0:	81000415 	stw	r4,16(r16)
 18084c4:	81000015 	stw	r4,0(r16)
 18084c8:	dfc01217 	ldw	ra,72(sp)
 18084cc:	dc801117 	ldw	r18,68(sp)
 18084d0:	dc401017 	ldw	r17,64(sp)
 18084d4:	dc000f17 	ldw	r16,60(sp)
 18084d8:	dec01304 	addi	sp,sp,76
 18084dc:	f800283a 	ret
 18084e0:	80c0030b 	ldhu	r3,12(r16)
 18084e4:	1880200c 	andi	r2,r3,128
 18084e8:	10000426 	beq	r2,zero,18084fc <__smakebuf_r+0xfc>
 18084ec:	04801004 	movi	r18,64
 18084f0:	18820014 	ori	r2,r3,2048
 18084f4:	8080030d 	sth	r2,12(r16)
 18084f8:	003fe506 	br	1808490 <__smakebuf_r+0x90>
 18084fc:	04810004 	movi	r18,1024
 1808500:	003ffb06 	br	18084f0 <__smakebuf_r+0xf0>
 1808504:	8140038f 	ldh	r5,14(r16)
 1808508:	8809883a 	mov	r4,r17
 180850c:	18089f80 	call	18089f8 <_isatty_r>
 1808510:	103fde26 	beq	r2,zero,180848c <__smakebuf_r+0x8c>
 1808514:	8080030b 	ldhu	r2,12(r16)
 1808518:	80c010c4 	addi	r3,r16,67
 180851c:	04810004 	movi	r18,1024
 1808520:	10800054 	ori	r2,r2,1
 1808524:	8080030d 	sth	r2,12(r16)
 1808528:	00800044 	movi	r2,1
 180852c:	80c00415 	stw	r3,16(r16)
 1808530:	80800515 	stw	r2,20(r16)
 1808534:	80c00015 	stw	r3,0(r16)
 1808538:	003fd506 	br	1808490 <__smakebuf_r+0x90>
 180853c:	80c00a17 	ldw	r3,40(r16)
 1808540:	00806074 	movhi	r2,385
 1808544:	10a18d04 	addi	r2,r2,-31180
 1808548:	18bfcb1e 	bne	r3,r2,1808478 <__smakebuf_r+0x78>
 180854c:	8080030b 	ldhu	r2,12(r16)
 1808550:	00c10004 	movi	r3,1024
 1808554:	1825883a 	mov	r18,r3
 1808558:	10c4b03a 	or	r2,r2,r3
 180855c:	8080030d 	sth	r2,12(r16)
 1808560:	80c01315 	stw	r3,76(r16)
 1808564:	003fca06 	br	1808490 <__smakebuf_r+0x90>
 1808568:	8100030b 	ldhu	r4,12(r16)
 180856c:	2080800c 	andi	r2,r4,512
 1808570:	103fb21e 	bne	r2,zero,180843c <__smakebuf_r+0x3c>
 1808574:	80c010c4 	addi	r3,r16,67
 1808578:	21000094 	ori	r4,r4,2
 180857c:	00800044 	movi	r2,1
 1808580:	80800515 	stw	r2,20(r16)
 1808584:	8100030d 	sth	r4,12(r16)
 1808588:	80c00415 	stw	r3,16(r16)
 180858c:	80c00015 	stw	r3,0(r16)
 1808590:	003faa06 	br	180843c <__smakebuf_r+0x3c>

01808594 <memset>:
 1808594:	008000c4 	movi	r2,3
 1808598:	29403fcc 	andi	r5,r5,255
 180859c:	2007883a 	mov	r3,r4
 18085a0:	1180022e 	bgeu	r2,r6,18085ac <memset+0x18>
 18085a4:	2084703a 	and	r2,r4,r2
 18085a8:	10000826 	beq	r2,zero,18085cc <memset+0x38>
 18085ac:	30000526 	beq	r6,zero,18085c4 <memset+0x30>
 18085b0:	2805883a 	mov	r2,r5
 18085b4:	30cd883a 	add	r6,r6,r3
 18085b8:	18800005 	stb	r2,0(r3)
 18085bc:	18c00044 	addi	r3,r3,1
 18085c0:	19bffd1e 	bne	r3,r6,18085b8 <memset+0x24>
 18085c4:	2005883a 	mov	r2,r4
 18085c8:	f800283a 	ret
 18085cc:	2804923a 	slli	r2,r5,8
 18085d0:	020003c4 	movi	r8,15
 18085d4:	200f883a 	mov	r7,r4
 18085d8:	2884b03a 	or	r2,r5,r2
 18085dc:	1006943a 	slli	r3,r2,16
 18085e0:	10c6b03a 	or	r3,r2,r3
 18085e4:	41800a2e 	bgeu	r8,r6,1808610 <memset+0x7c>
 18085e8:	4005883a 	mov	r2,r8
 18085ec:	31bffc04 	addi	r6,r6,-16
 18085f0:	38c00015 	stw	r3,0(r7)
 18085f4:	38c00115 	stw	r3,4(r7)
 18085f8:	38c00215 	stw	r3,8(r7)
 18085fc:	38c00315 	stw	r3,12(r7)
 1808600:	39c00404 	addi	r7,r7,16
 1808604:	11bff936 	bltu	r2,r6,18085ec <memset+0x58>
 1808608:	008000c4 	movi	r2,3
 180860c:	1180052e 	bgeu	r2,r6,1808624 <memset+0x90>
 1808610:	31bfff04 	addi	r6,r6,-4
 1808614:	008000c4 	movi	r2,3
 1808618:	38c00015 	stw	r3,0(r7)
 180861c:	39c00104 	addi	r7,r7,4
 1808620:	11bffb36 	bltu	r2,r6,1808610 <memset+0x7c>
 1808624:	3807883a 	mov	r3,r7
 1808628:	003fe006 	br	18085ac <memset+0x18>

0180862c <__sclose>:
 180862c:	2940038f 	ldh	r5,14(r5)
 1808630:	18087f01 	jmpi	18087f0 <_close_r>

01808634 <__sseek>:
 1808634:	defffe04 	addi	sp,sp,-8
 1808638:	dc000015 	stw	r16,0(sp)
 180863c:	2821883a 	mov	r16,r5
 1808640:	2940038f 	ldh	r5,14(r5)
 1808644:	dfc00115 	stw	ra,4(sp)
 1808648:	1808a680 	call	1808a68 <_lseek_r>
 180864c:	1007883a 	mov	r3,r2
 1808650:	00bfffc4 	movi	r2,-1
 1808654:	18800926 	beq	r3,r2,180867c <__sseek+0x48>
 1808658:	8080030b 	ldhu	r2,12(r16)
 180865c:	80c01415 	stw	r3,80(r16)
 1808660:	10840014 	ori	r2,r2,4096
 1808664:	8080030d 	sth	r2,12(r16)
 1808668:	1805883a 	mov	r2,r3
 180866c:	dfc00117 	ldw	ra,4(sp)
 1808670:	dc000017 	ldw	r16,0(sp)
 1808674:	dec00204 	addi	sp,sp,8
 1808678:	f800283a 	ret
 180867c:	8080030b 	ldhu	r2,12(r16)
 1808680:	10bbffcc 	andi	r2,r2,61439
 1808684:	8080030d 	sth	r2,12(r16)
 1808688:	1805883a 	mov	r2,r3
 180868c:	dfc00117 	ldw	ra,4(sp)
 1808690:	dc000017 	ldw	r16,0(sp)
 1808694:	dec00204 	addi	sp,sp,8
 1808698:	f800283a 	ret

0180869c <__swrite>:
 180869c:	2880030b 	ldhu	r2,12(r5)
 18086a0:	defffb04 	addi	sp,sp,-20
 18086a4:	dcc00315 	stw	r19,12(sp)
 18086a8:	1080400c 	andi	r2,r2,256
 18086ac:	dc800215 	stw	r18,8(sp)
 18086b0:	dc400115 	stw	r17,4(sp)
 18086b4:	dc000015 	stw	r16,0(sp)
 18086b8:	3027883a 	mov	r19,r6
 18086bc:	3825883a 	mov	r18,r7
 18086c0:	dfc00415 	stw	ra,16(sp)
 18086c4:	2821883a 	mov	r16,r5
 18086c8:	000d883a 	mov	r6,zero
 18086cc:	01c00084 	movi	r7,2
 18086d0:	2023883a 	mov	r17,r4
 18086d4:	10000226 	beq	r2,zero,18086e0 <__swrite+0x44>
 18086d8:	2940038f 	ldh	r5,14(r5)
 18086dc:	1808a680 	call	1808a68 <_lseek_r>
 18086e0:	8080030b 	ldhu	r2,12(r16)
 18086e4:	8140038f 	ldh	r5,14(r16)
 18086e8:	8809883a 	mov	r4,r17
 18086ec:	10bbffcc 	andi	r2,r2,61439
 18086f0:	980d883a 	mov	r6,r19
 18086f4:	900f883a 	mov	r7,r18
 18086f8:	8080030d 	sth	r2,12(r16)
 18086fc:	dfc00417 	ldw	ra,16(sp)
 1808700:	dcc00317 	ldw	r19,12(sp)
 1808704:	dc800217 	ldw	r18,8(sp)
 1808708:	dc400117 	ldw	r17,4(sp)
 180870c:	dc000017 	ldw	r16,0(sp)
 1808710:	dec00504 	addi	sp,sp,20
 1808714:	18087781 	jmpi	1808778 <_write_r>

01808718 <__sread>:
 1808718:	defffe04 	addi	sp,sp,-8
 180871c:	dc000015 	stw	r16,0(sp)
 1808720:	2821883a 	mov	r16,r5
 1808724:	2940038f 	ldh	r5,14(r5)
 1808728:	dfc00115 	stw	ra,4(sp)
 180872c:	1808ae00 	call	1808ae0 <_read_r>
 1808730:	1007883a 	mov	r3,r2
 1808734:	10000816 	blt	r2,zero,1808758 <__sread+0x40>
 1808738:	80801417 	ldw	r2,80(r16)
 180873c:	10c5883a 	add	r2,r2,r3
 1808740:	80801415 	stw	r2,80(r16)
 1808744:	1805883a 	mov	r2,r3
 1808748:	dfc00117 	ldw	ra,4(sp)
 180874c:	dc000017 	ldw	r16,0(sp)
 1808750:	dec00204 	addi	sp,sp,8
 1808754:	f800283a 	ret
 1808758:	8080030b 	ldhu	r2,12(r16)
 180875c:	10bbffcc 	andi	r2,r2,61439
 1808760:	8080030d 	sth	r2,12(r16)
 1808764:	1805883a 	mov	r2,r3
 1808768:	dfc00117 	ldw	ra,4(sp)
 180876c:	dc000017 	ldw	r16,0(sp)
 1808770:	dec00204 	addi	sp,sp,8
 1808774:	f800283a 	ret

01808778 <_write_r>:
 1808778:	defffd04 	addi	sp,sp,-12
 180877c:	dc000015 	stw	r16,0(sp)
 1808780:	04006074 	movhi	r16,385
 1808784:	8432a604 	addi	r16,r16,-13672
 1808788:	dc400115 	stw	r17,4(sp)
 180878c:	80000015 	stw	zero,0(r16)
 1808790:	2023883a 	mov	r17,r4
 1808794:	2809883a 	mov	r4,r5
 1808798:	300b883a 	mov	r5,r6
 180879c:	380d883a 	mov	r6,r7
 18087a0:	dfc00215 	stw	ra,8(sp)
 18087a4:	18092240 	call	1809224 <write>
 18087a8:	1007883a 	mov	r3,r2
 18087ac:	00bfffc4 	movi	r2,-1
 18087b0:	18800626 	beq	r3,r2,18087cc <_write_r+0x54>
 18087b4:	1805883a 	mov	r2,r3
 18087b8:	dfc00217 	ldw	ra,8(sp)
 18087bc:	dc400117 	ldw	r17,4(sp)
 18087c0:	dc000017 	ldw	r16,0(sp)
 18087c4:	dec00304 	addi	sp,sp,12
 18087c8:	f800283a 	ret
 18087cc:	80800017 	ldw	r2,0(r16)
 18087d0:	103ff826 	beq	r2,zero,18087b4 <_write_r+0x3c>
 18087d4:	88800015 	stw	r2,0(r17)
 18087d8:	1805883a 	mov	r2,r3
 18087dc:	dfc00217 	ldw	ra,8(sp)
 18087e0:	dc400117 	ldw	r17,4(sp)
 18087e4:	dc000017 	ldw	r16,0(sp)
 18087e8:	dec00304 	addi	sp,sp,12
 18087ec:	f800283a 	ret

018087f0 <_close_r>:
 18087f0:	defffd04 	addi	sp,sp,-12
 18087f4:	dc000015 	stw	r16,0(sp)
 18087f8:	04006074 	movhi	r16,385
 18087fc:	8432a604 	addi	r16,r16,-13672
 1808800:	dc400115 	stw	r17,4(sp)
 1808804:	80000015 	stw	zero,0(r16)
 1808808:	2023883a 	mov	r17,r4
 180880c:	2809883a 	mov	r4,r5
 1808810:	dfc00215 	stw	ra,8(sp)
 1808814:	1804ba40 	call	1804ba4 <close>
 1808818:	1007883a 	mov	r3,r2
 180881c:	00bfffc4 	movi	r2,-1
 1808820:	18800626 	beq	r3,r2,180883c <_close_r+0x4c>
 1808824:	1805883a 	mov	r2,r3
 1808828:	dfc00217 	ldw	ra,8(sp)
 180882c:	dc400117 	ldw	r17,4(sp)
 1808830:	dc000017 	ldw	r16,0(sp)
 1808834:	dec00304 	addi	sp,sp,12
 1808838:	f800283a 	ret
 180883c:	80800017 	ldw	r2,0(r16)
 1808840:	103ff826 	beq	r2,zero,1808824 <_close_r+0x34>
 1808844:	88800015 	stw	r2,0(r17)
 1808848:	1805883a 	mov	r2,r3
 180884c:	dfc00217 	ldw	ra,8(sp)
 1808850:	dc400117 	ldw	r17,4(sp)
 1808854:	dc000017 	ldw	r16,0(sp)
 1808858:	dec00304 	addi	sp,sp,12
 180885c:	f800283a 	ret

01808860 <_fclose_r>:
 1808860:	defffc04 	addi	sp,sp,-16
 1808864:	dc400115 	stw	r17,4(sp)
 1808868:	dc000015 	stw	r16,0(sp)
 180886c:	dfc00315 	stw	ra,12(sp)
 1808870:	dc800215 	stw	r18,8(sp)
 1808874:	2821883a 	mov	r16,r5
 1808878:	2023883a 	mov	r17,r4
 180887c:	28002926 	beq	r5,zero,1808924 <_fclose_r+0xc4>
 1808880:	1807ba40 	call	1807ba4 <__sfp_lock_acquire>
 1808884:	88000226 	beq	r17,zero,1808890 <_fclose_r+0x30>
 1808888:	88800e17 	ldw	r2,56(r17)
 180888c:	10002d26 	beq	r2,zero,1808944 <_fclose_r+0xe4>
 1808890:	8080030f 	ldh	r2,12(r16)
 1808894:	10002226 	beq	r2,zero,1808920 <_fclose_r+0xc0>
 1808898:	8809883a 	mov	r4,r17
 180889c:	800b883a 	mov	r5,r16
 18088a0:	180791c0 	call	180791c <_fflush_r>
 18088a4:	1025883a 	mov	r18,r2
 18088a8:	80800b17 	ldw	r2,44(r16)
 18088ac:	10000426 	beq	r2,zero,18088c0 <_fclose_r+0x60>
 18088b0:	81400717 	ldw	r5,28(r16)
 18088b4:	8809883a 	mov	r4,r17
 18088b8:	103ee83a 	callr	r2
 18088bc:	10002a16 	blt	r2,zero,1808968 <_fclose_r+0x108>
 18088c0:	8080030b 	ldhu	r2,12(r16)
 18088c4:	1080200c 	andi	r2,r2,128
 18088c8:	1000231e 	bne	r2,zero,1808958 <_fclose_r+0xf8>
 18088cc:	81400c17 	ldw	r5,48(r16)
 18088d0:	28000526 	beq	r5,zero,18088e8 <_fclose_r+0x88>
 18088d4:	80801004 	addi	r2,r16,64
 18088d8:	28800226 	beq	r5,r2,18088e4 <_fclose_r+0x84>
 18088dc:	8809883a 	mov	r4,r17
 18088e0:	1807f6c0 	call	1807f6c <_free_r>
 18088e4:	80000c15 	stw	zero,48(r16)
 18088e8:	81401117 	ldw	r5,68(r16)
 18088ec:	28000326 	beq	r5,zero,18088fc <_fclose_r+0x9c>
 18088f0:	8809883a 	mov	r4,r17
 18088f4:	1807f6c0 	call	1807f6c <_free_r>
 18088f8:	80001115 	stw	zero,68(r16)
 18088fc:	8000030d 	sth	zero,12(r16)
 1808900:	1807ba80 	call	1807ba8 <__sfp_lock_release>
 1808904:	9005883a 	mov	r2,r18
 1808908:	dfc00317 	ldw	ra,12(sp)
 180890c:	dc800217 	ldw	r18,8(sp)
 1808910:	dc400117 	ldw	r17,4(sp)
 1808914:	dc000017 	ldw	r16,0(sp)
 1808918:	dec00404 	addi	sp,sp,16
 180891c:	f800283a 	ret
 1808920:	1807ba80 	call	1807ba8 <__sfp_lock_release>
 1808924:	0025883a 	mov	r18,zero
 1808928:	9005883a 	mov	r2,r18
 180892c:	dfc00317 	ldw	ra,12(sp)
 1808930:	dc800217 	ldw	r18,8(sp)
 1808934:	dc400117 	ldw	r17,4(sp)
 1808938:	dc000017 	ldw	r16,0(sp)
 180893c:	dec00404 	addi	sp,sp,16
 1808940:	f800283a 	ret
 1808944:	8809883a 	mov	r4,r17
 1808948:	1807bb40 	call	1807bb4 <__sinit>
 180894c:	8080030f 	ldh	r2,12(r16)
 1808950:	103fd11e 	bne	r2,zero,1808898 <_fclose_r+0x38>
 1808954:	003ff206 	br	1808920 <_fclose_r+0xc0>
 1808958:	81400417 	ldw	r5,16(r16)
 180895c:	8809883a 	mov	r4,r17
 1808960:	1807f6c0 	call	1807f6c <_free_r>
 1808964:	003fd906 	br	18088cc <_fclose_r+0x6c>
 1808968:	04bfffc4 	movi	r18,-1
 180896c:	003fd406 	br	18088c0 <_fclose_r+0x60>

01808970 <fclose>:
 1808970:	00806074 	movhi	r2,385
 1808974:	10abd604 	addi	r2,r2,-20648
 1808978:	200b883a 	mov	r5,r4
 180897c:	11000017 	ldw	r4,0(r2)
 1808980:	18088601 	jmpi	1808860 <_fclose_r>

01808984 <_fstat_r>:
 1808984:	defffd04 	addi	sp,sp,-12
 1808988:	dc000015 	stw	r16,0(sp)
 180898c:	04006074 	movhi	r16,385
 1808990:	8432a604 	addi	r16,r16,-13672
 1808994:	dc400115 	stw	r17,4(sp)
 1808998:	80000015 	stw	zero,0(r16)
 180899c:	2023883a 	mov	r17,r4
 18089a0:	2809883a 	mov	r4,r5
 18089a4:	300b883a 	mov	r5,r6
 18089a8:	dfc00215 	stw	ra,8(sp)
 18089ac:	1808bf40 	call	1808bf4 <fstat>
 18089b0:	1007883a 	mov	r3,r2
 18089b4:	00bfffc4 	movi	r2,-1
 18089b8:	18800626 	beq	r3,r2,18089d4 <_fstat_r+0x50>
 18089bc:	1805883a 	mov	r2,r3
 18089c0:	dfc00217 	ldw	ra,8(sp)
 18089c4:	dc400117 	ldw	r17,4(sp)
 18089c8:	dc000017 	ldw	r16,0(sp)
 18089cc:	dec00304 	addi	sp,sp,12
 18089d0:	f800283a 	ret
 18089d4:	80800017 	ldw	r2,0(r16)
 18089d8:	103ff826 	beq	r2,zero,18089bc <_fstat_r+0x38>
 18089dc:	88800015 	stw	r2,0(r17)
 18089e0:	1805883a 	mov	r2,r3
 18089e4:	dfc00217 	ldw	ra,8(sp)
 18089e8:	dc400117 	ldw	r17,4(sp)
 18089ec:	dc000017 	ldw	r16,0(sp)
 18089f0:	dec00304 	addi	sp,sp,12
 18089f4:	f800283a 	ret

018089f8 <_isatty_r>:
 18089f8:	defffd04 	addi	sp,sp,-12
 18089fc:	dc000015 	stw	r16,0(sp)
 1808a00:	04006074 	movhi	r16,385
 1808a04:	8432a604 	addi	r16,r16,-13672
 1808a08:	dc400115 	stw	r17,4(sp)
 1808a0c:	80000015 	stw	zero,0(r16)
 1808a10:	2023883a 	mov	r17,r4
 1808a14:	2809883a 	mov	r4,r5
 1808a18:	dfc00215 	stw	ra,8(sp)
 1808a1c:	1808d2c0 	call	1808d2c <isatty>
 1808a20:	1007883a 	mov	r3,r2
 1808a24:	00bfffc4 	movi	r2,-1
 1808a28:	18800626 	beq	r3,r2,1808a44 <_isatty_r+0x4c>
 1808a2c:	1805883a 	mov	r2,r3
 1808a30:	dfc00217 	ldw	ra,8(sp)
 1808a34:	dc400117 	ldw	r17,4(sp)
 1808a38:	dc000017 	ldw	r16,0(sp)
 1808a3c:	dec00304 	addi	sp,sp,12
 1808a40:	f800283a 	ret
 1808a44:	80800017 	ldw	r2,0(r16)
 1808a48:	103ff826 	beq	r2,zero,1808a2c <_isatty_r+0x34>
 1808a4c:	88800015 	stw	r2,0(r17)
 1808a50:	1805883a 	mov	r2,r3
 1808a54:	dfc00217 	ldw	ra,8(sp)
 1808a58:	dc400117 	ldw	r17,4(sp)
 1808a5c:	dc000017 	ldw	r16,0(sp)
 1808a60:	dec00304 	addi	sp,sp,12
 1808a64:	f800283a 	ret

01808a68 <_lseek_r>:
 1808a68:	defffd04 	addi	sp,sp,-12
 1808a6c:	dc000015 	stw	r16,0(sp)
 1808a70:	04006074 	movhi	r16,385
 1808a74:	8432a604 	addi	r16,r16,-13672
 1808a78:	dc400115 	stw	r17,4(sp)
 1808a7c:	80000015 	stw	zero,0(r16)
 1808a80:	2023883a 	mov	r17,r4
 1808a84:	2809883a 	mov	r4,r5
 1808a88:	300b883a 	mov	r5,r6
 1808a8c:	380d883a 	mov	r6,r7
 1808a90:	dfc00215 	stw	ra,8(sp)
 1808a94:	1808e500 	call	1808e50 <lseek>
 1808a98:	1007883a 	mov	r3,r2
 1808a9c:	00bfffc4 	movi	r2,-1
 1808aa0:	18800626 	beq	r3,r2,1808abc <_lseek_r+0x54>
 1808aa4:	1805883a 	mov	r2,r3
 1808aa8:	dfc00217 	ldw	ra,8(sp)
 1808aac:	dc400117 	ldw	r17,4(sp)
 1808ab0:	dc000017 	ldw	r16,0(sp)
 1808ab4:	dec00304 	addi	sp,sp,12
 1808ab8:	f800283a 	ret
 1808abc:	80800017 	ldw	r2,0(r16)
 1808ac0:	103ff826 	beq	r2,zero,1808aa4 <_lseek_r+0x3c>
 1808ac4:	88800015 	stw	r2,0(r17)
 1808ac8:	1805883a 	mov	r2,r3
 1808acc:	dfc00217 	ldw	ra,8(sp)
 1808ad0:	dc400117 	ldw	r17,4(sp)
 1808ad4:	dc000017 	ldw	r16,0(sp)
 1808ad8:	dec00304 	addi	sp,sp,12
 1808adc:	f800283a 	ret

01808ae0 <_read_r>:
 1808ae0:	defffd04 	addi	sp,sp,-12
 1808ae4:	dc000015 	stw	r16,0(sp)
 1808ae8:	04006074 	movhi	r16,385
 1808aec:	8432a604 	addi	r16,r16,-13672
 1808af0:	dc400115 	stw	r17,4(sp)
 1808af4:	80000015 	stw	zero,0(r16)
 1808af8:	2023883a 	mov	r17,r4
 1808afc:	2809883a 	mov	r4,r5
 1808b00:	300b883a 	mov	r5,r6
 1808b04:	380d883a 	mov	r6,r7
 1808b08:	dfc00215 	stw	ra,8(sp)
 1808b0c:	1808fe40 	call	1808fe4 <read>
 1808b10:	1007883a 	mov	r3,r2
 1808b14:	00bfffc4 	movi	r2,-1
 1808b18:	18800626 	beq	r3,r2,1808b34 <_read_r+0x54>
 1808b1c:	1805883a 	mov	r2,r3
 1808b20:	dfc00217 	ldw	ra,8(sp)
 1808b24:	dc400117 	ldw	r17,4(sp)
 1808b28:	dc000017 	ldw	r16,0(sp)
 1808b2c:	dec00304 	addi	sp,sp,12
 1808b30:	f800283a 	ret
 1808b34:	80800017 	ldw	r2,0(r16)
 1808b38:	103ff826 	beq	r2,zero,1808b1c <_read_r+0x3c>
 1808b3c:	88800015 	stw	r2,0(r17)
 1808b40:	1805883a 	mov	r2,r3
 1808b44:	dfc00217 	ldw	ra,8(sp)
 1808b48:	dc400117 	ldw	r17,4(sp)
 1808b4c:	dc000017 	ldw	r16,0(sp)
 1808b50:	dec00304 	addi	sp,sp,12
 1808b54:	f800283a 	ret

01808b58 <__mulsi3>:
 1808b58:	20000a26 	beq	r4,zero,1808b84 <__mulsi3+0x2c>
 1808b5c:	0007883a 	mov	r3,zero
 1808b60:	2080004c 	andi	r2,r4,1
 1808b64:	1005003a 	cmpeq	r2,r2,zero
 1808b68:	2008d07a 	srli	r4,r4,1
 1808b6c:	1000011e 	bne	r2,zero,1808b74 <__mulsi3+0x1c>
 1808b70:	1947883a 	add	r3,r3,r5
 1808b74:	294b883a 	add	r5,r5,r5
 1808b78:	203ff91e 	bne	r4,zero,1808b60 <__mulsi3+0x8>
 1808b7c:	1805883a 	mov	r2,r3
 1808b80:	f800283a 	ret
 1808b84:	0007883a 	mov	r3,zero
 1808b88:	1805883a 	mov	r2,r3
 1808b8c:	f800283a 	ret

01808b90 <alt_sim_halt>:

/*
 * Routine called on exit.
 */
static ALT_ALWAYS_INLINE void alt_sim_halt(int exit_code)
{
 1808b90:	defffd04 	addi	sp,sp,-12
 1808b94:	df000215 	stw	fp,8(sp)
 1808b98:	df000204 	addi	fp,sp,8
 1808b9c:	e13fff15 	stw	r4,-4(fp)
  int r2 = exit_code;
 1808ba0:	e0bfff17 	ldw	r2,-4(fp)
 1808ba4:	e0bffe15 	stw	r2,-8(fp)
  __asm__ volatile ("\n0:\n\taddi %0,%0, -1\n\tbgt %0,zero,0b" : : "r" (ALT_CPU_FREQ/100) ); /* Delay for >30ms */

  __asm__ volatile ("break 2" : : "D02"(r2), "D03"(r3) ALT_GMON_DATA );

#else /* !DEBUG_STUB */
  if (r2) {
 1808ba8:	e0bffe17 	ldw	r2,-8(fp)
 1808bac:	1005003a 	cmpeq	r2,r2,zero
 1808bb0:	1000021e 	bne	r2,zero,1808bbc <alt_sim_halt+0x2c>
    ALT_SIM_FAIL();
 1808bb4:	002af070 	cmpltui	zero,zero,43969
 1808bb8:	00000106 	br	1808bc0 <alt_sim_halt+0x30>
  } else {
    ALT_SIM_PASS();
 1808bbc:	002af0b0 	cmpltui	zero,zero,43970
  }
#endif /* DEBUG_STUB */
}
 1808bc0:	e037883a 	mov	sp,fp
 1808bc4:	df000017 	ldw	fp,0(sp)
 1808bc8:	dec00104 	addi	sp,sp,4
 1808bcc:	f800283a 	ret

01808bd0 <_exit>:
 *
 * ALT_EXIT is mapped onto the _exit() system call in alt_syscall.h
 */

void ALT_EXIT (int exit_code)
{
 1808bd0:	defffd04 	addi	sp,sp,-12
 1808bd4:	dfc00215 	stw	ra,8(sp)
 1808bd8:	df000115 	stw	fp,4(sp)
 1808bdc:	df000104 	addi	fp,sp,4
 1808be0:	e13fff15 	stw	r4,-4(fp)
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Entering _exit() function.\r\n");
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Exit code from main was %d.\r\n",exit_code);
  /* Stop all other threads */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_OS_STOP().\r\n");
  ALT_OS_STOP();
 1808be4:	18058840 	call	1805884 <port_halt>

  /* Provide notification to the simulator that we've stopped */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_SIM_HALT().\r\n");
  ALT_SIM_HALT(exit_code);
 1808be8:	e13fff17 	ldw	r4,-4(fp)
 1808bec:	1808b900 	call	1808b90 <alt_sim_halt>

  /* spin forever, since there's no where to go back to */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Spinning forever.\r\n");
  while (1);
 1808bf0:	003fff06 	br	1808bf0 <_exit+0x20>

01808bf4 <fstat>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_FSTAT (int file, struct stat *st)
{
 1808bf4:	defff904 	addi	sp,sp,-28
 1808bf8:	dfc00615 	stw	ra,24(sp)
 1808bfc:	df000515 	stw	fp,20(sp)
 1808c00:	df000504 	addi	fp,sp,20
 1808c04:	e13ffc15 	stw	r4,-16(fp)
 1808c08:	e17ffd15 	stw	r5,-12(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 1808c0c:	e0bffc17 	ldw	r2,-16(fp)
 1808c10:	1004803a 	cmplt	r2,r2,zero
 1808c14:	1000091e 	bne	r2,zero,1808c3c <fstat+0x48>
 1808c18:	e13ffc17 	ldw	r4,-16(fp)
 1808c1c:	01400304 	movi	r5,12
 1808c20:	1808b580 	call	1808b58 <__mulsi3>
 1808c24:	1007883a 	mov	r3,r2
 1808c28:	00806074 	movhi	r2,385
 1808c2c:	10a96b04 	addi	r2,r2,-23124
 1808c30:	1887883a 	add	r3,r3,r2
 1808c34:	e0ffff15 	stw	r3,-4(fp)
 1808c38:	00000106 	br	1808c40 <fstat+0x4c>
 1808c3c:	e03fff15 	stw	zero,-4(fp)
 1808c40:	e0bfff17 	ldw	r2,-4(fp)
 1808c44:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
 1808c48:	e0bffb17 	ldw	r2,-20(fp)
 1808c4c:	1005003a 	cmpeq	r2,r2,zero
 1808c50:	1000121e 	bne	r2,zero,1808c9c <fstat+0xa8>
  {
    /* Call the drivers fstat() function to fill out the "st" structure. */

    if (fd->dev->fstat)
 1808c54:	e0bffb17 	ldw	r2,-20(fp)
 1808c58:	10800017 	ldw	r2,0(r2)
 1808c5c:	10800817 	ldw	r2,32(r2)
 1808c60:	1005003a 	cmpeq	r2,r2,zero
 1808c64:	1000081e 	bne	r2,zero,1808c88 <fstat+0x94>
    {
      return fd->dev->fstat(fd, st);
 1808c68:	e0bffb17 	ldw	r2,-20(fp)
 1808c6c:	10800017 	ldw	r2,0(r2)
 1808c70:	10800817 	ldw	r2,32(r2)
 1808c74:	e13ffb17 	ldw	r4,-20(fp)
 1808c78:	e17ffd17 	ldw	r5,-12(fp)
 1808c7c:	103ee83a 	callr	r2
 1808c80:	e0bffe15 	stw	r2,-8(fp)
 1808c84:	00000b06 	br	1808cb4 <fstat+0xc0>
     * device.
     */
 
    else
    {
      st->st_mode = _IFCHR;
 1808c88:	e0fffd17 	ldw	r3,-12(fp)
 1808c8c:	00880004 	movi	r2,8192
 1808c90:	18800115 	stw	r2,4(r3)
      return 0;
 1808c94:	e03ffe15 	stw	zero,-8(fp)
 1808c98:	00000606 	br	1808cb4 <fstat+0xc0>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
 1808c9c:	1808ccc0 	call	1808ccc <alt_get_errno>
 1808ca0:	1007883a 	mov	r3,r2
 1808ca4:	00801444 	movi	r2,81
 1808ca8:	18800015 	stw	r2,0(r3)
    return -1;
 1808cac:	00bfffc4 	movi	r2,-1
 1808cb0:	e0bffe15 	stw	r2,-8(fp)
 1808cb4:	e0bffe17 	ldw	r2,-8(fp)
  }
}
 1808cb8:	e037883a 	mov	sp,fp
 1808cbc:	dfc00117 	ldw	ra,4(sp)
 1808cc0:	df000017 	ldw	fp,0(sp)
 1808cc4:	dec00204 	addi	sp,sp,8
 1808cc8:	f800283a 	ret

01808ccc <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 1808ccc:	defffd04 	addi	sp,sp,-12
 1808cd0:	dfc00215 	stw	ra,8(sp)
 1808cd4:	df000115 	stw	fp,4(sp)
 1808cd8:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
 1808cdc:	00806074 	movhi	r2,385
 1808ce0:	10abd204 	addi	r2,r2,-20664
 1808ce4:	10800017 	ldw	r2,0(r2)
 1808ce8:	1005003a 	cmpeq	r2,r2,zero
 1808cec:	1000061e 	bne	r2,zero,1808d08 <alt_get_errno+0x3c>
 1808cf0:	00806074 	movhi	r2,385
 1808cf4:	10abd204 	addi	r2,r2,-20664
 1808cf8:	10800017 	ldw	r2,0(r2)
 1808cfc:	103ee83a 	callr	r2
 1808d00:	e0bfff15 	stw	r2,-4(fp)
 1808d04:	00000306 	br	1808d14 <alt_get_errno+0x48>
 1808d08:	00806074 	movhi	r2,385
 1808d0c:	10b2a604 	addi	r2,r2,-13672
 1808d10:	e0bfff15 	stw	r2,-4(fp)
 1808d14:	e0bfff17 	ldw	r2,-4(fp)
}
 1808d18:	e037883a 	mov	sp,fp
 1808d1c:	dfc00117 	ldw	ra,4(sp)
 1808d20:	df000017 	ldw	fp,0(sp)
 1808d24:	dec00204 	addi	sp,sp,8
 1808d28:	f800283a 	ret

01808d2c <isatty>:
 *
 * ALT_ISATTY is mapped onto the isatty() system call in alt_syscall.h
 */
 
int ALT_ISATTY (int file)
{
 1808d2c:	deffeb04 	addi	sp,sp,-84
 1808d30:	dfc01415 	stw	ra,80(sp)
 1808d34:	df001315 	stw	fp,76(sp)
 1808d38:	df001304 	addi	fp,sp,76
 1808d3c:	e13ffd15 	stw	r4,-12(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 1808d40:	e0bffd17 	ldw	r2,-12(fp)
 1808d44:	1004803a 	cmplt	r2,r2,zero
 1808d48:	1000091e 	bne	r2,zero,1808d70 <isatty+0x44>
 1808d4c:	e13ffd17 	ldw	r4,-12(fp)
 1808d50:	01400304 	movi	r5,12
 1808d54:	1808b580 	call	1808b58 <__mulsi3>
 1808d58:	1007883a 	mov	r3,r2
 1808d5c:	00806074 	movhi	r2,385
 1808d60:	10a96b04 	addi	r2,r2,-23124
 1808d64:	1887883a 	add	r3,r3,r2
 1808d68:	e0ffff15 	stw	r3,-4(fp)
 1808d6c:	00000106 	br	1808d74 <isatty+0x48>
 1808d70:	e03fff15 	stw	zero,-4(fp)
 1808d74:	e0bfff17 	ldw	r2,-4(fp)
 1808d78:	e0bfed15 	stw	r2,-76(fp)
  
  if (fd)
 1808d7c:	e0bfed17 	ldw	r2,-76(fp)
 1808d80:	1005003a 	cmpeq	r2,r2,zero
 1808d84:	10000f1e 	bne	r2,zero,1808dc4 <isatty+0x98>
    /*
     * If a device driver does not provide an fstat() function, then it is 
     * treated as a terminal device by default.
     */

    if (!fd->dev->fstat)
 1808d88:	e0bfed17 	ldw	r2,-76(fp)
 1808d8c:	10800017 	ldw	r2,0(r2)
 1808d90:	10800817 	ldw	r2,32(r2)
 1808d94:	1004c03a 	cmpne	r2,r2,zero
 1808d98:	1000031e 	bne	r2,zero,1808da8 <isatty+0x7c>
    {
      return 1;
 1808d9c:	00800044 	movi	r2,1
 1808da0:	e0bffe15 	stw	r2,-8(fp)
 1808da4:	00000c06 	br	1808dd8 <isatty+0xac>
     * this is called so that the device can identify itself.
     */ 

    else
    {
      fstat (file, &stat);
 1808da8:	e17fee04 	addi	r5,fp,-72
 1808dac:	e13ffd17 	ldw	r4,-12(fp)
 1808db0:	1808bf40 	call	1808bf4 <fstat>
      return (stat.st_mode == _IFCHR) ? 1 : 0;
 1808db4:	e0bfef17 	ldw	r2,-68(fp)
 1808db8:	10880020 	cmpeqi	r2,r2,8192
 1808dbc:	e0bffe15 	stw	r2,-8(fp)
 1808dc0:	00000506 	br	1808dd8 <isatty+0xac>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
 1808dc4:	1808df00 	call	1808df0 <alt_get_errno>
 1808dc8:	1007883a 	mov	r3,r2
 1808dcc:	00801444 	movi	r2,81
 1808dd0:	18800015 	stw	r2,0(r3)
    return 0;
 1808dd4:	e03ffe15 	stw	zero,-8(fp)
 1808dd8:	e0bffe17 	ldw	r2,-8(fp)
  }
}
 1808ddc:	e037883a 	mov	sp,fp
 1808de0:	dfc00117 	ldw	ra,4(sp)
 1808de4:	df000017 	ldw	fp,0(sp)
 1808de8:	dec00204 	addi	sp,sp,8
 1808dec:	f800283a 	ret

01808df0 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 1808df0:	defffd04 	addi	sp,sp,-12
 1808df4:	dfc00215 	stw	ra,8(sp)
 1808df8:	df000115 	stw	fp,4(sp)
 1808dfc:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
 1808e00:	00806074 	movhi	r2,385
 1808e04:	10abd204 	addi	r2,r2,-20664
 1808e08:	10800017 	ldw	r2,0(r2)
 1808e0c:	1005003a 	cmpeq	r2,r2,zero
 1808e10:	1000061e 	bne	r2,zero,1808e2c <alt_get_errno+0x3c>
 1808e14:	00806074 	movhi	r2,385
 1808e18:	10abd204 	addi	r2,r2,-20664
 1808e1c:	10800017 	ldw	r2,0(r2)
 1808e20:	103ee83a 	callr	r2
 1808e24:	e0bfff15 	stw	r2,-4(fp)
 1808e28:	00000306 	br	1808e38 <alt_get_errno+0x48>
 1808e2c:	00806074 	movhi	r2,385
 1808e30:	10b2a604 	addi	r2,r2,-13672
 1808e34:	e0bfff15 	stw	r2,-4(fp)
 1808e38:	e0bfff17 	ldw	r2,-4(fp)
}
 1808e3c:	e037883a 	mov	sp,fp
 1808e40:	dfc00117 	ldw	ra,4(sp)
 1808e44:	df000017 	ldw	fp,0(sp)
 1808e48:	dec00204 	addi	sp,sp,8
 1808e4c:	f800283a 	ret

01808e50 <lseek>:
 * ALT_LSEEK is mapped onto the lseek() system call in alt_syscall.h
 *
 */

off_t ALT_LSEEK (int file, off_t ptr, int dir)
{
 1808e50:	defff804 	addi	sp,sp,-32
 1808e54:	dfc00715 	stw	ra,28(sp)
 1808e58:	df000615 	stw	fp,24(sp)
 1808e5c:	df000604 	addi	fp,sp,24
 1808e60:	e13ffc15 	stw	r4,-16(fp)
 1808e64:	e17ffd15 	stw	r5,-12(fp)
 1808e68:	e1bffe15 	stw	r6,-8(fp)
  alt_fd* fd;
  off_t   rc = 0; 
 1808e6c:	e03ffa15 	stw	zero,-24(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 1808e70:	e0bffc17 	ldw	r2,-16(fp)
 1808e74:	1004803a 	cmplt	r2,r2,zero
 1808e78:	1000091e 	bne	r2,zero,1808ea0 <lseek+0x50>
 1808e7c:	e13ffc17 	ldw	r4,-16(fp)
 1808e80:	01400304 	movi	r5,12
 1808e84:	1808b580 	call	1808b58 <__mulsi3>
 1808e88:	1007883a 	mov	r3,r2
 1808e8c:	00806074 	movhi	r2,385
 1808e90:	10a96b04 	addi	r2,r2,-23124
 1808e94:	1887883a 	add	r3,r3,r2
 1808e98:	e0ffff15 	stw	r3,-4(fp)
 1808e9c:	00000106 	br	1808ea4 <lseek+0x54>
 1808ea0:	e03fff15 	stw	zero,-4(fp)
 1808ea4:	e0bfff17 	ldw	r2,-4(fp)
 1808ea8:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd) 
 1808eac:	e0bffb17 	ldw	r2,-20(fp)
 1808eb0:	1005003a 	cmpeq	r2,r2,zero
 1808eb4:	1000111e 	bne	r2,zero,1808efc <lseek+0xac>
    /*
     * If the device driver provides an implementation of the lseek() function,
     * then call that to process the request.
     */
 
    if (fd->dev->lseek)
 1808eb8:	e0bffb17 	ldw	r2,-20(fp)
 1808ebc:	10800017 	ldw	r2,0(r2)
 1808ec0:	10800717 	ldw	r2,28(r2)
 1808ec4:	1005003a 	cmpeq	r2,r2,zero
 1808ec8:	1000091e 	bne	r2,zero,1808ef0 <lseek+0xa0>
    {
      rc = fd->dev->lseek(fd, ptr, dir);
 1808ecc:	e0bffb17 	ldw	r2,-20(fp)
 1808ed0:	10800017 	ldw	r2,0(r2)
 1808ed4:	10800717 	ldw	r2,28(r2)
 1808ed8:	e13ffb17 	ldw	r4,-20(fp)
 1808edc:	e17ffd17 	ldw	r5,-12(fp)
 1808ee0:	e1bffe17 	ldw	r6,-8(fp)
 1808ee4:	103ee83a 	callr	r2
 1808ee8:	e0bffa15 	stw	r2,-24(fp)
 1808eec:	00000506 	br	1808f04 <lseek+0xb4>
     * Otherwise return an error.
     */

    else
    {
      rc = -ENOTSUP;
 1808ef0:	00bfde84 	movi	r2,-134
 1808ef4:	e0bffa15 	stw	r2,-24(fp)
 1808ef8:	00000206 	br	1808f04 <lseek+0xb4>
    }
  }
  else  
  {
    rc = -EBADFD;
 1808efc:	00bfebc4 	movi	r2,-81
 1808f00:	e0bffa15 	stw	r2,-24(fp)
  }

  if (rc < 0)
 1808f04:	e0bffa17 	ldw	r2,-24(fp)
 1808f08:	1004403a 	cmpge	r2,r2,zero
 1808f0c:	1000071e 	bne	r2,zero,1808f2c <lseek+0xdc>
  {
    ALT_ERRNO = -rc;
 1808f10:	1808f440 	call	1808f44 <alt_get_errno>
 1808f14:	1007883a 	mov	r3,r2
 1808f18:	e0bffa17 	ldw	r2,-24(fp)
 1808f1c:	0085c83a 	sub	r2,zero,r2
 1808f20:	18800015 	stw	r2,0(r3)
    rc = -1;
 1808f24:	00bfffc4 	movi	r2,-1
 1808f28:	e0bffa15 	stw	r2,-24(fp)
  }

  return rc;
 1808f2c:	e0bffa17 	ldw	r2,-24(fp)
}
 1808f30:	e037883a 	mov	sp,fp
 1808f34:	dfc00117 	ldw	ra,4(sp)
 1808f38:	df000017 	ldw	fp,0(sp)
 1808f3c:	dec00204 	addi	sp,sp,8
 1808f40:	f800283a 	ret

01808f44 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 1808f44:	defffd04 	addi	sp,sp,-12
 1808f48:	dfc00215 	stw	ra,8(sp)
 1808f4c:	df000115 	stw	fp,4(sp)
 1808f50:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
 1808f54:	00806074 	movhi	r2,385
 1808f58:	10abd204 	addi	r2,r2,-20664
 1808f5c:	10800017 	ldw	r2,0(r2)
 1808f60:	1005003a 	cmpeq	r2,r2,zero
 1808f64:	1000061e 	bne	r2,zero,1808f80 <alt_get_errno+0x3c>
 1808f68:	00806074 	movhi	r2,385
 1808f6c:	10abd204 	addi	r2,r2,-20664
 1808f70:	10800017 	ldw	r2,0(r2)
 1808f74:	103ee83a 	callr	r2
 1808f78:	e0bfff15 	stw	r2,-4(fp)
 1808f7c:	00000306 	br	1808f8c <alt_get_errno+0x48>
 1808f80:	00806074 	movhi	r2,385
 1808f84:	10b2a604 	addi	r2,r2,-13672
 1808f88:	e0bfff15 	stw	r2,-4(fp)
 1808f8c:	e0bfff17 	ldw	r2,-4(fp)
}
 1808f90:	e037883a 	mov	sp,fp
 1808f94:	dfc00117 	ldw	ra,4(sp)
 1808f98:	df000017 	ldw	fp,0(sp)
 1808f9c:	dec00204 	addi	sp,sp,8
 1808fa0:	f800283a 	ret

01808fa4 <__malloc_lock>:
 * configuration is single threaded, so there is nothing to do here. Note that 
 * this requires that malloc is never called by an interrupt service routine.
 */

void __malloc_lock ( struct _reent *_r )
{
 1808fa4:	defffe04 	addi	sp,sp,-8
 1808fa8:	df000115 	stw	fp,4(sp)
 1808fac:	df000104 	addi	fp,sp,4
 1808fb0:	e13fff15 	stw	r4,-4(fp)
}
 1808fb4:	e037883a 	mov	sp,fp
 1808fb8:	df000017 	ldw	fp,0(sp)
 1808fbc:	dec00104 	addi	sp,sp,4
 1808fc0:	f800283a 	ret

01808fc4 <__malloc_unlock>:
/*
 *
 */

void __malloc_unlock ( struct _reent *_r )
{
 1808fc4:	defffe04 	addi	sp,sp,-8
 1808fc8:	df000115 	stw	fp,4(sp)
 1808fcc:	df000104 	addi	fp,sp,4
 1808fd0:	e13fff15 	stw	r4,-4(fp)
}
 1808fd4:	e037883a 	mov	sp,fp
 1808fd8:	df000017 	ldw	fp,0(sp)
 1808fdc:	dec00104 	addi	sp,sp,4
 1808fe0:	f800283a 	ret

01808fe4 <read>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_READ (int file, void *ptr, size_t len)
{
 1808fe4:	defff704 	addi	sp,sp,-36
 1808fe8:	dfc00815 	stw	ra,32(sp)
 1808fec:	df000715 	stw	fp,28(sp)
 1808ff0:	df000704 	addi	fp,sp,28
 1808ff4:	e13ffb15 	stw	r4,-20(fp)
 1808ff8:	e17ffc15 	stw	r5,-16(fp)
 1808ffc:	e1bffd15 	stw	r6,-12(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 1809000:	e0bffb17 	ldw	r2,-20(fp)
 1809004:	1004803a 	cmplt	r2,r2,zero
 1809008:	1000091e 	bne	r2,zero,1809030 <read+0x4c>
 180900c:	e13ffb17 	ldw	r4,-20(fp)
 1809010:	01400304 	movi	r5,12
 1809014:	1808b580 	call	1808b58 <__mulsi3>
 1809018:	1007883a 	mov	r3,r2
 180901c:	00806074 	movhi	r2,385
 1809020:	10a96b04 	addi	r2,r2,-23124
 1809024:	1887883a 	add	r3,r3,r2
 1809028:	e0ffff15 	stw	r3,-4(fp)
 180902c:	00000106 	br	1809034 <read+0x50>
 1809030:	e03fff15 	stw	zero,-4(fp)
 1809034:	e0bfff17 	ldw	r2,-4(fp)
 1809038:	e0bffa15 	stw	r2,-24(fp)
  
  if (fd)
 180903c:	e0bffa17 	ldw	r2,-24(fp)
 1809040:	1005003a 	cmpeq	r2,r2,zero
 1809044:	1000241e 	bne	r2,zero,18090d8 <read+0xf4>
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
 1809048:	e0bffa17 	ldw	r2,-24(fp)
 180904c:	10800217 	ldw	r2,8(r2)
 1809050:	108000cc 	andi	r2,r2,3
 1809054:	10800060 	cmpeqi	r2,r2,1
 1809058:	10001a1e 	bne	r2,zero,18090c4 <read+0xe0>
 180905c:	e0bffa17 	ldw	r2,-24(fp)
 1809060:	10800017 	ldw	r2,0(r2)
 1809064:	10800517 	ldw	r2,20(r2)
 1809068:	1005003a 	cmpeq	r2,r2,zero
 180906c:	1000151e 	bne	r2,zero,18090c4 <read+0xe0>
        (fd->dev->read))
      {
        if ((rval = fd->dev->read(fd, ptr, len)) < 0)
 1809070:	e0bffa17 	ldw	r2,-24(fp)
 1809074:	10800017 	ldw	r2,0(r2)
 1809078:	10800517 	ldw	r2,20(r2)
 180907c:	e17ffc17 	ldw	r5,-16(fp)
 1809080:	e1bffd17 	ldw	r6,-12(fp)
 1809084:	e13ffa17 	ldw	r4,-24(fp)
 1809088:	103ee83a 	callr	r2
 180908c:	e0bff915 	stw	r2,-28(fp)
 1809090:	e0bff917 	ldw	r2,-28(fp)
 1809094:	1004403a 	cmpge	r2,r2,zero
 1809098:	1000071e 	bne	r2,zero,18090b8 <read+0xd4>
        {
          ALT_ERRNO = -rval;
 180909c:	18091080 	call	1809108 <alt_get_errno>
 18090a0:	e0fff917 	ldw	r3,-28(fp)
 18090a4:	00c7c83a 	sub	r3,zero,r3
 18090a8:	10c00015 	stw	r3,0(r2)
          return -1;
 18090ac:	00bfffc4 	movi	r2,-1
 18090b0:	e0bffe15 	stw	r2,-8(fp)
 18090b4:	00000e06 	br	18090f0 <read+0x10c>
        }
        return rval;
 18090b8:	e0bff917 	ldw	r2,-28(fp)
 18090bc:	e0bffe15 	stw	r2,-8(fp)
 18090c0:	00000b06 	br	18090f0 <read+0x10c>
      }
      else
      {
        ALT_ERRNO = EACCES;
 18090c4:	18091080 	call	1809108 <alt_get_errno>
 18090c8:	1007883a 	mov	r3,r2
 18090cc:	00800344 	movi	r2,13
 18090d0:	18800015 	stw	r2,0(r3)
 18090d4:	00000406 	br	18090e8 <read+0x104>
      }
    }
  else
  {
    ALT_ERRNO = EBADFD;
 18090d8:	18091080 	call	1809108 <alt_get_errno>
 18090dc:	1007883a 	mov	r3,r2
 18090e0:	00801444 	movi	r2,81
 18090e4:	18800015 	stw	r2,0(r3)
  }
  return -1;
 18090e8:	00bfffc4 	movi	r2,-1
 18090ec:	e0bffe15 	stw	r2,-8(fp)
 18090f0:	e0bffe17 	ldw	r2,-8(fp)
}
 18090f4:	e037883a 	mov	sp,fp
 18090f8:	dfc00117 	ldw	ra,4(sp)
 18090fc:	df000017 	ldw	fp,0(sp)
 1809100:	dec00204 	addi	sp,sp,8
 1809104:	f800283a 	ret

01809108 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 1809108:	defffd04 	addi	sp,sp,-12
 180910c:	dfc00215 	stw	ra,8(sp)
 1809110:	df000115 	stw	fp,4(sp)
 1809114:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
 1809118:	00806074 	movhi	r2,385
 180911c:	10abd204 	addi	r2,r2,-20664
 1809120:	10800017 	ldw	r2,0(r2)
 1809124:	1005003a 	cmpeq	r2,r2,zero
 1809128:	1000061e 	bne	r2,zero,1809144 <alt_get_errno+0x3c>
 180912c:	00806074 	movhi	r2,385
 1809130:	10abd204 	addi	r2,r2,-20664
 1809134:	10800017 	ldw	r2,0(r2)
 1809138:	103ee83a 	callr	r2
 180913c:	e0bfff15 	stw	r2,-4(fp)
 1809140:	00000306 	br	1809150 <alt_get_errno+0x48>
 1809144:	00806074 	movhi	r2,385
 1809148:	10b2a604 	addi	r2,r2,-13672
 180914c:	e0bfff15 	stw	r2,-4(fp)
 1809150:	e0bfff17 	ldw	r2,-4(fp)
}
 1809154:	e037883a 	mov	sp,fp
 1809158:	dfc00117 	ldw	ra,4(sp)
 180915c:	df000017 	ldw	fp,0(sp)
 1809160:	dec00204 	addi	sp,sp,8
 1809164:	f800283a 	ret

01809168 <sbrk>:
#endif
 
caddr_t ALT_SBRK (int incr) __attribute__ ((no_instrument_function ));

caddr_t ALT_SBRK (int incr)
{ 
 1809168:	defff804 	addi	sp,sp,-32
 180916c:	df000715 	stw	fp,28(sp)
 1809170:	df000704 	addi	fp,sp,28
 1809174:	e13ffe15 	stw	r4,-8(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 1809178:	0005303a 	rdctl	r2,status
 180917c:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 1809180:	e0fffb17 	ldw	r3,-20(fp)
 1809184:	00bfff84 	movi	r2,-2
 1809188:	1884703a 	and	r2,r3,r2
 180918c:	1001703a 	wrctl	status,r2
  
  return context;
 1809190:	e0bffb17 	ldw	r2,-20(fp)
  alt_irq_context context;
  char *prev_heap_end; 

  context = alt_irq_disable_all();
 1809194:	e0bffd15 	stw	r2,-12(fp)

  /* Always return data aligned on a word boundary */
  heap_end = (char *)(((unsigned int)heap_end + 3) & ~3);
 1809198:	d0a00d17 	ldw	r2,-32716(gp)
 180919c:	10c000c4 	addi	r3,r2,3
 18091a0:	00bfff04 	movi	r2,-4
 18091a4:	1884703a 	and	r2,r3,r2
 18091a8:	d0a00d15 	stw	r2,-32716(gp)
  if (((heap_end + incr) - __alt_heap_start) > ALT_MAX_HEAP_BYTES) {
    alt_irq_enable_all(context);
    return (caddr_t)-1;
  }
#else
  if ((heap_end + incr) > __alt_heap_limit) {
 18091ac:	d0e00d17 	ldw	r3,-32716(gp)
 18091b0:	e0bffe17 	ldw	r2,-8(fp)
 18091b4:	1887883a 	add	r3,r3,r2
 18091b8:	00808034 	movhi	r2,512
 18091bc:	10800004 	addi	r2,r2,0
 18091c0:	10c0072e 	bgeu	r2,r3,18091e0 <sbrk+0x78>
 18091c4:	e0bffd17 	ldw	r2,-12(fp)
 18091c8:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 18091cc:	e0bffa17 	ldw	r2,-24(fp)
 18091d0:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
    return (caddr_t)-1;
 18091d4:	00bfffc4 	movi	r2,-1
 18091d8:	e0bfff15 	stw	r2,-4(fp)
 18091dc:	00000c06 	br	1809210 <sbrk+0xa8>
  }
#endif

  prev_heap_end = heap_end; 
 18091e0:	d0a00d17 	ldw	r2,-32716(gp)
 18091e4:	e0bffc15 	stw	r2,-16(fp)
  heap_end += incr; 
 18091e8:	d0e00d17 	ldw	r3,-32716(gp)
 18091ec:	e0bffe17 	ldw	r2,-8(fp)
 18091f0:	1885883a 	add	r2,r3,r2
 18091f4:	d0a00d15 	stw	r2,-32716(gp)
 18091f8:	e0bffd17 	ldw	r2,-12(fp)
 18091fc:	e0bff915 	stw	r2,-28(fp)
 1809200:	e0bff917 	ldw	r2,-28(fp)
 1809204:	1001703a 	wrctl	status,r2

#endif

  alt_irq_enable_all(context);

  return (caddr_t) prev_heap_end; 
 1809208:	e0bffc17 	ldw	r2,-16(fp)
 180920c:	e0bfff15 	stw	r2,-4(fp)
 1809210:	e0bfff17 	ldw	r2,-4(fp)
} 
 1809214:	e037883a 	mov	sp,fp
 1809218:	df000017 	ldw	fp,0(sp)
 180921c:	dec00104 	addi	sp,sp,4
 1809220:	f800283a 	ret

01809224 <write>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_WRITE (int file, const void *ptr, size_t len)
{
 1809224:	defff704 	addi	sp,sp,-36
 1809228:	dfc00815 	stw	ra,32(sp)
 180922c:	df000715 	stw	fp,28(sp)
 1809230:	df000704 	addi	fp,sp,28
 1809234:	e13ffb15 	stw	r4,-20(fp)
 1809238:	e17ffc15 	stw	r5,-16(fp)
 180923c:	e1bffd15 	stw	r6,-12(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 1809240:	e0bffb17 	ldw	r2,-20(fp)
 1809244:	1004803a 	cmplt	r2,r2,zero
 1809248:	1000091e 	bne	r2,zero,1809270 <write+0x4c>
 180924c:	e13ffb17 	ldw	r4,-20(fp)
 1809250:	01400304 	movi	r5,12
 1809254:	1808b580 	call	1808b58 <__mulsi3>
 1809258:	1007883a 	mov	r3,r2
 180925c:	00806074 	movhi	r2,385
 1809260:	10a96b04 	addi	r2,r2,-23124
 1809264:	1887883a 	add	r3,r3,r2
 1809268:	e0ffff15 	stw	r3,-4(fp)
 180926c:	00000106 	br	1809274 <write+0x50>
 1809270:	e03fff15 	stw	zero,-4(fp)
 1809274:	e0bfff17 	ldw	r2,-4(fp)
 1809278:	e0bffa15 	stw	r2,-24(fp)
  
  if (fd)
 180927c:	e0bffa17 	ldw	r2,-24(fp)
 1809280:	1005003a 	cmpeq	r2,r2,zero
 1809284:	1000241e 	bne	r2,zero,1809318 <write+0xf4>
     * If the file has not been opened with write access, or if the driver does
     * not provide an implementation of write(), generate an error. Otherwise
     * call the drivers write() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_RDONLY) && fd->dev->write)
 1809288:	e0bffa17 	ldw	r2,-24(fp)
 180928c:	10800217 	ldw	r2,8(r2)
 1809290:	108000cc 	andi	r2,r2,3
 1809294:	1005003a 	cmpeq	r2,r2,zero
 1809298:	10001a1e 	bne	r2,zero,1809304 <write+0xe0>
 180929c:	e0bffa17 	ldw	r2,-24(fp)
 18092a0:	10800017 	ldw	r2,0(r2)
 18092a4:	10800617 	ldw	r2,24(r2)
 18092a8:	1005003a 	cmpeq	r2,r2,zero
 18092ac:	1000151e 	bne	r2,zero,1809304 <write+0xe0>
    {
      
      /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */
      ALT_LOG_WRITE_FUNCTION(ptr,len);

      if ((rval = fd->dev->write(fd, ptr, len)) < 0)
 18092b0:	e0bffa17 	ldw	r2,-24(fp)
 18092b4:	10800017 	ldw	r2,0(r2)
 18092b8:	10800617 	ldw	r2,24(r2)
 18092bc:	e17ffc17 	ldw	r5,-16(fp)
 18092c0:	e1bffd17 	ldw	r6,-12(fp)
 18092c4:	e13ffa17 	ldw	r4,-24(fp)
 18092c8:	103ee83a 	callr	r2
 18092cc:	e0bff915 	stw	r2,-28(fp)
 18092d0:	e0bff917 	ldw	r2,-28(fp)
 18092d4:	1004403a 	cmpge	r2,r2,zero
 18092d8:	1000071e 	bne	r2,zero,18092f8 <write+0xd4>
      {
        ALT_ERRNO = -rval;
 18092dc:	18093480 	call	1809348 <alt_get_errno>
 18092e0:	e0fff917 	ldw	r3,-28(fp)
 18092e4:	00c7c83a 	sub	r3,zero,r3
 18092e8:	10c00015 	stw	r3,0(r2)
        return -1;
 18092ec:	00bfffc4 	movi	r2,-1
 18092f0:	e0bffe15 	stw	r2,-8(fp)
 18092f4:	00000e06 	br	1809330 <write+0x10c>
      }
      return rval;
 18092f8:	e0bff917 	ldw	r2,-28(fp)
 18092fc:	e0bffe15 	stw	r2,-8(fp)
 1809300:	00000b06 	br	1809330 <write+0x10c>
    }
    else
    {
      ALT_ERRNO = EACCES;
 1809304:	18093480 	call	1809348 <alt_get_errno>
 1809308:	1007883a 	mov	r3,r2
 180930c:	00800344 	movi	r2,13
 1809310:	18800015 	stw	r2,0(r3)
 1809314:	00000406 	br	1809328 <write+0x104>
    }
  }
  else  
  {
    ALT_ERRNO = EBADFD;
 1809318:	18093480 	call	1809348 <alt_get_errno>
 180931c:	1007883a 	mov	r3,r2
 1809320:	00801444 	movi	r2,81
 1809324:	18800015 	stw	r2,0(r3)
  }
  return -1;
 1809328:	00bfffc4 	movi	r2,-1
 180932c:	e0bffe15 	stw	r2,-8(fp)
 1809330:	e0bffe17 	ldw	r2,-8(fp)
}
 1809334:	e037883a 	mov	sp,fp
 1809338:	dfc00117 	ldw	ra,4(sp)
 180933c:	df000017 	ldw	fp,0(sp)
 1809340:	dec00204 	addi	sp,sp,8
 1809344:	f800283a 	ret

01809348 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 1809348:	defffd04 	addi	sp,sp,-12
 180934c:	dfc00215 	stw	ra,8(sp)
 1809350:	df000115 	stw	fp,4(sp)
 1809354:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
 1809358:	00806074 	movhi	r2,385
 180935c:	10abd204 	addi	r2,r2,-20664
 1809360:	10800017 	ldw	r2,0(r2)
 1809364:	1005003a 	cmpeq	r2,r2,zero
 1809368:	1000061e 	bne	r2,zero,1809384 <alt_get_errno+0x3c>
 180936c:	00806074 	movhi	r2,385
 1809370:	10abd204 	addi	r2,r2,-20664
 1809374:	10800017 	ldw	r2,0(r2)
 1809378:	103ee83a 	callr	r2
 180937c:	e0bfff15 	stw	r2,-4(fp)
 1809380:	00000306 	br	1809390 <alt_get_errno+0x48>
 1809384:	00806074 	movhi	r2,385
 1809388:	10b2a604 	addi	r2,r2,-13672
 180938c:	e0bfff15 	stw	r2,-4(fp)
 1809390:	e0bfff17 	ldw	r2,-4(fp)
}
 1809394:	e037883a 	mov	sp,fp
 1809398:	dfc00117 	ldw	ra,4(sp)
 180939c:	df000017 	ldw	fp,0(sp)
 18093a0:	dec00204 	addi	sp,sp,8
 18093a4:	f800283a 	ret
 18093a8:	01807768 	cmpgeui	r6,zero,477
